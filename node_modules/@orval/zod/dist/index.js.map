{"version":3,"file":"index.js","names":["ZOD_DEPENDENCIES: GeneratorDependency[]","constsUniqueCounter: Record<string, number>","consts: string[]","functions: [string, any][]","defaultVarName: string | undefined","defaultValue: string","schema","value","childContext: ContextSpecs","resolvedContext: ContextSpecs","headers: ZodValidationSchemaDefinition","queryParams: ZodValidationSchemaDefinition","params: ZodValidationSchemaDefinition","generateZod: ClientBuilder","zodClientBuilder: ClientGeneratorsBuilder"],"sources":["../src/compatibleV4.ts","../src/index.ts"],"sourcesContent":["import { compareVersions, PackageJson } from '@orval/core';\n\nconst getZodPackageVersion = (packageJson: PackageJson) => {\n  return (\n    packageJson.dependencies?.zod ??\n    packageJson.devDependencies?.zod ??\n    packageJson.peerDependencies?.zod\n  );\n};\n\nexport const isZodVersionV4 = (packageJson: PackageJson) => {\n  const version = getZodPackageVersion(packageJson);\n\n  if (!version) {\n    return false;\n  }\n\n  const withoutRc = version.split('-')[0];\n\n  return compareVersions(withoutRc, '4.0.0');\n};\n\nexport const getZodDateFormat = (isZodV4: boolean) => {\n  return isZodV4 ? 'iso.date' : 'date';\n};\n\nexport const getZodTimeFormat = (isZodV4: boolean) => {\n  return isZodV4 ? 'iso.time' : 'time';\n};\n\nexport const getZodDateTimeFormat = (isZodV4: boolean) => {\n  return isZodV4 ? 'iso.datetime' : 'datetime';\n};\n\nexport const getParameterFunctions = (\n  isZodV4: boolean,\n  strict: boolean,\n  parameters: Record<string, any>,\n): [string, any][] => {\n  if (isZodV4 && strict) {\n    return [['strictObject', parameters]];\n  } else {\n    return strict\n      ? [\n          ['object', parameters],\n          ['strict', undefined],\n        ]\n      : [['object', parameters]];\n  }\n};\n\nexport const getObjectFunctionName = (isZodV4: boolean, strict: boolean) => {\n  return isZodV4 && strict ? 'strictObject' : 'object';\n};\n","import {\n  camel,\n  ClientBuilder,\n  ClientGeneratorsBuilder,\n  ContextSpecs,\n  escape,\n  generateMutator,\n  GeneratorDependency,\n  GeneratorMutator,\n  GeneratorOptions,\n  GeneratorVerbOptions,\n  getNumberWord,\n  getRefInfo,\n  isBoolean,\n  isObject,\n  isString,\n  jsStringEscape,\n  pascal,\n  resolveRef,\n  stringify,\n  ZodCoerceType,\n} from '@orval/core';\nimport uniq from 'lodash.uniq';\nimport {\n  ParameterObject,\n  PathItemObject,\n  ReferenceObject,\n  RequestBodyObject,\n  ResponseObject,\n  SchemaObject,\n} from 'openapi3-ts/oas30';\nimport { SchemaObject as SchemaObject31 } from 'openapi3-ts/oas31';\n\nimport {\n  getObjectFunctionName,\n  getParameterFunctions,\n  getZodDateFormat,\n  getZodDateTimeFormat,\n  getZodTimeFormat,\n  isZodVersionV4,\n} from './compatibleV4';\n\nconst ZOD_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      {\n        default: true,\n        name: 'zod',\n        syntheticDefaultImport: true,\n        values: true,\n      },\n    ],\n    dependency: 'zod',\n  },\n];\n\nexport const getZodDependencies = () => ZOD_DEPENDENCIES;\n\n/**\n * values that may appear in \"type\". Equals SchemaObjectType\n */\nconst possibleSchemaTypes = new Set([\n  'integer',\n  'number',\n  'string',\n  'boolean',\n  'object',\n  'strictObject',\n  'null',\n  'array',\n]);\n\nconst resolveZodType = (schema: SchemaObject | SchemaObject31) => {\n  const schemaTypeValue = schema.type;\n  const type = Array.isArray(schemaTypeValue)\n    ? schemaTypeValue.find((t) => possibleSchemaTypes.has(t))\n    : schemaTypeValue;\n\n  // TODO: if \"prefixItems\" exists and type is \"array\", then generate a \"tuple\"\n  if (schema.type === 'array' && 'prefixItems' in schema) {\n    return 'tuple';\n  }\n\n  switch (type) {\n    case 'integer': {\n      return 'number';\n    }\n    default: {\n      return type ?? 'any';\n    }\n  }\n};\n\nconst constsUniqueCounter: Record<string, number> = {};\n\n// https://github.com/colinhacks/zod#coercion-for-primitives\nconst COERCIBLE_TYPES = new Set([\n  'string',\n  'number',\n  'boolean',\n  'bigint',\n  'date',\n]);\n\nexport type ZodValidationSchemaDefinition = {\n  functions: [string, any][];\n  consts: string[];\n};\n\nconst minAndMaxTypes = new Set(['number', 'string', 'array']);\n\nconst removeReadOnlyProperties = (schema: SchemaObject): SchemaObject => {\n  if (schema.properties) {\n    return {\n      ...schema,\n      properties: Object.entries(schema.properties).reduce<\n        Record<string, SchemaObject>\n      >((acc, [key, value]) => {\n        if ('readOnly' in value && value.readOnly) return acc;\n        acc[key] = value as SchemaObject;\n        return acc;\n      }, {}),\n    };\n  }\n  if (schema.items && 'properties' in schema.items) {\n    return {\n      ...schema,\n      items: removeReadOnlyProperties(schema.items as SchemaObject),\n    };\n  }\n  return schema;\n};\n\ntype DateTimeOptions = {\n  offset?: boolean;\n  local?: boolean;\n  precision?: number;\n};\n\ntype TimeOptions = {\n  precision?: -1 | 0 | 1 | 2 | 3;\n};\n\nexport const generateZodValidationSchemaDefinition = (\n  schema: SchemaObject | SchemaObject31 | undefined,\n  context: ContextSpecs,\n  name: string,\n  strict: boolean,\n  isZodV4: boolean,\n  rules?: {\n    required?: boolean;\n    dateTimeOptions?: DateTimeOptions;\n    timeOptions?: TimeOptions;\n  },\n): ZodValidationSchemaDefinition => {\n  if (!schema) return { functions: [], consts: [] };\n\n  const consts: string[] = [];\n  const constsCounter =\n    typeof constsUniqueCounter[name] === 'number'\n      ? constsUniqueCounter[name] + 1\n      : 0;\n\n  const constsCounterValue = constsCounter\n    ? pascal(getNumberWord(constsCounter))\n    : '';\n\n  constsUniqueCounter[name] = constsCounter;\n\n  const functions: [string, any][] = [];\n  const type = resolveZodType(schema);\n  const required = rules?.required ?? false;\n  const nullable =\n    ('nullable' in schema && schema.nullable) ||\n    (Array.isArray(schema.type) && schema.type.includes('null'));\n  const min = schema.minimum ?? schema.minLength ?? schema.minItems;\n  const max = schema.maximum ?? schema.maxLength ?? schema.maxItems;\n  const multipleOf = schema.multipleOf;\n  const matches = schema.pattern ?? undefined;\n\n  let defaultVarName: string | undefined;\n  if (schema.default !== undefined) {\n    defaultVarName = `${name}Default${constsCounterValue}`;\n    let defaultValue: string;\n\n    const isDateType =\n      schema.type === 'string' &&\n      (schema.format === 'date' || schema.format === 'date-time') &&\n      context.output.override.useDates;\n\n    if (isDateType) {\n      defaultValue = `new Date(\"${escape(schema.default)}\")`;\n    } else if (isObject(schema.default)) {\n      const entries = Object.entries(schema.default)\n        .map(([key, value]) => {\n          if (isString(value)) {\n            return `${key}: \"${escape(value)}\"`;\n          }\n\n          if (Array.isArray(value)) {\n            const arrayItems = value.map((item) =>\n              isString(item) ? `\"${escape(item)}\"` : `${item}`,\n            );\n            return `${key}: [${arrayItems.join(', ')}]`;\n          }\n\n          return `${key}: ${value}`;\n        })\n        .join(', ');\n      defaultValue = `{ ${entries} }`;\n    } else {\n      const rawStringified = stringify(schema.default);\n      defaultValue =\n        rawStringified === undefined\n          ? 'null'\n          : rawStringified.replaceAll(\"'\", '\"');\n    }\n    consts.push(`export const ${defaultVarName} = ${defaultValue};`);\n  }\n\n  switch (type) {\n    case 'tuple': {\n      /**\n       *\n       * > 10.3.1.1. prefixItems\n       * > The value of \"prefixItems\" MUST be a non-empty array of valid JSON Schemas.\n       * >\n       * > Validation succeeds if each element of the instance validates against the schema at the same position, if any.\n       * > This keyword does not constrain the length of the array. If the array is longer than this keyword's value,\n       * > this keyword validates only the prefix of matching length.\n       * >\n       * > This keyword produces an annotation value which is the largest index to which this keyword applied a subschema.\n       * > The value MAY be a boolean true if a subschema was applied to every index of the instance, such as is produced by the \"items\" keyword.\n       * > This annotation affects the behavior of \"items\" and \"unevaluatedItems\".\n       * >\n       * > Omitting this keyword has the same assertion behavior as an empty array.\n       */\n      if ('prefixItems' in schema) {\n        const schema31 = schema as SchemaObject31;\n\n        if (schema31.prefixItems && schema31.prefixItems.length > 0) {\n          functions.push([\n            'tuple',\n            schema31.prefixItems.map((item, idx) =>\n              generateZodValidationSchemaDefinition(\n                deference(item as SchemaObject | ReferenceObject, context),\n                context,\n                camel(`${name}-${idx}-item`),\n                isZodV4,\n                strict,\n                {\n                  required: true,\n                },\n              ),\n            ),\n          ]);\n\n          if (\n            schema.items &&\n            (max || Number.POSITIVE_INFINITY) > schema31.prefixItems.length\n          ) {\n            // only add zod.rest() if number of tuple elements can exceed provided prefixItems:\n            functions.push([\n              'rest',\n              generateZodValidationSchemaDefinition(\n                schema.items as SchemaObject | undefined,\n                context,\n                camel(`${name}-item`),\n                strict,\n                isZodV4,\n                {\n                  required: true,\n                },\n              ),\n            ]);\n          }\n        }\n      }\n      break;\n    }\n    case 'array': {\n      functions.push([\n        'array',\n        generateZodValidationSchemaDefinition(\n          schema.items as SchemaObject | undefined,\n          context,\n          camel(`${name}-item`),\n          strict,\n          isZodV4,\n          {\n            required: true,\n          },\n        ),\n      ]);\n      break;\n    }\n    case 'string': {\n      if (schema.enum && type === 'string') {\n        break;\n      }\n\n      if (\n        context.output.override.useDates &&\n        (schema.format === 'date' || schema.format === 'date-time')\n      ) {\n        functions.push(['date', undefined]);\n        break;\n      }\n\n      if (schema.format === 'binary') {\n        functions.push(['instanceof', 'File']);\n        break;\n      }\n\n      if (isZodV4) {\n        if (\n          ![\n            'date',\n            'time',\n            'date-time',\n            'email',\n            'uri',\n            'hostname',\n            'uuid',\n          ].includes(schema.format || '')\n        ) {\n          if ('const' in schema) {\n            functions.push(['literal', `\"${schema.const}\"`]);\n          } else {\n            functions.push([type as string, undefined]);\n          }\n          break;\n        }\n      } else {\n        if ('const' in schema) {\n          functions.push(['literal', `\"${schema.const}\"`]);\n        } else {\n          functions.push([type as string, undefined]);\n        }\n      }\n\n      if (schema.format === 'date') {\n        const formatAPI = getZodDateFormat(isZodV4);\n\n        functions.push([formatAPI, undefined]);\n        break;\n      }\n\n      if (schema.format === 'time') {\n        const options = context.output.override.zod?.timeOptions;\n        const formatAPI = getZodTimeFormat(isZodV4);\n\n        functions.push([\n          formatAPI,\n          options ? JSON.stringify(options) : undefined,\n        ]);\n        break;\n      }\n\n      if (schema.format === 'date-time') {\n        const options = context.output.override.zod?.dateTimeOptions;\n        const formatAPI = getZodDateTimeFormat(isZodV4);\n\n        functions.push([\n          formatAPI,\n          options ? JSON.stringify(options) : undefined,\n        ]);\n        break;\n      }\n\n      if (schema.format === 'email') {\n        functions.push(['email', undefined]);\n        break;\n      }\n\n      if (schema.format === 'uri' || schema.format === 'hostname') {\n        functions.push(['url', undefined]);\n        break;\n      }\n\n      if (schema.format === 'uuid') {\n        functions.push(['uuid', undefined]);\n        break;\n      }\n\n      break;\n    }\n    case 'object':\n    default: {\n      if (schema.allOf || schema.oneOf || schema.anyOf) {\n        const separator = schema.allOf\n          ? 'allOf'\n          : schema.oneOf\n            ? 'oneOf'\n            : 'anyOf';\n\n        const schemas = (schema.allOf ?? schema.oneOf ?? schema.anyOf) as (\n          | SchemaObject\n          | ReferenceObject\n        )[];\n\n        functions.push([\n          separator,\n          schemas.map((schema) =>\n            generateZodValidationSchemaDefinition(\n              schema as SchemaObject,\n              context,\n              camel(name),\n              strict,\n              isZodV4,\n              {\n                required: true,\n              },\n            ),\n          ),\n        ]);\n        break;\n      }\n\n      if (schema.properties) {\n        const objectType = getObjectFunctionName(isZodV4, strict);\n\n        functions.push([\n          objectType,\n          Object.keys(schema.properties)\n            .map((key) => ({\n              [key]: generateZodValidationSchemaDefinition(\n                schema.properties?.[key] as any,\n                context,\n                camel(`${name}-${key}`),\n                strict,\n                isZodV4,\n                {\n                  required: schema.required?.includes(key),\n                },\n              ),\n            }))\n            .reduce((acc, curr) => ({ ...acc, ...curr }), {}),\n        ]);\n\n        if (strict && !isZodV4) {\n          functions.push(['strict', undefined]);\n        }\n\n        break;\n      }\n\n      if (schema.additionalProperties) {\n        functions.push([\n          'additionalProperties',\n          generateZodValidationSchemaDefinition(\n            isBoolean(schema.additionalProperties)\n              ? {}\n              : (schema.additionalProperties as SchemaObject),\n            context,\n            name,\n            strict,\n            isZodV4,\n            {\n              required: true,\n            },\n          ),\n        ]);\n\n        break;\n      }\n\n      if (schema.enum) {\n        break;\n      }\n\n      functions.push([type as string, undefined]);\n\n      break;\n    }\n  }\n\n  if (minAndMaxTypes.has(type)) {\n    if (min !== undefined) {\n      if (min === 1) {\n        functions.push(['min', `${min}`]);\n      } else {\n        consts.push(`export const ${name}Min${constsCounterValue} = ${min};`);\n        functions.push(['min', `${name}Min${constsCounterValue}`]);\n      }\n    }\n    if (max !== undefined) {\n      consts.push(`export const ${name}Max${constsCounterValue} = ${max};`);\n      functions.push(['max', `${name}Max${constsCounterValue}`]);\n    }\n    if (multipleOf !== undefined) {\n      consts.push(\n        `export const ${name}MultipleOf${constsCounterValue} = ${multipleOf.toString()};`,\n      );\n      functions.push(['multipleOf', `${name}MultipleOf${constsCounterValue}`]);\n    }\n  }\n\n  if (matches) {\n    const isStartWithSlash = matches.startsWith('/');\n    const isEndWithSlash = matches.endsWith('/');\n\n    const regexp = `new RegExp('${jsStringEscape(\n      matches.slice(isStartWithSlash ? 1 : 0, isEndWithSlash ? -1 : undefined),\n    )}')`;\n\n    consts.push(\n      `export const ${name}RegExp${constsCounterValue} = ${regexp};\\n`,\n    );\n    functions.push(['regex', `${name}RegExp${constsCounterValue}`]);\n  }\n\n  if (schema.enum) {\n    if (schema.enum.every((value) => isString(value))) {\n      functions.push([\n        'enum',\n        `[${schema.enum.map((value) => `'${escape(value)}'`).join(', ')}]`,\n      ]);\n    } else {\n      functions.push([\n        'oneOf',\n        schema.enum.map((value) => ({\n          functions: [\n            ['literal', isString(value) ? `'${escape(value)}'` : value],\n          ],\n          consts: [],\n        })),\n      ]);\n    }\n  }\n\n  if (!required && schema.default) {\n    functions.push(['default', defaultVarName]);\n  } else if (!required && nullable) {\n    functions.push(['nullish', undefined]);\n  } else if (nullable) {\n    functions.push(['nullable', undefined]);\n  } else if (!required) {\n    functions.push(['optional', undefined]);\n  }\n\n  if (schema.description) {\n    functions.push(['describe', `'${jsStringEscape(schema.description)}'`]);\n  }\n\n  return { functions, consts: uniq(consts) };\n};\n\nexport const parseZodValidationSchemaDefinition = (\n  input: ZodValidationSchemaDefinition,\n  context: ContextSpecs,\n  coerceTypes: boolean | ZodCoerceType[] = false,\n  strict: boolean,\n  isZodV4: boolean,\n  preprocess?: GeneratorMutator,\n): { zod: string; consts: string } => {\n  if (input.functions.length === 0) {\n    return { zod: '', consts: '' };\n  }\n\n  let consts = '';\n\n  const parseProperty = (property: [string, any]): string => {\n    const [fn, args = ''] = property;\n\n    if (fn === 'allOf') {\n      return args.reduce(\n        (\n          acc: string,\n          {\n            functions,\n            consts: argConsts,\n          }: { functions: [string, any][]; consts: string[] },\n        ) => {\n          const value = functions.map(parseProperty).join('');\n          const valueWithZod = `${value.startsWith('.') ? 'zod' : ''}${value}`;\n\n          if (argConsts.length > 0) {\n            consts += argConsts.join('\\n');\n          }\n\n          if (!acc) {\n            acc += valueWithZod;\n            return acc;\n          }\n\n          acc += `.and(${valueWithZod})`;\n\n          return acc;\n        },\n        '',\n      );\n    }\n    if (fn === 'oneOf' || fn === 'anyOf') {\n      // Can't use zod.union() with a single item\n      if (args.length === 1) {\n        return args[0].functions.map(parseProperty).join('');\n      }\n\n      const union = args.map(\n        ({\n          functions,\n          consts: argConsts,\n        }: {\n          functions: [string, any][];\n          consts: string[];\n        }) => {\n          const value = functions.map(parseProperty).join('');\n          const valueWithZod = `${value.startsWith('.') ? 'zod' : ''}${value}`;\n          // consts are missing here\n          consts += argConsts?.join('\\n');\n          return valueWithZod;\n        },\n      );\n\n      return `.union([${union}])`;\n    }\n\n    if (fn === 'additionalProperties') {\n      const value = args.functions.map(parseProperty).join('');\n      const valueWithZod = `${value.startsWith('.') ? 'zod' : ''}${value}`;\n      consts += args.consts;\n      return `zod.record(zod.string(), ${valueWithZod})`;\n    }\n\n    if (fn === 'object' || fn === 'strictObject') {\n      const objectType = getObjectFunctionName(isZodV4, strict);\n\n      return `zod.${objectType}({\n${Object.entries(args)\n  .map(([key, schema]) => {\n    const value = (schema as ZodValidationSchemaDefinition).functions\n      .map(parseProperty)\n      .join('');\n    consts += (schema as ZodValidationSchemaDefinition).consts.join('\\n');\n    return `  \"${key}\": ${value.startsWith('.') ? 'zod' : ''}${value}`;\n  })\n  .join(',\\n')}\n})`;\n    }\n    if (fn === 'array') {\n      const value = args.functions.map(parseProperty).join('');\n      if (typeof args.consts === 'string') {\n        consts += args.consts;\n      } else if (Array.isArray(args.consts)) {\n        consts += args.consts.join('\\n');\n      }\n      return `.array(${value.startsWith('.') ? 'zod' : ''}${value})`;\n    }\n\n    if (fn === 'strict' && !isZodV4) {\n      return '.strict()';\n    }\n\n    if (fn === 'tuple') {\n      return `zod.tuple([${(args as ZodValidationSchemaDefinition[])\n        .map((x) => {\n          const value = x.functions.map(parseProperty).join('');\n          return `${value.startsWith('.') ? 'zod' : ''}${value}`;\n        })\n        .join(',\\n')}])`;\n    }\n    if (fn === 'rest') {\n      return `.rest(zod${(args as ZodValidationSchemaDefinition).functions.map(parseProperty)})`;\n    }\n    const shouldCoerceType =\n      coerceTypes &&\n      (Array.isArray(coerceTypes)\n        ? coerceTypes.includes(fn as ZodCoerceType)\n        : COERCIBLE_TYPES.has(fn));\n\n    if (\n      (fn !== 'date' && shouldCoerceType) ||\n      (fn === 'date' && shouldCoerceType && context.output.override.useDates)\n    ) {\n      return `.coerce.${fn}(${args})`;\n    }\n\n    return `.${fn}(${args})`;\n  };\n\n  consts += input.consts.join('\\n');\n\n  const schema = input.functions.map(parseProperty).join('');\n  const value = preprocess\n    ? `.preprocess(${preprocess.name}, ${\n        schema.startsWith('.') ? 'zod' : ''\n      }${schema})`\n    : schema;\n\n  const zod = `${value.startsWith('.') ? 'zod' : ''}${value}`;\n  // Some export consts includes `,` as prefix, adding replace to remove those\n  if (consts?.includes(',export')) {\n    consts = consts.replaceAll(',export', '\\nexport');\n  }\n  return { zod, consts };\n};\n\nconst deferenceScalar = (value: any, context: ContextSpecs): unknown => {\n  if (isObject(value)) {\n    return deference(value, context);\n  } else if (Array.isArray(value)) {\n    return value.map((item) => deferenceScalar(item, context));\n  } else {\n    return value;\n  }\n};\n\nconst deference = (\n  schema: SchemaObject | ReferenceObject,\n  context: ContextSpecs,\n): SchemaObject => {\n  const refName = '$ref' in schema ? schema.$ref : undefined;\n  if (refName && context.parents?.includes(refName)) {\n    return {};\n  }\n\n  const childContext: ContextSpecs = {\n    ...context,\n    ...(refName\n      ? { parents: [...(context.parents || []), refName] }\n      : undefined),\n  };\n\n  const { schema: resolvedSchema } = resolveRef<SchemaObject>(\n    schema,\n    childContext,\n  );\n\n  const resolvedSpecKey = refName\n    ? getRefInfo(refName, context).specKey\n    : undefined;\n\n  const resolvedContext: ContextSpecs = {\n    ...childContext,\n    specKey: resolvedSpecKey ?? childContext.specKey,\n  };\n\n  return Object.entries(resolvedSchema).reduce<any>((acc, [key, value]) => {\n    if (key === 'properties' && isObject(value)) {\n      acc[key] = Object.entries(value).reduce<Record<string, SchemaObject>>(\n        (props, [propKey, propSchema]) => {\n          props[propKey] = deference(\n            propSchema as SchemaObject | ReferenceObject,\n            resolvedContext,\n          );\n          return props;\n        },\n        {},\n      );\n    } else if (key === 'default' || key === 'example' || key === 'examples') {\n      acc[key] = value;\n    } else {\n      acc[key] = deferenceScalar(value, resolvedContext);\n    }\n\n    return acc;\n  }, {});\n};\n\nconst parseBodyAndResponse = ({\n  data,\n  context,\n  name,\n  strict,\n  generate,\n  isZodV4,\n  parseType,\n}: {\n  data: ResponseObject | RequestBodyObject | ReferenceObject | undefined;\n  context: ContextSpecs;\n  name: string;\n  strict: boolean;\n  generate: boolean;\n  isZodV4: boolean;\n  parseType: 'body' | 'response';\n}): {\n  input: ZodValidationSchemaDefinition;\n  isArray: boolean;\n  rules?: {\n    min?: number;\n    max?: number;\n  };\n} => {\n  if (!data || !generate) {\n    return {\n      input: { functions: [], consts: [] },\n      isArray: false,\n    };\n  }\n\n  const resolvedRef = resolveRef<ResponseObject | RequestBodyObject>(\n    data,\n    context,\n  ).schema;\n\n  const schema =\n    resolvedRef.content?.['application/json']?.schema ||\n    resolvedRef.content?.['multipart/form-data']?.schema;\n\n  if (!schema) {\n    return {\n      input: { functions: [], consts: [] },\n      isArray: false,\n    };\n  }\n\n  const resolvedJsonSchema = deference(schema, context);\n\n  // keep the same behaviour for array\n  if (resolvedJsonSchema.items) {\n    const min =\n      resolvedJsonSchema.minimum ??\n      resolvedJsonSchema.minLength ??\n      resolvedJsonSchema.minItems;\n    const max =\n      resolvedJsonSchema.maximum ??\n      resolvedJsonSchema.maxLength ??\n      resolvedJsonSchema.maxItems;\n\n    return {\n      input: generateZodValidationSchemaDefinition(\n        parseType === 'body'\n          ? removeReadOnlyProperties(resolvedJsonSchema.items as SchemaObject)\n          : (resolvedJsonSchema.items as SchemaObject),\n        context,\n        name,\n        strict,\n        isZodV4,\n        {\n          required: true,\n        },\n      ),\n      isArray: true,\n      rules: {\n        ...(min === undefined ? {} : { min }),\n        ...(max === undefined ? {} : { max }),\n      },\n    };\n  }\n\n  return {\n    input: generateZodValidationSchemaDefinition(\n      parseType === 'body'\n        ? removeReadOnlyProperties(resolvedJsonSchema)\n        : resolvedJsonSchema,\n      context,\n      name,\n      strict,\n      isZodV4,\n      {\n        required: true,\n      },\n    ),\n    isArray: false,\n  };\n};\n\nconst parseParameters = ({\n  data,\n  context,\n  operationName,\n  isZodV4,\n  strict,\n  generate,\n}: {\n  data: (ParameterObject | ReferenceObject)[] | undefined;\n  context: ContextSpecs;\n  operationName: string;\n  isZodV4: boolean;\n  strict: {\n    param: boolean;\n    query: boolean;\n    header: boolean;\n    body: boolean;\n    response: boolean;\n  };\n  generate: {\n    param: boolean;\n    query: boolean;\n    header: boolean;\n    body: boolean;\n    response: boolean;\n  };\n}): {\n  headers: ZodValidationSchemaDefinition;\n  queryParams: ZodValidationSchemaDefinition;\n  params: ZodValidationSchemaDefinition;\n} => {\n  if (!data) {\n    return {\n      headers: {\n        functions: [],\n        consts: [],\n      },\n      queryParams: {\n        functions: [],\n        consts: [],\n      },\n      params: {\n        functions: [],\n        consts: [],\n      },\n    };\n  }\n\n  const defintionsByParameters = data.reduce<\n    Record<\n      'headers' | 'queryParams' | 'params',\n      Record<string, { functions: [string, any][]; consts: string[] }>\n    >\n  >(\n    (acc, val) => {\n      const { schema: parameter } = resolveRef<ParameterObject>(val, context);\n\n      if (!parameter.schema) {\n        return acc;\n      }\n\n      const schema = deference(parameter.schema, context);\n      schema.description = parameter.description;\n\n      const mapStrict = {\n        path: strict.param,\n        query: strict.query,\n        header: strict.header,\n      };\n\n      const mapGenerate = {\n        path: generate.param,\n        query: generate.query,\n        header: generate.header,\n      };\n\n      const definition = generateZodValidationSchemaDefinition(\n        schema,\n        context,\n        camel(`${operationName}-${parameter.in}-${parameter.name}`),\n        mapStrict[parameter.in as 'path' | 'query' | 'header'] ?? false,\n        isZodV4,\n        {\n          required: parameter.required,\n        },\n      );\n\n      if (parameter.in === 'header' && mapGenerate.header) {\n        return {\n          ...acc,\n          headers: { ...acc.headers, [parameter.name]: definition },\n        };\n      }\n\n      if (parameter.in === 'query' && mapGenerate.query) {\n        return {\n          ...acc,\n          queryParams: { ...acc.queryParams, [parameter.name]: definition },\n        };\n      }\n\n      if (parameter.in === 'path' && mapGenerate.path) {\n        return {\n          ...acc,\n          params: { ...acc.params, [parameter.name]: definition },\n        };\n      }\n\n      return acc;\n    },\n    {\n      headers: {},\n      queryParams: {},\n      params: {},\n    },\n  );\n\n  const headers: ZodValidationSchemaDefinition = {\n    functions: [],\n    consts: [],\n  };\n\n  if (Object.keys(defintionsByParameters.headers).length > 0) {\n    const parameterFunctions = getParameterFunctions(\n      isZodV4,\n      strict.header,\n      defintionsByParameters.headers,\n    );\n\n    headers.functions.push(...parameterFunctions);\n  }\n\n  const queryParams: ZodValidationSchemaDefinition = {\n    functions: [],\n    consts: [],\n  };\n\n  if (Object.keys(defintionsByParameters.queryParams).length > 0) {\n    const parameterFunctions = getParameterFunctions(\n      isZodV4,\n      strict.query,\n      defintionsByParameters.queryParams,\n    );\n\n    queryParams.functions.push(...parameterFunctions);\n  }\n\n  const params: ZodValidationSchemaDefinition = {\n    functions: [],\n    consts: [],\n  };\n\n  if (Object.keys(defintionsByParameters.params).length > 0) {\n    const parameterFunctions = getParameterFunctions(\n      isZodV4,\n      strict.param,\n      defintionsByParameters.params,\n    );\n\n    params.functions.push(...parameterFunctions);\n  }\n\n  return {\n    headers,\n    queryParams,\n    params,\n  };\n};\n\nconst generateZodRoute = async (\n  { operationName, verb, override }: GeneratorVerbOptions,\n  { pathRoute, context, output }: GeneratorOptions,\n) => {\n  const isZodV4 =\n    !!context.output.packageJson && isZodVersionV4(context.output.packageJson);\n  const spec = context.specs[context.specKey].paths[pathRoute] as\n    | PathItemObject\n    | undefined;\n\n  const parameters = spec?.[verb]?.parameters!;\n  const parsedParameters = parseParameters({\n    data: parameters,\n    context,\n    operationName,\n    isZodV4,\n    strict: override.zod.strict,\n    generate: override.zod.generate,\n  });\n\n  const requestBody = spec?.[verb]?.requestBody;\n  const parsedBody = parseBodyAndResponse({\n    data: requestBody,\n    context,\n    name: camel(`${operationName}-body`),\n    strict: override.zod.strict.body,\n    generate: override.zod.generate.body,\n    isZodV4,\n    parseType: 'body',\n  });\n\n  const responses = (\n    context.output.override.zod.generateEachHttpStatus\n      ? Object.entries(spec?.[verb]?.responses ?? {})\n      : [['', spec?.[verb]?.responses[200]]]\n  ) as [string, ResponseObject | ReferenceObject][];\n  const parsedResponses = responses.map(([code, response]) =>\n    parseBodyAndResponse({\n      data: response,\n      context,\n      name: camel(`${operationName}-${code}-response`),\n      strict: override.zod.strict.response,\n      generate: override.zod.generate.response,\n      isZodV4,\n      parseType: 'response',\n    }),\n  );\n\n  const preprocessParams = override.zod.preprocess?.param\n    ? await generateMutator({\n        output,\n        mutator: override.zod.preprocess.response,\n        name: `${operationName}PreprocessParams`,\n        workspace: context.workspace,\n        tsconfig: context.output.tsconfig,\n      })\n    : undefined;\n\n  const inputParams = parseZodValidationSchemaDefinition(\n    parsedParameters.params,\n    context,\n    override.zod.coerce.param,\n    override.zod.strict.param,\n    isZodV4,\n    preprocessParams,\n  );\n\n  if (override.coerceTypes) {\n    console.warn(\n      'override.coerceTypes is deprecated, please use override.zod.coerce instead.',\n    );\n  }\n\n  const preprocessQueryParams = override.zod.preprocess?.query\n    ? await generateMutator({\n        output,\n        mutator: override.zod.preprocess.response,\n        name: `${operationName}PreprocessQueryParams`,\n        workspace: context.workspace,\n        tsconfig: context.output.tsconfig,\n      })\n    : undefined;\n\n  const inputQueryParams = parseZodValidationSchemaDefinition(\n    parsedParameters.queryParams,\n    context,\n    override.zod.coerce.query ?? override.coerceTypes,\n    override.zod.strict.query,\n    isZodV4,\n    preprocessQueryParams,\n  );\n\n  const preprocessHeader = override.zod.preprocess?.header\n    ? await generateMutator({\n        output,\n        mutator: override.zod.preprocess.response,\n        name: `${operationName}PreprocessHeader`,\n        workspace: context.workspace,\n        tsconfig: context.output.tsconfig,\n      })\n    : undefined;\n\n  const inputHeaders = parseZodValidationSchemaDefinition(\n    parsedParameters.headers,\n    context,\n    override.zod.coerce.header,\n    override.zod.strict.header,\n    isZodV4,\n    preprocessHeader,\n  );\n\n  const preprocessBody = override.zod.preprocess?.body\n    ? await generateMutator({\n        output,\n        mutator: override.zod.preprocess.response,\n        name: `${operationName}PreprocessBody`,\n        workspace: context.workspace,\n        tsconfig: context.output.tsconfig,\n      })\n    : undefined;\n\n  const inputBody = parseZodValidationSchemaDefinition(\n    parsedBody.input,\n    context,\n    override.zod.coerce.body,\n    override.zod.strict.body,\n    isZodV4,\n    preprocessBody,\n  );\n\n  const preprocessResponse = override.zod.preprocess?.response\n    ? await generateMutator({\n        output,\n        mutator: override.zod.preprocess.response,\n        name: `${operationName}PreprocessResponse`,\n        workspace: context.workspace,\n        tsconfig: context.output.tsconfig,\n      })\n    : undefined;\n\n  const inputResponses = parsedResponses.map((parsedResponse) =>\n    parseZodValidationSchemaDefinition(\n      parsedResponse.input,\n      context,\n      override.zod.coerce.response,\n      override.zod.strict.response,\n      isZodV4,\n      preprocessResponse,\n    ),\n  );\n\n  if (\n    !inputParams.zod &&\n    !inputQueryParams.zod &&\n    !inputHeaders.zod &&\n    !inputBody.zod &&\n    !inputResponses.some((inputResponse) => inputResponse.zod)\n  ) {\n    return {\n      implemtation: '',\n      mutators: [],\n    };\n  }\n\n  return {\n    implementation: [\n      ...(inputParams.consts ? [inputParams.consts] : []),\n      ...(inputParams.zod\n        ? [`export const ${operationName}Params = ${inputParams.zod}`]\n        : []),\n      ...(inputQueryParams.consts ? [inputQueryParams.consts] : []),\n      ...(inputQueryParams.zod\n        ? [`export const ${operationName}QueryParams = ${inputQueryParams.zod}`]\n        : []),\n      ...(inputHeaders.consts ? [inputHeaders.consts] : []),\n      ...(inputHeaders.zod\n        ? [`export const ${operationName}Header = ${inputHeaders.zod}`]\n        : []),\n      ...(inputBody.consts ? [inputBody.consts] : []),\n      ...(inputBody.zod\n        ? [\n            parsedBody.isArray\n              ? `export const ${operationName}BodyItem = ${inputBody.zod}\nexport const ${operationName}Body = zod.array(${operationName}BodyItem)${\n                  parsedBody.rules?.min ? `.min(${parsedBody.rules?.min})` : ''\n                }${\n                  parsedBody.rules?.max ? `.max(${parsedBody.rules?.max})` : ''\n                }`\n              : `export const ${operationName}Body = ${inputBody.zod}`,\n          ]\n        : []),\n      ...inputResponses.flatMap((inputResponse, index) => {\n        const operationResponse = camel(\n          `${operationName}-${responses[index][0]}-response`,\n        );\n        return [\n          ...(inputResponse.consts ? [inputResponse.consts] : []),\n          ...(inputResponse.zod\n            ? [\n                parsedResponses[index].isArray\n                  ? `export const ${operationResponse}Item = ${\n                      inputResponse.zod\n                    }\nexport const ${operationResponse} = zod.array(${operationResponse}Item)${\n                      parsedResponses[index].rules?.min\n                        ? `.min(${parsedResponses[index].rules?.min})`\n                        : ''\n                    }${\n                      parsedResponses[index].rules?.max\n                        ? `.max(${parsedResponses[index].rules?.max})`\n                        : ''\n                    }`\n                  : `export const ${operationResponse} = ${inputResponse.zod}`,\n              ]\n            : []),\n        ];\n      }),\n    ].join('\\n\\n'),\n    mutators: preprocessResponse ? [preprocessResponse] : [],\n  };\n};\n\nexport const generateZod: ClientBuilder = async (verbOptions, options) => {\n  const { implementation, mutators } = await generateZodRoute(\n    verbOptions,\n    options,\n  );\n\n  return {\n    implementation: implementation ? `${implementation}\\n\\n` : '',\n    imports: [],\n    mutators,\n  };\n};\n\nconst zodClientBuilder: ClientGeneratorsBuilder = {\n  client: generateZod,\n  dependencies: getZodDependencies,\n};\n\nexport const builder = () => () => zodClientBuilder;\n\nexport default builder;\n"],"mappings":"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"}