{"version":3,"file":"index.js","names":["getMcpHeader: ClientHeaderBuilder","upath","generateMcp: ClientBuilder","generateExtraFiles: ClientExtraFilesBuilder","mcpClientBuilder: ClientGeneratorsBuilder"],"sources":["../src/index.ts"],"sourcesContent":["import {\n  camel,\n  ClientBuilder,\n  ClientExtraFilesBuilder,\n  ClientGeneratorsBuilder,\n  ClientHeaderBuilder,\n  ContextSpecs,\n  generateMutatorImports,\n  generateVerbImports,\n  GeneratorMutator,\n  GeneratorVerbOptions,\n  getFileInfo,\n  getFullRoute,\n  jsDoc,\n  NormalizedOutputOptions,\n  pascal,\n  upath,\n} from '@orval/core';\nimport {\n  generateClient,\n  generateFetchHeader,\n  generateRequestFunction as generateFetchRequestFunction,\n} from '@orval/fetch';\nimport { generateZod } from '@orval/zod';\nimport { InfoObject } from 'openapi3-ts/oas30';\n\nconst getHeader = (\n  option: false | ((info: InfoObject) => string | string[]),\n  info: InfoObject,\n): string => {\n  if (!option) {\n    return '';\n  }\n\n  const header = option(info);\n\n  return Array.isArray(header) ? jsDoc({ description: header }) : header;\n};\n\nexport const getMcpHeader: ClientHeaderBuilder = ({\n  verbOptions,\n  output,\n  clientImplementation,\n}) => {\n  const targetInfo = getFileInfo(output.target);\n  const schemaInfo = getFileInfo(output.schemas);\n\n  const relativeSchemaImportPath = output.schemas\n    ? upath.relativeSafe(targetInfo.dirname, schemaInfo.dirname)\n    : './' + targetInfo.filename + '.schemas';\n\n  const importSchemaNames = Object.values(verbOptions)\n    .flatMap((verbOption) => {\n      const imports = [];\n      const pascalOperationName = pascal(verbOption.operationName);\n\n      if (verbOption.queryParams) {\n        imports.push(`${pascalOperationName}Params`);\n      }\n\n      if (verbOption.body.definition) {\n        imports.push(`${pascalOperationName}Body`);\n      }\n\n      return imports;\n    })\n    .reduce<string[]>((acc, name) => {\n      if (!acc.find((i) => i === name)) {\n        acc.push(name);\n      }\n      return acc;\n    }, []);\n\n  const importSchemasImplementation = `import {\\n  ${importSchemaNames.join(\n    ',\\n  ',\n  )}\\n} from '${relativeSchemaImportPath}';\n`;\n\n  const relativeFetchClientPath = './http-client';\n  const importFetchClientNames = Object.values(verbOptions)\n    .flatMap((verbOption) => verbOption.operationName)\n    .reduce<string[]>((acc, name) => {\n      if (!acc.find((i) => i === name)) {\n        acc.push(name);\n      }\n\n      return acc;\n    }, []);\n\n  const importFetchClientImplementation = `import {\\n  ${importFetchClientNames.join(\n    ',\\n  ',\n  )}\\n} from '${relativeFetchClientPath}';\n  `;\n\n  const content = [\n    importSchemasImplementation,\n    importFetchClientImplementation,\n  ].join('\\n');\n\n  return content + '\\n';\n};\n\nexport const generateMcp: ClientBuilder = async (verbOptions, options) => {\n  const handlerArgsTypes = [];\n  const pathParamsType = verbOptions.params\n    .map((param) => {\n      const paramName = param.name.split(': ')[0];\n      const paramType = param.implementation.split(': ')[1];\n      return `    ${paramName}: ${paramType}`;\n    })\n    .join(',\\n');\n  if (pathParamsType) {\n    handlerArgsTypes.push(`  pathParams: {\\n${pathParamsType}\\n  };`);\n  }\n  if (verbOptions.queryParams) {\n    handlerArgsTypes.push(\n      `  queryParams: ${verbOptions.queryParams.schema.name};`,\n    );\n  }\n  if (verbOptions.body.definition) {\n    handlerArgsTypes.push(`  bodyParams: ${verbOptions.body.definition};`);\n  }\n\n  const handlerArgsName = `${verbOptions.operationName}Args`;\n  const handlerArgsImplementation =\n    handlerArgsTypes.length > 0\n      ? `\nexport type ${handlerArgsName} = {\n${handlerArgsTypes.join('\\n')}\n}\n`\n      : '';\n\n  const fetchParams = [];\n  if (verbOptions.params.length > 0) {\n    const pathParamsArgs = verbOptions.params\n      .map((param) => {\n        const paramName = param.name.split(': ')[0];\n\n        return `args.pathParams.${paramName}`;\n      })\n      .join(', ');\n\n    fetchParams.push(pathParamsArgs);\n  }\n  if (verbOptions.body.definition) fetchParams.push(`args.bodyParams`);\n  if (verbOptions.queryParams) fetchParams.push(`args.queryParams`);\n\n  const handlerName = `${verbOptions.operationName}Handler`;\n  const handlerImplementation = `\nexport const ${handlerName} = async (${handlerArgsTypes.length > 0 ? `args: ${handlerArgsName}` : ''}) => {\n  const res = await ${verbOptions.operationName}(${fetchParams.join(', ')});\n\n  return {\n    content: [\n      {\n        type: 'text' as const,\n        text: JSON.stringify(res),\n      },\n    ],\n  };\n};`;\n\n  const handlersImplementation = [\n    handlerArgsImplementation,\n    handlerImplementation,\n  ].join('');\n\n  return {\n    implementation: handlersImplementation ? `${handlersImplementation}\\n` : '',\n    imports: [],\n  };\n};\n\nexport const generateServer = async (\n  verbOptions: Record<string, GeneratorVerbOptions>,\n  output: NormalizedOutputOptions,\n  context: ContextSpecs,\n) => {\n  const info = context.specs[context.specKey].info;\n  const { extension, dirname } = getFileInfo(output.target);\n  const serverPath = upath.join(dirname, `server${extension}`);\n  const header = getHeader(output.override.header, info);\n\n  const toolImplementations = Object.values(verbOptions)\n    .map((verbOption) => {\n      const imputSchemaTypes = [];\n      if (verbOption.params.length > 0)\n        imputSchemaTypes.push(\n          `  pathParams: ${verbOption.operationName}Params`,\n        );\n      if (verbOption.queryParams)\n        imputSchemaTypes.push(\n          `  queryParams: ${verbOption.operationName}QueryParams`,\n        );\n      if (verbOption.body.definition)\n        imputSchemaTypes.push(`  bodyParams: ${verbOption.operationName}Body`);\n\n      const imputSchemaImplementation =\n        imputSchemaTypes.length > 0\n          ? `  {\n  ${imputSchemaTypes.join(',\\n  ')}\n  },`\n          : '';\n\n      const toolImplementation = `\nserver.tool(\n  '${verbOption.operationName}',\n  '${verbOption.summary}',${imputSchemaImplementation ? `\\n${imputSchemaImplementation}` : ''}\n  ${verbOption.operationName}Handler\n);`;\n\n      return toolImplementation;\n    })\n    .join('\\n');\n\n  const importToolSchemas = Object.values(verbOptions)\n    .flatMap((verbOption) => {\n      const imports = [];\n\n      if (verbOption.headers)\n        imports.push(`  ${verbOption.operationName}Header`);\n      if (verbOption.params.length > 0)\n        imports.push(`  ${verbOption.operationName}Params`);\n      if (verbOption.queryParams)\n        imports.push(`  ${verbOption.operationName}QueryParams`);\n      if (verbOption.body.definition)\n        imports.push(`  ${verbOption.operationName}Body`);\n\n      return imports;\n    })\n    .join(',\\n');\n  const importToolSchemasImplementation = `import {\\n${importToolSchemas}\\n} from './tool-schemas.zod';`;\n\n  const importHandlers = Object.values(verbOptions)\n    .filter((verbOption) =>\n      toolImplementations.includes(`${verbOption.operationName}Handler`),\n    )\n    .map((verbOption) => `  ${verbOption.operationName}Handler`)\n    .join(`,\\n`);\n  const importHandlersImplementation = `import {\\n${importHandlers}\\n} from './handlers';`;\n\n  const importDependenciesImplementation = `import {\n  McpServer\n} from '@modelcontextprotocol/sdk/server/mcp.js';\n  \nimport {\n  StdioServerTransport\n} from '@modelcontextprotocol/sdk/server/stdio.js';  \n`;\n  const newMcpServerImplementation = `\nconst server = new McpServer({\n  name: '${camel(info.title)}Server',\n  version: '1.0.0',\n});\n`;\n  const serverConnectImplementation = `\nconst transport = new StdioServerTransport();\n\nserver.connect(transport).then(() => {\n  console.error('MCP server running on stdio');\n}).catch(console.error);\n`;\n\n  const content = [\n    header,\n    importDependenciesImplementation,\n    importHandlersImplementation,\n    importToolSchemasImplementation,\n    newMcpServerImplementation,\n    toolImplementations,\n    serverConnectImplementation,\n  ].join('\\n');\n\n  return [\n    {\n      content,\n      path: serverPath,\n    },\n  ];\n};\n\nconst generateZodFiles = async (\n  verbOptions: Record<string, GeneratorVerbOptions>,\n  output: NormalizedOutputOptions,\n  context: ContextSpecs,\n) => {\n  const { extension, dirname, filename } = getFileInfo(output.target);\n\n  const header = getHeader(\n    output.override.header,\n    context.specs[context.specKey].info,\n  );\n\n  const zods = await Promise.all(\n    Object.values(verbOptions).map((verbOption) =>\n      generateZod(\n        verbOption,\n        {\n          route: verbOption.route,\n          pathRoute: verbOption.pathRoute,\n          override: output.override,\n          context,\n          mock: output.mock,\n          output: output.target!,\n        },\n        output.client,\n      ),\n    ),\n  );\n\n  const allMutators = zods.reduce(\n    (acc, z) => {\n      for (const mutator of z.mutators ?? []) {\n        acc[mutator.name] = mutator;\n      }\n      return acc;\n    },\n    {} as Record<string, GeneratorMutator>,\n  );\n\n  const mutatorsImports = generateMutatorImports({\n    mutators: Object.values(allMutators),\n  });\n\n  let content = `${header}import { z as zod } from 'zod';\\n${mutatorsImports}\\n`;\n\n  const zodPath = upath.join(dirname, `tool-schemas.zod${extension}`);\n\n  content += zods.map((zod) => zod.implementation).join('\\n');\n\n  return [\n    {\n      content,\n      path: zodPath,\n    },\n  ];\n};\n\nconst generateHttpClinetFiles = async (\n  verbOptions: Record<string, GeneratorVerbOptions>,\n  output: NormalizedOutputOptions,\n  context: ContextSpecs,\n) => {\n  const { extension, dirname, filename } = getFileInfo(output.target);\n\n  const header = getHeader(\n    output.override.header,\n    context.specs[context.specKey].info,\n  );\n\n  const clients = await Promise.all(\n    Object.values(verbOptions).map((verbOption) => {\n      const fullRoute = getFullRoute(\n        verbOption.route,\n        context.specs[context.specKey].servers,\n        output.baseUrl,\n      );\n\n      const options = {\n        route: fullRoute,\n        pathRoute: verbOption.pathRoute,\n        override: output.override,\n        context,\n        mock: output.mock,\n        output: output.target!,\n      };\n\n      return generateClient(verbOption, options, output.client, output);\n    }),\n  );\n\n  const clientImplementation = clients\n    .map((client) => client.implementation)\n    .join('\\n');\n\n  const relativeSchemasPath = output.schemas\n    ? upath.relativeSafe(dirname, getFileInfo(output.schemas).dirname)\n    : './' + filename + '.schemas';\n  const importNames = clients\n    .flatMap((client) => client.imports)\n    .reduce((acc, imp) => {\n      if (!acc.find((i) => i === imp.name)) {\n        acc.push(imp.name);\n      }\n\n      return acc;\n    }, [] as string[]);\n  const importImplementation = `import { ${importNames.join(\n    ',\\n',\n  )} } from '${relativeSchemasPath}';`;\n\n  const fetchHeader = generateFetchHeader({\n    title: '',\n    isRequestOptions: false,\n    isMutator: false,\n    noFunction: false,\n    isGlobalMutator: false,\n    provideIn: false,\n    hasAwaitedType: false,\n    output,\n    verbOptions,\n    clientImplementation,\n  });\n\n  const content = [\n    header,\n    importImplementation,\n    fetchHeader,\n    clientImplementation,\n  ].join('\\n');\n  const outputPath = upath.join(dirname, `http-client${extension}`);\n\n  return [\n    {\n      content,\n      path: outputPath,\n    },\n  ];\n};\n\nexport const generateExtraFiles: ClientExtraFilesBuilder = async (\n  verbOptions,\n  output,\n  context,\n) => {\n  const [server, zods, httpClients] = await Promise.all([\n    generateServer(verbOptions, output, context),\n    generateZodFiles(verbOptions, output, context),\n    generateHttpClinetFiles(verbOptions, output, context),\n  ]);\n\n  return [...server, ...zods, ...httpClients];\n};\n\nconst mcpClientBuilder: ClientGeneratorsBuilder = {\n  client: generateMcp,\n  header: getMcpHeader,\n  extraFiles: generateExtraFiles,\n};\n\nexport const builder = () => () => mcpClientBuilder;\n\nexport default builder;\n"],"mappings":"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"}