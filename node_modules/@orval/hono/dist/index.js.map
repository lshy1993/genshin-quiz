{"version":3,"file":"index.js","names":["HONO_DEPENDENCIES: GeneratorDependency[]","getHonoHeader: ClientHeaderBuilder","tag","upath","getHonoFooter: ClientFooterBuilder","generateHono: ClientBuilder","handlerPath","hasZValidator","fs","content","validatorImport","zodImports","outputRelativePath","relativeSchemasPath","contexts","imps","imports: GeneratorImport[]","contextPath","zods","allMutators","mutatorsImports","zodPath","context","generateExtraFiles: ClientExtraFilesBuilder","honoClientBuilder: ClientGeneratorsBuilder"],"sources":["../src/route.ts","../src/index.ts"],"sourcesContent":["import { sanitize } from '@orval/core';\n\nconst hasParam = (path: string): boolean => /[^{]*{[\\w*_-]*}.*/.test(path);\n\nconst getRoutePath = (path: string): string => {\n  const matches = /([^{]*){?([\\w*_-]*)}?(.*)/.exec(path);\n  if (!matches?.length) return path; // impossible due to regexp grouping here, but for TS\n\n  const prev = matches[1];\n  const param = sanitize(matches[2], {\n    es5keyword: true,\n    underscore: true,\n    dash: true,\n    dot: true,\n  });\n  const next = hasParam(matches[3]) ? getRoutePath(matches[3]) : matches[3];\n\n  return hasParam(path) ? `${prev}\\:${param}${next}` : `${prev}${param}${next}`;\n};\n\nexport const getRoute = (route: string) => {\n  const splittedRoute = route.split('/');\n\n  return splittedRoute.reduce((acc, path, i) => {\n    if (!path && !i) {\n      return acc;\n    }\n\n    if (!path.includes('{')) {\n      return `${acc}/${path}`;\n    }\n\n    return `${acc}/${getRoutePath(path)}`;\n  }, '');\n};\n","import {\n  camel,\n  ClientBuilder,\n  ClientExtraFilesBuilder,\n  ClientFooterBuilder,\n  ClientGeneratorsBuilder,\n  ClientHeaderBuilder,\n  ContextSpecs,\n  generateMutatorImports,\n  GeneratorDependency,\n  GeneratorImport,\n  GeneratorMutator,\n  GeneratorVerbOptions,\n  getFileInfo,\n  getOrvalGeneratedTypes,\n  getParamsInPath,\n  jsDoc,\n  kebab,\n  NormalizedMutator,\n  NormalizedOutputOptions,\n  pascal,\n  sanitize,\n  upath,\n} from '@orval/core';\nimport { generateZod } from '@orval/zod';\nimport fs from 'fs-extra';\nimport { InfoObject } from 'openapi3-ts/oas30';\n\nimport { getRoute } from './route';\n\nconst HONO_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      {\n        name: 'Hono',\n        values: true,\n      },\n      {\n        name: 'Context',\n      },\n      {\n        name: 'Env',\n      },\n    ],\n    dependency: 'hono',\n  },\n];\n\nexport const getHonoDependencies = () => HONO_DEPENDENCIES;\n\nexport const getHonoHeader: ClientHeaderBuilder = ({\n  verbOptions,\n  output,\n  tag,\n  clientImplementation,\n}) => {\n  const targetInfo = getFileInfo(output.target);\n\n  let handlers = '';\n\n  const importHandlers = Object.values(verbOptions).filter((verbOption) =>\n    clientImplementation.includes(`${verbOption.operationName}Handlers`),\n  );\n\n  if (output.override.hono.handlers) {\n    const handlerFileInfo = getFileInfo(output.override.hono.handlers);\n    handlers = importHandlers\n      .map((verbOption) => {\n        const isTagMode =\n          output.mode === 'tags' || output.mode === 'tags-split';\n        const tag = kebab(verbOption.tags[0] ?? 'default');\n\n        const handlersPath = upath.relativeSafe(\n          upath.join(targetInfo.dirname ?? '', isTagMode ? tag : ''),\n          upath.join(\n            handlerFileInfo.dirname ?? '',\n            `./${verbOption.operationName}`,\n          ),\n        );\n\n        return `import { ${verbOption.operationName}Handlers } from '${handlersPath}';`;\n      })\n      .join('\\n');\n  } else {\n    const importHandlerNames = importHandlers\n      .map((verbOption) => ` ${verbOption.operationName}Handlers`)\n      .join(`, \\n`);\n\n    handlers = `import {\\n${importHandlerNames}\\n} from './${tag ?? targetInfo.filename}.handlers';`;\n  }\n\n  return `${handlers}\\n\\n\nconst app = new Hono()\\n\\n`;\n};\n\nexport const getHonoFooter: ClientFooterBuilder = () => 'export default app';\n\nconst generateHonoRoute = (\n  { operationName, verb }: GeneratorVerbOptions,\n  pathRoute: string,\n) => {\n  const path = getRoute(pathRoute);\n\n  return `\napp.${verb.toLowerCase()}('${path}',...${operationName}Handlers)`;\n};\n\nexport const generateHono: ClientBuilder = async (verbOptions, options) => {\n  if (options.override.hono.compositeRoute) {\n    return {\n      implementation: '',\n      imports: [],\n    };\n  }\n\n  const routeImplementation = generateHonoRoute(verbOptions, options.pathRoute);\n\n  return {\n    implementation: routeImplementation ? `${routeImplementation}\\n\\n` : '',\n    imports: [\n      ...verbOptions.params.flatMap((param) => param.imports),\n      ...verbOptions.body.imports,\n      ...(verbOptions.queryParams\n        ? [\n            {\n              name: verbOptions.queryParams.schema.name,\n            },\n          ]\n        : []),\n    ],\n  };\n};\n\nconst getHonoHandlers = ({\n  handlerName,\n  contextTypeName,\n  verbOption,\n  validator,\n}: {\n  handlerName: string;\n  contextTypeName: string;\n  verbOption: GeneratorVerbOptions;\n  validator: boolean | 'hono' | NormalizedMutator;\n}) => {\n  let currentValidator = '';\n\n  if (validator) {\n    if (verbOption.headers) {\n      currentValidator += `zValidator('header', ${verbOption.operationName}Header),\\n`;\n    }\n    if (verbOption.params.length > 0) {\n      currentValidator += `zValidator('param', ${verbOption.operationName}Params),\\n`;\n    }\n    if (verbOption.queryParams) {\n      currentValidator += `zValidator('query', ${verbOption.operationName}QueryParams),\\n`;\n    }\n    if (verbOption.body.definition) {\n      currentValidator += `zValidator('json', ${verbOption.operationName}Body),\\n`;\n    }\n    if (\n      validator !== 'hono' &&\n      verbOption.response.originalSchema?.['200']?.content?.['application/json']\n    ) {\n      currentValidator += `zValidator('response', ${verbOption.operationName}Response),\\n`;\n    }\n  }\n\n  return `\nexport const ${handlerName} = factory.createHandlers(\n${currentValidator}async (c: ${contextTypeName}) => {\n\n  },\n);`;\n};\n\nconst getValidatorOutputRelativePath = (\n  validatorOutputPath: string,\n  handlerPath: string,\n) => {\n  const { pathWithoutExtension } = getFileInfo(validatorOutputPath);\n\n  return upath.relativeSafe(upath.dirname(handlerPath), pathWithoutExtension);\n};\n\nconst getZvalidatorImports = (\n  verbOptions: GeneratorVerbOptions[],\n  importPath: string,\n  isHonoValidator: boolean,\n) => {\n  const importImplementation = verbOptions\n    .flatMap((verbOption) => {\n      const imports = [];\n\n      if (verbOption.headers) {\n        imports.push(`${verbOption.operationName}Header`);\n      }\n\n      if (verbOption.params.length > 0) {\n        imports.push(`${verbOption.operationName}Params`);\n      }\n\n      if (verbOption.queryParams) {\n        imports.push(`${verbOption.operationName}QueryParams`);\n      }\n\n      if (verbOption.body.definition) {\n        imports.push(`${verbOption.operationName}Body`);\n      }\n\n      if (\n        !isHonoValidator &&\n        !!verbOption.response.originalSchema?.['200']?.content?.[\n          'application/json'\n        ]\n      ) {\n        imports.push(`${verbOption.operationName}Response`);\n      }\n\n      return imports.join(',\\n');\n    })\n    .join(',\\n');\n\n  return importImplementation\n    ? `import {\\n${importImplementation}\\n} from '${importPath}'`\n    : '';\n};\n\nconst getVerbOptionGroupByTag = (\n  verbOptions: Record<string, GeneratorVerbOptions>,\n) => {\n  return Object.values(verbOptions).reduce<\n    Record<string, GeneratorVerbOptions[]>\n  >((acc, value) => {\n    const tag = value.tags[0];\n    if (!acc[tag]) {\n      acc[tag] = [];\n    }\n    acc[tag].push(value);\n    return acc;\n  }, {});\n};\n\nconst generateHandlers = async (\n  verbOptions: Record<string, GeneratorVerbOptions>,\n  output: NormalizedOutputOptions,\n) => {\n  const { pathWithoutExtension, extension, dirname, filename } = getFileInfo(\n    output.target,\n  );\n\n  if (output.override.hono.handlers) {\n    return Promise.all(\n      Object.values(verbOptions).map(async (verbOption) => {\n        const isTagMode =\n          output.mode === 'tags' || output.mode === 'tags-split';\n        const tag = kebab(verbOption.tags[0] ?? 'default');\n        const outputPath = upath.relativeSafe(\n          output.override.hono.handlers ?? '',\n          isTagMode ? `${dirname}/${tag}/${tag}` : pathWithoutExtension,\n        );\n\n        const handlerPath = upath.join(\n          output.override.hono.handlers ?? '',\n          `./${verbOption.operationName}` + extension,\n        );\n\n        const hasZValidator =\n          !!verbOption.headers ||\n          verbOption.params.length > 0 ||\n          !!verbOption.queryParams ||\n          !!verbOption.body.definition;\n\n        const isExist = fs.existsSync(handlerPath);\n\n        const handlerName = `${verbOption.operationName}Handlers`;\n        const contextTypeName = `${pascal(verbOption.operationName)}Context`;\n\n        if (isExist) {\n          const rawFile = await fs.readFile(handlerPath, 'utf8');\n          let content = rawFile;\n\n          if (!rawFile.includes(handlerName)) {\n            content += getHonoHandlers({\n              handlerName,\n              contextTypeName,\n              verbOption,\n              validator: output.override.hono.validator,\n            });\n          }\n\n          return {\n            content,\n            path: handlerPath,\n          };\n        }\n\n        let validatorImport = '';\n\n        if (hasZValidator) {\n          if (output.override.hono.validator === true) {\n            const validatorPath = output.override.hono.validatorOutputPath\n              ? getValidatorOutputRelativePath(\n                  output.override.hono.validatorOutputPath,\n                  handlerPath,\n                )\n              : `${outputPath}.validator`;\n\n            validatorImport = `\\nimport { zValidator } from '${validatorPath}';`;\n          } else if (output.override.hono.validator === 'hono') {\n            validatorImport = `\\nimport { zValidator } from '@hono/zod-validator';`;\n          }\n        }\n\n        const zodImports = output.override.hono.validator\n          ? getZvalidatorImports(\n              [verbOption],\n              `${outputPath}.zod`,\n              output.override.hono.validator === 'hono',\n            )\n          : '';\n\n        const content = `import { createFactory } from 'hono/factory';${validatorImport}\nimport { ${contextTypeName} } from '${outputPath}.context';\n${zodImports}\n\nconst factory = createFactory();\n\n${getHonoHandlers({\n  handlerName,\n  contextTypeName,\n  verbOption,\n  validator: output.override.hono.validator,\n})}\n`;\n\n        return {\n          content,\n          path: handlerPath,\n        };\n      }),\n    );\n  }\n\n  if (output.mode === 'tags' || output.mode === 'tags-split') {\n    const groupByTags = getVerbOptionGroupByTag(verbOptions);\n\n    return Promise.all(\n      Object.entries(groupByTags).map(async ([tag, verbs]) => {\n        const handlerPath =\n          output.mode === 'tags'\n            ? upath.join(dirname, `${kebab(tag)}.handlers${extension}`)\n            : upath.join(dirname, tag, tag + '.handlers' + extension);\n\n        const hasZValidator = verbs.some(\n          (verb) =>\n            !!verb.headers ||\n            verb.params.length > 0 ||\n            !!verb.queryParams ||\n            !!verb.body.definition,\n        );\n\n        const isExist = fs.existsSync(handlerPath);\n\n        if (isExist) {\n          const rawFile = await fs.readFile(handlerPath, 'utf8');\n          let content = rawFile;\n\n          content += Object.values(verbs).reduce((acc, verbOption) => {\n            const handlerName = `${verbOption.operationName}Handlers`;\n            const contextTypeName = `${pascal(\n              verbOption.operationName,\n            )}Context`;\n\n            if (!rawFile.includes(handlerName)) {\n              acc += getHonoHandlers({\n                handlerName,\n                contextTypeName,\n                verbOption,\n                validator: output.override.hono.validator,\n              });\n            }\n\n            return acc;\n          }, '');\n\n          return {\n            content,\n            path: handlerPath,\n          };\n        }\n\n        let validatorImport = '';\n        if (hasZValidator) {\n          if (output.override.hono.validator === true) {\n            const validatorOutputPath =\n              output.override.hono.validatorOutputPath ||\n              `${dirname}/${filename}.validator${extension}`;\n            const validatorPath = getValidatorOutputRelativePath(\n              validatorOutputPath,\n              handlerPath,\n            );\n\n            validatorImport = `\\nimport { zValidator } from '${validatorPath}';`;\n          } else if (output.override.hono.validator === 'hono') {\n            validatorImport = `\\nimport { zValidator } from '@hono/zod-validator';`;\n          }\n        }\n\n        const outputRelativePath = `./${kebab(tag)}`;\n\n        const zodImports = output.override.hono.validator\n          ? getZvalidatorImports(\n              Object.values(verbs),\n              `${outputRelativePath}.zod`,\n              output.override.hono.validator === 'hono',\n            )\n          : '';\n\n        let content = `import { createFactory } from 'hono/factory';${validatorImport}\nimport { ${Object.values(verbs)\n          .map((verb) => `${pascal(verb.operationName)}Context`)\n          .join(',\\n')} } from '${outputRelativePath}.context';\n${zodImports}\n\nconst factory = createFactory();`;\n\n        content += Object.values(verbs).reduce((acc, verbOption) => {\n          const handlerName = `${verbOption.operationName}Handlers`;\n          const contextTypeName = `${pascal(verbOption.operationName)}Context`;\n\n          acc += getHonoHandlers({\n            handlerName,\n            contextTypeName,\n            verbOption,\n            validator: output.override.hono.validator,\n          });\n\n          return acc;\n        }, '');\n\n        return {\n          content,\n          path: handlerPath,\n        };\n      }),\n    );\n  }\n\n  const hasZValidator = Object.values(verbOptions).some(\n    (verb) =>\n      !!verb.headers ||\n      verb.params.length > 0 ||\n      !!verb.queryParams ||\n      !!verb.body.definition ||\n      (verb.response.contentTypes.length === 1 &&\n        verb.response.contentTypes[0] === 'application/json'),\n  );\n\n  const handlerPath = upath.join(dirname, `${filename}.handlers${extension}`);\n\n  const isExist = fs.existsSync(handlerPath);\n\n  if (isExist) {\n    const rawFile = await fs.readFile(handlerPath, 'utf8');\n    let content = rawFile;\n\n    content += Object.values(verbOptions).reduce((acc, verbOption) => {\n      const handlerName = `${verbOption.operationName}Handlers`;\n      const contextTypeName = `${pascal(verbOption.operationName)}Context`;\n\n      if (!rawFile.includes(handlerName)) {\n        acc += getHonoHandlers({\n          handlerName,\n          contextTypeName,\n          verbOption,\n          validator: output.override.hono.validator,\n        });\n      }\n\n      return acc;\n    }, '');\n\n    return [\n      {\n        content,\n        path: handlerPath,\n      },\n    ];\n  }\n\n  const outputRelativePath = `./${filename}`;\n\n  let validatorImport = '';\n\n  if (hasZValidator) {\n    if (output.override.hono.validator === true) {\n      const validatorPath = output.override.hono.validatorOutputPath\n        ? getValidatorOutputRelativePath(\n            output.override.hono.validatorOutputPath,\n            handlerPath,\n          )\n        : `${outputRelativePath}.validator`;\n\n      validatorImport = `\\nimport { zValidator } from '${validatorPath}';`;\n    } else if (output.override.hono.validator === 'hono') {\n      validatorImport = `\\nimport { zValidator } from '@hono/zod-validator';`;\n    }\n  }\n\n  const zodImports = output.override.hono.validator\n    ? getZvalidatorImports(\n        Object.values(verbOptions),\n        `${outputRelativePath}.zod`,\n        output.override.hono.validator === 'hono',\n      )\n    : '';\n\n  let content = `import { createFactory } from 'hono/factory';${validatorImport}\nimport { ${Object.values(verbOptions)\n    .map((verb) => `${pascal(verb.operationName)}Context`)\n    .join(',\\n')} } from '${outputRelativePath}.context';\n${zodImports}\n\nconst factory = createFactory();`;\n\n  content += Object.values(verbOptions).reduce((acc, verbOption) => {\n    const handlerName = `${verbOption.operationName}Handlers`;\n    const contextTypeName = `${pascal(verbOption.operationName)}Context`;\n\n    acc += getHonoHandlers({\n      handlerName,\n      contextTypeName,\n      verbOption,\n      validator: output.override.hono.validator,\n    });\n\n    return acc;\n  }, '');\n\n  return [\n    {\n      content,\n      path: handlerPath,\n    },\n  ];\n};\n\nconst getContext = (verbOption: GeneratorVerbOptions) => {\n  let paramType = '';\n  if (verbOption.params.length > 0) {\n    const params = getParamsInPath(verbOption.pathRoute).map((name) => {\n      const param = verbOption.params.find(\n        (p) => p.name === sanitize(camel(name), { es5keyword: true }),\n      );\n      const definition = param?.definition.split(':')[1];\n      const required = param?.required ?? false;\n      return {\n        definition: `${name}${required ? '' : '?'}:${definition}`,\n      };\n    });\n    paramType = `param: {\\n ${params\n      .map((property) => property.definition)\n      .join(',\\n    ')},\\n },`;\n  }\n\n  const queryType = verbOption.queryParams\n    ? `query: ${verbOption.queryParams?.schema.name},`\n    : '';\n  const bodyType = verbOption.body.definition\n    ? `json: ${verbOption.body.definition},`\n    : '';\n  const hasIn = !!paramType || !!queryType || !!bodyType;\n\n  return `export type ${pascal(\n    verbOption.operationName,\n  )}Context<E extends Env = any> = Context<E, '${getRoute(\n    verbOption.pathRoute,\n  )}'${\n    hasIn\n      ? `, { in: { ${paramType}${queryType}${bodyType} }, out: { ${paramType}${queryType}${bodyType} } }`\n      : ''\n  }>`;\n};\n\nconst getHeader = (\n  option: false | ((info: InfoObject) => string | string[]),\n  info: InfoObject,\n): string => {\n  if (!option) {\n    return '';\n  }\n\n  const header = option(info);\n\n  return Array.isArray(header) ? jsDoc({ description: header }) : header;\n};\n\nconst generateContext = async (\n  verbOptions: Record<string, GeneratorVerbOptions>,\n  output: NormalizedOutputOptions,\n  context: ContextSpecs,\n) => {\n  const header = getHeader(\n    output.override.header,\n    context.specs[context.specKey].info,\n  );\n  const { extension, dirname, filename } = getFileInfo(output.target);\n\n  if (output.mode === 'tags' || output.mode === 'tags-split') {\n    const groupByTags = getVerbOptionGroupByTag(verbOptions);\n\n    let relativeSchemasPath = output.mode === 'tags-split' ? '../' : '';\n\n    relativeSchemasPath += output.schemas\n      ? upath.relativeSafe(dirname, getFileInfo(output.schemas).dirname)\n      : `${filename}.schemas`;\n\n    return Promise.all(\n      Object.entries(groupByTags).map(async ([tag, verbs]) => {\n        let content = `${header}import type { Context, Env } from 'hono';\\n\\n`;\n\n        const contexts = verbs.map((verb) => getContext(verb)).join('\\n');\n\n        const imps = verbs\n          .flatMap((verb) => {\n            const imports: GeneratorImport[] = [];\n            if (verb.params.length > 0) {\n              imports.push(...verb.params.flatMap((param) => param.imports));\n            }\n\n            if (verb.queryParams) {\n              imports.push({\n                name: verb.queryParams.schema.name,\n              });\n            }\n\n            if (verb.body.definition) {\n              imports.push(...verb.body.imports);\n            }\n\n            return imports;\n          })\n          .filter((imp) => contexts.includes(imp.name))\n          .filter(\n            (imp, i, arr) => arr.findIndex((v) => v.name === imp.name) === i,\n          );\n\n        if (contexts.includes('NonReadonly<')) {\n          content += getOrvalGeneratedTypes();\n          content += '\\n';\n        }\n\n        if (imps.length > 0) {\n          const importSchemas = imps.map((imp) => imp.name).join(',\\n  ');\n\n          content += `import {\\n  ${importSchemas}\\n} from '${relativeSchemasPath}';\\n\\n`;\n        }\n\n        content += contexts;\n\n        const contextPath =\n          output.mode === 'tags'\n            ? upath.join(dirname, `${kebab(tag)}.context${extension}`)\n            : upath.join(dirname, tag, tag + '.context' + extension);\n\n        return {\n          content,\n          path: contextPath,\n        };\n      }),\n    );\n  }\n\n  let content = `${header}import type { Context, Env } from 'hono';\\n\\n`;\n\n  const contextPath = upath.join(dirname, `${filename}.context${extension}`);\n\n  const contexts = Object.values(verbOptions)\n    .map((verbOption) => getContext(verbOption))\n    .join('\\n');\n\n  const imps = Object.values(verbOptions)\n    .flatMap((verb) => {\n      const imports: GeneratorImport[] = [];\n      if (verb.params.length > 0) {\n        imports.push(...verb.params.flatMap((param) => param.imports));\n      }\n\n      if (verb.queryParams) {\n        imports.push({\n          name: verb.queryParams.schema.name,\n        });\n      }\n\n      if (verb.body.definition) {\n        imports.push(...verb.body.imports);\n      }\n\n      return imports;\n    })\n    .filter((imp) => contexts.includes(imp.name))\n    .filter((imp, i, arr) => arr.findIndex((v) => v.name === imp.name) === i);\n\n  if (contexts.includes('NonReadonly<')) {\n    content += getOrvalGeneratedTypes();\n    content += '\\n';\n  }\n\n  const relativeSchemasPath = output.schemas\n    ? upath.relativeSafe(dirname, getFileInfo(output.schemas).dirname)\n    : './' + filename + '.schemas';\n\n  content += `import { ${imps\n    .map((imp) => imp.name)\n    .join(',\\n')} } from '${relativeSchemasPath}';\\n\\n`;\n\n  content += contexts;\n\n  return [\n    {\n      content,\n      path: contextPath,\n    },\n  ];\n};\n\nconst generateZodFiles = async (\n  verbOptions: Record<string, GeneratorVerbOptions>,\n  output: NormalizedOutputOptions,\n  context: ContextSpecs,\n) => {\n  const { extension, dirname, filename } = getFileInfo(output.target);\n\n  const header = getHeader(\n    output.override.header,\n    context.specs[context.specKey].info,\n  );\n\n  if (output.mode === 'tags' || output.mode === 'tags-split') {\n    const groupByTags = getVerbOptionGroupByTag(verbOptions);\n\n    const builderContexts = await Promise.all(\n      Object.entries(groupByTags).map(async ([tag, verbs]) => {\n        const zods = await Promise.all(\n          verbs.map((verbOption) =>\n            generateZod(\n              verbOption,\n              {\n                route: verbOption.route,\n                pathRoute: verbOption.pathRoute,\n                override: output.override,\n                context,\n                mock: output.mock,\n                output: output.target!,\n              },\n              output.client,\n            ),\n          ),\n        );\n\n        if (zods.every((z) => z.implementation === '')) {\n          return {\n            content: '',\n            path: '',\n          };\n        }\n\n        const allMutators = zods.reduce(\n          (acc, z) => {\n            for (const mutator of z.mutators ?? []) {\n              acc[mutator.name] = mutator;\n            }\n            return acc;\n          },\n          {} as Record<string, GeneratorMutator>,\n        );\n\n        const mutatorsImports = generateMutatorImports({\n          mutators: Object.values(allMutators),\n        });\n\n        let content = `${header}import { z as zod } from 'zod';\\n${mutatorsImports}\\n`;\n\n        const zodPath =\n          output.mode === 'tags'\n            ? upath.join(dirname, `${kebab(tag)}.zod${extension}`)\n            : upath.join(dirname, tag, tag + '.zod' + extension);\n\n        content += zods.map((zod) => zod.implementation).join('\\n');\n\n        return {\n          content,\n          path: zodPath,\n        };\n      }),\n    );\n\n    return Promise.all(\n      builderContexts.filter((context) => context.content !== ''),\n    );\n  }\n\n  const zods = await Promise.all(\n    Object.values(verbOptions).map((verbOption) =>\n      generateZod(\n        verbOption,\n        {\n          route: verbOption.route,\n          pathRoute: verbOption.pathRoute,\n          override: output.override,\n          context,\n          mock: output.mock,\n          output: output.target!,\n        },\n        output.client,\n      ),\n    ),\n  );\n\n  const allMutators = zods.reduce(\n    (acc, z) => {\n      for (const mutator of z.mutators ?? []) {\n        acc[mutator.name] = mutator;\n      }\n      return acc;\n    },\n    {} as Record<string, GeneratorMutator>,\n  );\n\n  const mutatorsImports = generateMutatorImports({\n    mutators: Object.values(allMutators),\n  });\n\n  let content = `${header}import { z as zod } from 'zod';\\n${mutatorsImports}\\n`;\n\n  const zodPath = upath.join(dirname, `${filename}.zod${extension}`);\n\n  content += zods.map((zod) => zod.implementation).join('\\n');\n\n  return [\n    {\n      content,\n      path: zodPath,\n    },\n  ];\n};\n\nconst generateZvalidator = (\n  output: NormalizedOutputOptions,\n  context: ContextSpecs,\n) => {\n  const header = getHeader(\n    output.override.header,\n    context.specs[context.specKey].info,\n  );\n\n  const content = `\n// based on https://github.com/honojs/middleware/blob/main/packages/zod-validator/src/index.ts\nimport type { z, ZodSchema, ZodError } from 'zod';\nimport {\n  Context,\n  Env,\n  Input,\n  MiddlewareHandler,\n  TypedResponse,\n  ValidationTargets,\n} from 'hono';\n\ntype HasUndefined<T> = undefined extends T ? true : false;\n\ntype Hook<T, E extends Env, P extends string, O = {}> = (\n  result:\n    | { success: true; data: T }\n    | { success: false; error: ZodError; data: T },\n  c: Context<E, P>,\n) =>\n  | Response\n  | Promise<Response>\n  | void\n  | Promise<Response | void>\n  | TypedResponse<O>;\nimport { zValidator as zValidatorBase } from '@hono/zod-validator';\n\ntype ValidationTargetsWithResponse = ValidationTargets & { response: any };\n\nexport const zValidator =\n  <\n    T extends ZodSchema,\n    Target extends keyof ValidationTargetsWithResponse,\n    E extends Env,\n    P extends string,\n    In = z.input<T>,\n    Out = z.output<T>,\n    I extends Input = {\n      in: HasUndefined<In> extends true\n        ? {\n            [K in Target]?: K extends 'json'\n              ? In\n              : HasUndefined<\n                  keyof ValidationTargetsWithResponse[K]\n                > extends true\n              ? { [K2 in keyof In]?: ValidationTargetsWithResponse[K][K2] }\n              : { [K2 in keyof In]: ValidationTargetsWithResponse[K][K2] };\n          }\n        : {\n            [K in Target]: K extends 'json'\n              ? In\n              : HasUndefined<\n                  keyof ValidationTargetsWithResponse[K]\n                > extends true\n              ? { [K2 in keyof In]?: ValidationTargetsWithResponse[K][K2] }\n              : { [K2 in keyof In]: ValidationTargetsWithResponse[K][K2] };\n          };\n      out: { [K in Target]: Out };\n    },\n    V extends I = I,\n  >(\n    target: Target,\n    schema: T,\n    hook?: Hook<z.infer<T>, E, P>,\n  ): MiddlewareHandler<E, P, V> =>\n  async (c, next) => {\n    if (target !== 'response') {\n      const value = await zValidatorBase<\n        T,\n        keyof ValidationTargets,\n        E,\n        P,\n        In,\n        Out,\n        I,\n        V\n      >(\n        target,\n        schema,\n        hook,\n      )(c, next);\n\n      if (value instanceof Response) {\n        return value;\n      }\n    } else {\n      await next();\n\n      if (\n        c.res.status !== 200 ||\n       !c.res.headers.get('Content-Type')?.includes('application/json')\n      ) {\n        return;\n      }\n\n      let value: unknown;\n      try {\n        value = await c.res.json();\n      } catch {\n        const message = 'Malformed JSON in response';\n        c.res = new Response(message, { status: 400 });\n\n        return;\n      }\n\n      const result = await schema.safeParseAsync(value);\n\n      if (hook) {\n        const hookResult = hook({ data: value, ...result }, c);\n        if (hookResult) {\n          if (hookResult instanceof Response || hookResult instanceof Promise) {\n            const hookResponse = await hookResult;\n\n            if (hookResponse instanceof Response) {\n              c.res = new Response(hookResponse.body, hookResponse);\n            }\n          }\n          if (\n            'response' in hookResult &&\n            hookResult.response instanceof Response\n          ) {\n            c.res = new Response(hookResult.response.body, hookResult.response);\n          }\n        }\n      }\n\n      if (!result.success) {\n        c.res = new Response(JSON.stringify(result), {\n          status: 400,\n          headers: {\n            'Content-Type': 'application/json',\n          },\n        });\n      } else {\n        c.res = new Response(JSON.stringify(result.data), c.res);\n      }\n    }\n    \n    return;\n  };\n`;\n\n  let validatorPath = output.override.hono.validatorOutputPath;\n  if (!output.override.hono.validatorOutputPath) {\n    const { extension, dirname, filename } = getFileInfo(output.target);\n\n    validatorPath = upath.join(dirname, `${filename}.validator${extension}`);\n  }\n\n  return {\n    content: `${header}${content}`,\n    path: validatorPath,\n  };\n};\n\nconst generateCompositeRoutes = async (\n  verbOptions: Record<string, GeneratorVerbOptions>,\n  output: NormalizedOutputOptions,\n  context: ContextSpecs,\n) => {\n  const targetInfo = getFileInfo(output.target);\n  const compositeRouteInfo = getFileInfo(output.override.hono.compositeRoute);\n\n  const header = getHeader(\n    output.override.header,\n    context.specs[context.specKey].info,\n  );\n\n  const routes = Object.values(verbOptions)\n    .map((verbOption) => {\n      return generateHonoRoute(verbOption, verbOption.pathRoute);\n    })\n    .join(';');\n\n  const importHandlers = Object.values(verbOptions);\n\n  let ImportHandlersImplementation = '';\n  if (output.override.hono.handlers) {\n    const handlerFileInfo = getFileInfo(output.override.hono.handlers);\n    const operationNames = importHandlers.map(\n      (verbOption) => verbOption.operationName,\n    );\n\n    ImportHandlersImplementation = operationNames\n      .map((operationName) => {\n        const importHandlerName = `${operationName}Handlers`;\n\n        const handlersPath = upath.relativeSafe(\n          compositeRouteInfo.dirname,\n          upath.join(handlerFileInfo.dirname ?? '', `./${operationName}`),\n        );\n\n        return `import { ${importHandlerName} } from '${handlersPath}';`;\n      })\n      .join('\\n');\n  } else {\n    const tags = importHandlers.map((verbOption) =>\n      kebab(verbOption.tags[0] ?? 'default'),\n    );\n    const uniqueTags = tags.filter((t, i) => tags.indexOf(t) === i);\n\n    ImportHandlersImplementation = uniqueTags\n      .map((tag) => {\n        const importHandlerNames = importHandlers\n          .filter((verbOption) => verbOption.tags[0] === tag)\n          .map((verbOption) => ` ${verbOption.operationName}Handlers`)\n          .join(`, \\n`);\n\n        const handlersPath = upath.relativeSafe(\n          compositeRouteInfo.dirname,\n          upath.join(targetInfo.dirname ?? '', tag),\n        );\n\n        return `import {\\n${importHandlerNames}\\n} from '${handlersPath}/${tag}.handlers';`;\n      })\n      .join('\\n');\n  }\n\n  const honoImport = `import { Hono } from 'hono';`;\n  const honoInitialization = `\\nconst app = new Hono()`;\n  const honoAppExport = `\\nexport default app`;\n\n  const content = `${header}${honoImport}\n${ImportHandlersImplementation}\n${honoInitialization}\n${routes}\n${honoAppExport}\n`;\n\n  return [\n    {\n      content,\n      path: output.override.hono.compositeRoute || '',\n    },\n  ];\n};\n\nexport const generateExtraFiles: ClientExtraFilesBuilder = async (\n  verbOptions,\n  output,\n  context,\n) => {\n  const [handlers, contexts, zods, validator, compositeRoutes] =\n    await Promise.all([\n      generateHandlers(verbOptions, output),\n      generateContext(verbOptions, output, context),\n      generateZodFiles(verbOptions, output, context),\n      generateZvalidator(output, context),\n      output.override.hono.compositeRoute\n        ? generateCompositeRoutes(verbOptions, output, context)\n        : [],\n    ]);\n\n  return [\n    ...handlers,\n    ...contexts,\n    ...zods,\n    ...(output.override.hono.validator &&\n    output.override.hono.validator !== 'hono'\n      ? [validator]\n      : []),\n    ...compositeRoutes,\n  ];\n};\n\nconst honoClientBuilder: ClientGeneratorsBuilder = {\n  client: generateHono,\n  dependencies: getHonoDependencies,\n  header: getHonoHeader,\n  footer: getHonoFooter,\n  extraFiles: generateExtraFiles,\n};\n\nexport const builder = () => () => honoClientBuilder;\n\nexport default builder;\n"],"mappings":"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"}