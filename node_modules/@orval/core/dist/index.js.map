{"version":3,"file":"index.js","names":["path","log","LogLevels: Record<LogLevel, number>","lastType: LogType | undefined","lastMsg: string | undefined","options","logger: Logger","path","debug","resolvedPath: string | undefined","fs","file: File | undefined","error: any","mm","replacement","module","path","isFunction","isString","basepath","propName","path","pascalMemory: Record<string, string>","regex","filter","count","path","isObject","keyword","path","ibmOpenapiRuleset","Spectral","errors: { message: string; path: string[] }[]","warnings: { message: string; path: string[] }[]","path","keyword","RefComponentSuffix: Record<RefComponent, string>","search","upath.getSchemaFileName","path","upath.resolve","getSchema","schemaByRefPaths: Schema | undefined","name","schema","additionalImports: GeneratorImport[]","imports","keyword","imports","schemas","keyword","name","separator","resolvedValue","separator","resolvedValue","resolvedValue: ScalarValue | undefined","path","paramGetterProps: GetterProps","imports","schemas","imports","schemas","contentType","path","imports","schemas","path","isRootKey","upath.join","exports","upath.relativeSafe","fs","path","Parser","property","returnStatement","filter","imp","upath.getSpecName","schema","verbOption: GeneratorVerbOptions","upath.join","path","fs","exports","upath.joinSafe","upath.relativeSafe","dirname","fs","path","upath.relativeSafe","dirname","upath.join","fs","acc","upath.join","dirname","fs","target","upath.relativeSafe","tag","upath.joinSafe","target","upath.relativeSafe","dirname","tag","upath.join","fs"],"sources":["../src/types.ts","../src/constants.ts","../src/utils/extension.ts","../src/utils/debug.ts","../src/utils/logger.ts","../src/utils/file.ts","../src/utils/path.ts","../src/utils/assertion.ts","../src/utils/async-reduce.ts","../src/utils/case.ts","../src/utils/compare-version.ts","../src/utils/doc.ts","../src/utils/dynamic-import.ts","../src/utils/file-extensions.ts","../src/utils/is-body-verb.ts","../src/utils/merge-deep.ts","../src/utils/occurrence.ts","../src/utils/open-api-converter.ts","../src/utils/sort.ts","../src/utils/string.ts","../src/utils/tsconfig.ts","../src/utils/validator.ts","../src/getters/enum.ts","../src/getters/ref.ts","../src/resolvers/ref.ts","../src/resolvers/value.ts","../src/resolvers/object.ts","../src/getters/array.ts","../src/getters/res-req-types.ts","../src/getters/body.ts","../src/getters/imports.ts","../src/getters/keys.ts","../src/getters/object.ts","../src/getters/scalar.ts","../src/getters/combine.ts","../src/getters/discriminators.ts","../src/getters/operation.ts","../src/getters/parameters.ts","../src/getters/params.ts","../src/getters/props.ts","../src/getters/query-params.ts","../src/getters/response.ts","../src/getters/route.ts","../src/generators/component-definition.ts","../src/generators/imports.ts","../src/generators/models-inline.ts","../src/generators/mutator.ts","../src/generators/options.ts","../src/generators/parameter-definition.ts","../src/generators/interface.ts","../src/generators/schema-definition.ts","../src/generators/verbs-options.ts","../src/writers/schemas.ts","../src/writers/generate-imports-for-builder.ts","../src/writers/target.ts","../src/writers/types.ts","../src/writers/single-mode.ts","../src/writers/split-mode.ts","../src/writers/target-tags.ts","../src/writers/split-tags-mode.ts","../src/writers/tags-mode.ts"],"sourcesContent":["import type SwaggerParser from '@apidevtools/swagger-parser';\nimport type { allLocales } from '@faker-js/faker';\nimport type { JSONSchema6, JSONSchema7 } from 'json-schema';\nimport type {\n  InfoObject,\n  OpenAPIObject,\n  OperationObject,\n  ParameterObject,\n  ReferenceObject,\n  RequestBodyObject,\n  ResponsesObject,\n  SchemaObject,\n} from 'openapi3-ts/oas30';\nimport type { ConvertInputOptions } from 'swagger2openapi';\nimport type { TypeDocOptions } from 'typedoc';\n\nexport interface Options {\n  output?: string | OutputOptions;\n  input?: string | InputOptions;\n  hooks?: Partial<HooksOptions>;\n}\n\nexport type OptionsFn = () => Options | Promise<Options>;\nexport type OptionsExport = Options | Promise<Options> | OptionsFn;\n\nexport type Config = Record<string, OptionsExport>;\nexport type ConfigFn = () => Config | Promise<Config>;\n\nexport type ConfigExternal = Config | Promise<Config> | ConfigFn;\n\nexport type NormalizedConfig = Record<string, NormalizedOptions | undefined>;\n\nexport interface NormalizedOptions {\n  output: NormalizedOutputOptions;\n  input: NormalizedInputOptions;\n  hooks: NormalizedHookOptions;\n}\n\nexport type NormalizedOutputOptions = {\n  workspace?: string;\n  target?: string;\n  schemas?: string;\n  namingConvention: NamingConvention;\n  fileExtension: string;\n  mode: OutputMode;\n  mock?: GlobalMockOptions | ClientMockBuilder;\n  override: NormalizedOverrideOutput;\n  client: OutputClient | OutputClientFunc;\n  httpClient: OutputHttpClient;\n  clean: boolean | string[];\n  docs: boolean | OutputDocsOptions;\n  prettier: boolean;\n  biome: boolean;\n  tsconfig?: Tsconfig;\n  packageJson?: PackageJson;\n  headers: boolean;\n  indexFiles: boolean;\n  baseUrl?: string | BaseUrlFromSpec | BaseUrlFromConstant;\n  allParamsOptional: boolean;\n  urlEncodeParameters: boolean;\n  unionAddMissingProperties: boolean;\n  optionsParamRequired: boolean;\n  propertySortOrder: PropertySortOrder;\n};\n\nexport type NormalizedParamsSerializerOptions = {\n  qs?: Record<string, any>;\n};\n\nexport type NormalizedOverrideOutput = {\n  title?: (title: string) => string;\n  transformer?: OutputTransformer;\n  mutator?: NormalizedMutator;\n  operations: Record<string, NormalizedOperationOptions>;\n  tags: Record<string, NormalizedOperationOptions>;\n  mock?: OverrideMockOptions;\n  contentType?: OverrideOutputContentType;\n  header: false | ((info: InfoObject) => string[] | string);\n  formData: NormalizedFormDataType<NormalizedMutator>;\n  formUrlEncoded: boolean | NormalizedMutator;\n  paramsSerializer?: NormalizedMutator;\n  paramsSerializerOptions?: NormalizedParamsSerializerOptions;\n  namingConvention: {\n    enum?: NamingConvention;\n  };\n  components: {\n    schemas: {\n      suffix: string;\n      itemSuffix: string;\n    };\n    responses: {\n      suffix: string;\n    };\n    parameters: {\n      suffix: string;\n    };\n    requestBodies: {\n      suffix: string;\n    };\n  };\n  hono: NormalizedHonoOptions;\n  query: NormalizedQueryOptions;\n  angular: Required<AngularOptions>;\n  swr: SwrOptions;\n  zod: NormalizedZodOptions;\n  fetch: NormalizedFetchOptions;\n  operationName?: (\n    operation: OperationObject,\n    route: string,\n    verb: Verbs,\n  ) => string;\n  requestOptions: Record<string, any> | boolean;\n  useDates?: boolean;\n  coerceTypes?: boolean; // deprecated\n  useTypeOverInterfaces?: boolean;\n  useDeprecatedOperations?: boolean;\n  useBigInt?: boolean;\n  useNamedParameters?: boolean;\n  enumGenerationType: EnumGeneration;\n  suppressReadonlyModifier?: boolean;\n  jsDoc: NormalizedJsDocOptions;\n};\n\nexport type NormalizedMutator = {\n  path: string;\n  name?: string;\n  default: boolean;\n  alias?: Record<string, string>;\n  extension?: string;\n};\n\nexport type NormalizedOperationOptions = {\n  transformer?: OutputTransformer;\n  mutator?: NormalizedMutator;\n  mock?: {\n    data?: MockData;\n    properties?: MockProperties;\n  };\n  contentType?: OverrideOutputContentType;\n  query?: NormalizedQueryOptions;\n  angular?: Required<AngularOptions>;\n  swr?: SwrOptions;\n  zod?: NormalizedZodOptions;\n  operationName?: (\n    operation: OperationObject,\n    route: string,\n    verb: Verbs,\n  ) => string;\n  fetch?: FetchOptions;\n  formData?: NormalizedFormDataType<NormalizedMutator>;\n  formUrlEncoded?: boolean | NormalizedMutator;\n  paramsSerializer?: NormalizedMutator;\n  requestOptions?: object | boolean;\n};\n\nexport type NormalizedInputOptions = {\n  target: string | Record<string, unknown> | OpenAPIObject;\n  validation: boolean | object;\n  override: OverrideInput;\n  converterOptions: Partial<ConvertInputOptions>;\n  parserOptions: SwaggerParserOptions;\n  filters?: InputFiltersOption;\n};\n\nexport type OutputClientFunc = (\n  clients: GeneratorClients,\n) => ClientGeneratorsBuilder;\n\nexport type BaseUrlFromSpec = {\n  getBaseUrlFromSpecification: true;\n  variables?: Record<string, string>;\n  index?: number;\n  baseUrl?: never;\n};\n\nexport type BaseUrlFromConstant = {\n  getBaseUrlFromSpecification: false;\n  variables?: never;\n  index?: never;\n  baseUrl: string;\n};\n\nexport const PropertySortOrder = {\n  ALPHABETICAL: 'Alphabetical',\n  SPECIFICATION: 'Specification',\n} as const;\n\nexport type PropertySortOrder =\n  (typeof PropertySortOrder)[keyof typeof PropertySortOrder];\n\nexport const NamingConvention = {\n  CAMEL_CASE: 'camelCase',\n  PASCAL_CASE: 'PascalCase',\n  SNAKE_CASE: 'snake_case',\n  KEBAB_CASE: 'kebab-case',\n} as const;\n\nexport type NamingConvention =\n  (typeof NamingConvention)[keyof typeof NamingConvention];\n\nexport const EnumGeneration = {\n  CONST: 'const',\n  ENUM: 'enum',\n  UNION: 'union',\n} as const;\n\nexport type EnumGeneration =\n  (typeof EnumGeneration)[keyof typeof EnumGeneration];\n\nexport type OutputOptions = {\n  workspace?: string;\n  target?: string;\n  schemas?: string;\n  namingConvention?: NamingConvention;\n  fileExtension?: string;\n  mode?: OutputMode;\n  // If mock is a boolean, it will use the default mock options (type: msw)\n  mock?: boolean | GlobalMockOptions | ClientMockBuilder;\n  override?: OverrideOutput;\n  client?: OutputClient | OutputClientFunc;\n  httpClient?: OutputHttpClient;\n  clean?: boolean | string[];\n  docs?: boolean | OutputDocsOptions;\n  prettier?: boolean;\n  biome?: boolean;\n  tsconfig?: string | Tsconfig;\n  packageJson?: string;\n  headers?: boolean;\n  indexFiles?: boolean;\n  baseUrl?: string | BaseUrlFromSpec | BaseUrlFromConstant;\n  allParamsOptional?: boolean;\n  urlEncodeParameters?: boolean;\n  unionAddMissingProperties?: boolean;\n  optionsParamRequired?: boolean;\n  propertySortOrder?: PropertySortOrder;\n};\n\nexport type SwaggerParserOptions = Omit<SwaggerParser.Options, 'validate'> & {\n  validate?: boolean;\n};\n\nexport type InputFiltersOption = {\n  mode?: 'include' | 'exclude';\n  tags?: (string | RegExp)[];\n  schemas?: (string | RegExp)[];\n};\n\nexport type InputOptions = {\n  target: string | Record<string, unknown> | OpenAPIObject;\n  validation?: boolean | object;\n  override?: OverrideInput;\n  converterOptions?: Partial<ConvertInputOptions>;\n  parserOptions?: SwaggerParserOptions;\n  filters?: InputFiltersOption;\n};\n\nexport const OutputClient = {\n  ANGULAR: 'angular',\n  AXIOS: 'axios',\n  AXIOS_FUNCTIONS: 'axios-functions',\n  REACT_QUERY: 'react-query',\n  SVELTE_QUERY: 'svelte-query',\n  VUE_QUERY: 'vue-query',\n  SWR: 'swr',\n  ZOD: 'zod',\n  HONO: 'hono',\n  FETCH: 'fetch',\n  MCP: 'mcp',\n} as const;\n\nexport type OutputClient = (typeof OutputClient)[keyof typeof OutputClient];\n\nexport const OutputHttpClient = {\n  AXIOS: 'axios',\n  FETCH: 'fetch',\n} as const;\n\nexport type OutputHttpClient =\n  (typeof OutputHttpClient)[keyof typeof OutputHttpClient];\n\nexport const OutputMode = {\n  SINGLE: 'single',\n  SPLIT: 'split',\n  TAGS: 'tags',\n  TAGS_SPLIT: 'tags-split',\n} as const;\n\nexport type OutputMode = (typeof OutputMode)[keyof typeof OutputMode];\n\nexport type OutputDocsOptions = {\n  configPath?: string;\n} & Partial<TypeDocOptions>;\n\n// TODO: add support for other mock types (like cypress or playwright)\nexport const OutputMockType = {\n  MSW: 'msw',\n} as const;\n\nexport type OutputMockType =\n  (typeof OutputMockType)[keyof typeof OutputMockType];\n\nexport type GlobalMockOptions = {\n  // This is the type of the mock that will be generated\n  type: OutputMockType;\n  // This is the option to use the examples from the openapi specification where possible to generate mock data\n  useExamples?: boolean;\n  // This is used to generate mocks for all http responses defined in the OpenAPI specification\n  generateEachHttpStatus?: boolean;\n  // This is used to set the delay to your own custom value, or pass false to disable delay\n  delay?: false | number | (() => number);\n  // This is used to execute functions that are passed to the 'delay' argument\n  // at runtime rather than build time.\n  delayFunctionLazyExecute?: boolean;\n  // This is used to set the base url to your own custom value\n  baseUrl?: string;\n  // This is used to set the locale of the faker library\n  locale?: keyof typeof allLocales;\n  indexMockFiles?: boolean;\n};\n\nexport type OverrideMockOptions = Partial<GlobalMockOptions> & {\n  arrayMin?: number;\n  arrayMax?: number;\n  stringMin?: number;\n  stringMax?: number;\n  numberMin?: number;\n  numberMax?: number;\n  required?: boolean;\n  properties?: MockProperties;\n  format?: Record<string, unknown>;\n  fractionDigits?: number;\n};\n\nexport type MockOptions = Omit<OverrideMockOptions, 'properties'> & {\n  properties?: Record<string, unknown>;\n  operations?: Record<string, { properties: Record<string, unknown> }>;\n  tags?: Record<string, { properties: Record<string, unknown> }>;\n};\n\nexport type MockPropertiesObject = Record<string, unknown>;\nexport type MockPropertiesObjectFn = (\n  specs: OpenAPIObject,\n) => MockPropertiesObject;\n\nexport type MockProperties = MockPropertiesObject | MockPropertiesObjectFn;\n\nexport type MockDataObject = Record<string, unknown>;\n\nexport type MockDataObjectFn = (specs: OpenAPIObject) => MockDataObject;\n\nexport type MockDataArray = unknown[];\n\nexport type MockDataArrayFn = (specs: OpenAPIObject) => MockDataArray;\n\nexport type MockData =\n  | MockDataObject\n  | MockDataObjectFn\n  | MockDataArray\n  | MockDataArrayFn;\n\ntype OutputTransformerFn = (verb: GeneratorVerbOptions) => GeneratorVerbOptions;\n\ntype OutputTransformer = string | OutputTransformerFn;\n\nexport type MutatorObject = {\n  path: string;\n  name?: string;\n  default?: boolean;\n  alias?: Record<string, string>;\n  extension?: string;\n};\n\nexport type Mutator = string | MutatorObject;\n\nexport type ParamsSerializerOptions = {\n  qs?: Record<string, any>;\n};\n\nexport const FormDataArrayHandling = {\n  SERIALIZE: 'serialize',\n  EXPLODE: 'explode',\n  SERIALIZE_WITH_BRACKETS: 'serialize-with-brackets',\n} as const;\n\nexport type FormDataArrayHandling =\n  (typeof FormDataArrayHandling)[keyof typeof FormDataArrayHandling];\n\nexport type NormalizedFormDataType<TMutator> =\n  | {\n      disabled: true;\n      mutator?: never;\n      arrayHandling: FormDataArrayHandling;\n    }\n  | {\n      disabled: false;\n      mutator?: TMutator;\n      arrayHandling: FormDataArrayHandling;\n    };\nexport type FormDataType<TMutator> =\n  | {\n      mutator: TMutator;\n      arrayHandling?: FormDataArrayHandling;\n    }\n  | {\n      mutator?: TMutator;\n      arrayHandling: FormDataArrayHandling;\n    };\n\nexport type OverrideOutput = {\n  title?: (title: string) => string;\n  transformer?: OutputTransformer;\n  mutator?: Mutator;\n  operations?: Record<string, OperationOptions>;\n  tags?: Record<string, OperationOptions>;\n  mock?: OverrideMockOptions;\n  contentType?: OverrideOutputContentType;\n  header?: boolean | ((info: InfoObject) => string[] | string);\n  formData?: boolean | Mutator | FormDataType<Mutator>;\n  formUrlEncoded?: boolean | Mutator;\n  paramsSerializer?: Mutator;\n  paramsSerializerOptions?: ParamsSerializerOptions;\n  namingConvention?: {\n    enum?: NamingConvention;\n  };\n  components?: {\n    schemas?: {\n      suffix?: string;\n      itemSuffix?: string;\n    };\n    responses?: {\n      suffix?: string;\n    };\n    parameters?: {\n      suffix?: string;\n    };\n    requestBodies?: {\n      suffix?: string;\n    };\n  };\n  hono?: HonoOptions;\n  query?: QueryOptions;\n  swr?: SwrOptions;\n  angular?: AngularOptions;\n  zod?: ZodOptions;\n  operationName?: (\n    operation: OperationObject,\n    route: string,\n    verb: Verbs,\n  ) => string;\n  fetch?: FetchOptions;\n  requestOptions?: Record<string, any> | boolean;\n  useDates?: boolean;\n  useTypeOverInterfaces?: boolean;\n  useDeprecatedOperations?: boolean;\n  useBigInt?: boolean;\n  useNamedParameters?: boolean;\n  /**\n   * @deprecated use 'enumGenerationType=\"enum\"' instead\n   */\n  useNativeEnums?: boolean;\n  enumGenerationType?: EnumGeneration;\n  suppressReadonlyModifier?: boolean;\n  jsDoc?: JsDocOptions;\n};\n\nexport type JsDocOptions = {\n  filter?: (schema: Record<string, any>) => { key: string; value: string }[];\n};\n\nexport type NormalizedJsDocOptions = {\n  filter?: (schema: Record<string, any>) => { key: string; value: string }[];\n};\n\nexport type OverrideOutputContentType = {\n  include?: string[];\n  exclude?: string[];\n};\n\nexport type NormalizedHonoOptions = {\n  handlers?: string;\n  compositeRoute: string;\n  validator: boolean | 'hono';\n  validatorOutputPath: string;\n};\n\nexport type ZodDateTimeOptions = {\n  offset?: boolean;\n  local?: boolean;\n  precision?: number;\n};\n\nexport type ZodTimeOptions = {\n  precision?: -1 | 0 | 1 | 2 | 3;\n};\n\nexport type ZodOptions = {\n  strict?: {\n    param?: boolean;\n    query?: boolean;\n    header?: boolean;\n    body?: boolean;\n    response?: boolean;\n  };\n  generate?: {\n    param?: boolean;\n    query?: boolean;\n    header?: boolean;\n    body?: boolean;\n    response?: boolean;\n  };\n  coerce?: {\n    param?: boolean | ZodCoerceType[];\n    query?: boolean | ZodCoerceType[];\n    header?: boolean | ZodCoerceType[];\n    body?: boolean | ZodCoerceType[];\n    response?: boolean | ZodCoerceType[];\n  };\n  preprocess?: {\n    param?: Mutator;\n    query?: Mutator;\n    header?: Mutator;\n    body?: Mutator;\n    response?: Mutator;\n  };\n  dateTimeOptions?: ZodDateTimeOptions;\n  timeOptions?: ZodTimeOptions;\n  generateEachHttpStatus?: boolean;\n};\n\nexport type ZodCoerceType = 'string' | 'number' | 'boolean' | 'bigint' | 'date';\n\nexport type NormalizedZodOptions = {\n  strict: {\n    param: boolean;\n    query: boolean;\n    header: boolean;\n    body: boolean;\n    response: boolean;\n  };\n  generate: {\n    param: boolean;\n    query: boolean;\n    header: boolean;\n    body: boolean;\n    response: boolean;\n  };\n  coerce: {\n    param: boolean | ZodCoerceType[];\n    query: boolean | ZodCoerceType[];\n    header: boolean | ZodCoerceType[];\n    body: boolean | ZodCoerceType[];\n    response: boolean | ZodCoerceType[];\n  };\n  preprocess: {\n    param?: NormalizedMutator;\n    query?: NormalizedMutator;\n    header?: NormalizedMutator;\n    body?: NormalizedMutator;\n    response?: NormalizedMutator;\n  };\n  generateEachHttpStatus: boolean;\n  dateTimeOptions: ZodDateTimeOptions;\n  timeOptions: ZodTimeOptions;\n};\n\nexport type HonoOptions = {\n  handlers?: string;\n  compositeRoute?: string;\n  validator?: boolean | 'hono';\n  validatorOutputPath?: string;\n};\n\nexport type NormalizedQueryOptions = {\n  useQuery?: boolean;\n  useSuspenseQuery?: boolean;\n  useMutation?: boolean;\n  useInfinite?: boolean;\n  useSuspenseInfiniteQuery?: boolean;\n  useInfiniteQueryParam?: string;\n  usePrefetch?: boolean;\n  options?: any;\n  queryKey?: NormalizedMutator;\n  queryOptions?: NormalizedMutator;\n  mutationOptions?: NormalizedMutator;\n  shouldExportMutatorHooks?: boolean;\n  shouldExportHttpClient?: boolean;\n  shouldExportQueryKey?: boolean;\n  shouldSplitQueryKey?: boolean;\n  useOperationIdAsQueryKey?: boolean;\n  signal?: boolean;\n  version?: 3 | 4 | 5;\n};\n\nexport type QueryOptions = {\n  useQuery?: boolean;\n  useSuspenseQuery?: boolean;\n  useMutation?: boolean;\n  useInfinite?: boolean;\n  useSuspenseInfiniteQuery?: boolean;\n  useInfiniteQueryParam?: string;\n  usePrefetch?: boolean;\n  options?: any;\n  queryKey?: Mutator;\n  queryOptions?: Mutator;\n  mutationOptions?: Mutator;\n  shouldExportMutatorHooks?: boolean;\n  shouldExportHttpClient?: boolean;\n  shouldExportQueryKey?: boolean;\n  shouldSplitQueryKey?: boolean;\n  useOperationIdAsQueryKey?: boolean;\n  signal?: boolean;\n  version?: 3 | 4 | 5;\n};\n\nexport type AngularOptions = {\n  provideIn?: 'root' | 'any' | boolean;\n};\n\nexport type SwrOptions = {\n  useInfinite?: boolean;\n  useSWRMutationForGet?: boolean;\n  swrOptions?: any;\n  swrMutationOptions?: any;\n  swrInfiniteOptions?: any;\n};\n\nexport type NormalizedFetchOptions = {\n  includeHttpResponseReturnType: boolean;\n  forceSuccessResponse: boolean;\n  explode: boolean;\n  jsonReviver?: Mutator;\n};\n\nexport type FetchOptions = {\n  includeHttpResponseReturnType?: boolean;\n  forceSuccessResponse?: boolean;\n  explode?: boolean;\n  jsonReviver?: Mutator;\n};\n\nexport type InputTransformerFn = (spec: OpenAPIObject) => OpenAPIObject;\n\ntype InputTransformer = string | InputTransformerFn;\n\nexport type OverrideInput = {\n  transformer?: InputTransformer;\n};\n\nexport type OperationOptions = {\n  transformer?: OutputTransformer;\n  mutator?: Mutator;\n  mock?: {\n    data?: MockData;\n    properties?: MockProperties;\n  };\n  query?: QueryOptions;\n  angular?: Required<AngularOptions>;\n  swr?: SwrOptions;\n  zod?: ZodOptions;\n  operationName?: (\n    operation: OperationObject,\n    route: string,\n    verb: Verbs,\n  ) => string;\n  fetch?: FetchOptions;\n  formData?: boolean | Mutator | FormDataType<Mutator>;\n  formUrlEncoded?: boolean | Mutator;\n  paramsSerializer?: Mutator;\n  requestOptions?: object | boolean;\n};\n\nexport type Hook = 'afterAllFilesWrite';\n\nexport type HookFunction = (...args: any[]) => void | Promise<void>;\n\nexport interface HookOption {\n  command: string | HookFunction;\n  injectGeneratedDirsAndFiles?: boolean;\n}\n\nexport type HookCommand =\n  | string\n  | HookFunction\n  | HookOption\n  | (string | HookFunction | HookOption)[];\n\nexport type NormalizedHookCommand = HookCommand[];\n\nexport type HooksOptions<T = HookCommand | NormalizedHookCommand> = Partial<\n  Record<Hook, T>\n>;\n\nexport type NormalizedHookOptions = HooksOptions<NormalizedHookCommand>;\n\nexport type Verbs = 'post' | 'put' | 'get' | 'patch' | 'delete' | 'head';\n\nexport const Verbs = {\n  POST: 'post' as Verbs,\n  PUT: 'put' as Verbs,\n  GET: 'get' as Verbs,\n  PATCH: 'patch' as Verbs,\n  DELETE: 'delete' as Verbs,\n  HEAD: 'head' as Verbs,\n};\n\nexport type ImportOpenApi = {\n  data: JSONSchema6 | JSONSchema7 | Record<string, unknown | OpenAPIObject>;\n  input: NormalizedInputOptions;\n  output: NormalizedOutputOptions;\n  target: string;\n  workspace: string;\n};\n\nexport interface ContextSpecs {\n  specKey: string;\n  target: string;\n  workspace: string;\n  specs: Record<string, OpenAPIObject>;\n  parents?: string[];\n  output: NormalizedOutputOptions;\n}\n\nexport interface GlobalOptions {\n  projectName?: string;\n  watch?: boolean | string | (string | boolean)[];\n  clean?: boolean | string[];\n  prettier?: boolean;\n  biome?: boolean;\n  mock?: boolean | GlobalMockOptions;\n  client?: OutputClient;\n  httpClient?: OutputHttpClient;\n  mode?: OutputMode;\n  tsconfig?: string | Tsconfig;\n  packageJson?: string;\n  input?: string;\n  output?: string;\n}\n\nexport interface Tsconfig {\n  baseUrl?: string;\n  compilerOptions?: {\n    esModuleInterop?: boolean;\n    allowSyntheticDefaultImports?: boolean;\n    exactOptionalPropertyTypes?: boolean;\n    paths?: Record<string, string[]>;\n    target?: TsConfigTarget;\n  };\n}\n\nexport type TsConfigTarget =\n  | 'es3'\n  | 'es5'\n  | 'es6'\n  | 'es2015'\n  | 'es2016'\n  | 'es2017'\n  | 'es2018'\n  | 'es2019'\n  | 'es2020'\n  | 'es2021'\n  | 'es2022'\n  | 'esnext'; // https://www.typescriptlang.org/tsconfig#target\n\nexport interface PackageJson {\n  dependencies?: Record<string, string>;\n  devDependencies?: Record<string, string>;\n  peerDependencies?: Record<string, string>;\n}\n\nexport type GeneratorSchema = {\n  name: string;\n  model: string;\n  imports: GeneratorImport[];\n};\n\nexport type GeneratorImport = {\n  name: string;\n  schemaName?: string;\n  isConstant?: boolean;\n  alias?: string;\n  specKey?: string;\n  default?: boolean;\n  values?: boolean;\n  syntheticDefaultImport?: boolean;\n};\n\nexport type GeneratorDependency = {\n  exports: GeneratorImport[];\n  dependency: string;\n};\n\nexport type GeneratorApiResponse = {\n  operations: GeneratorOperations;\n  schemas: GeneratorSchema[];\n};\n\nexport type GeneratorOperations = Record<string, GeneratorOperation>;\n\nexport type GeneratorTarget = {\n  imports: GeneratorImport[];\n  implementation: string;\n  implementationMock: string;\n  importsMock: GeneratorImport[];\n  mutators?: GeneratorMutator[];\n  clientMutators?: GeneratorMutator[];\n  formData?: GeneratorMutator[];\n  formUrlEncoded?: GeneratorMutator[];\n  paramsSerializer?: GeneratorMutator[];\n  fetchReviver?: GeneratorMutator[];\n};\n\nexport type GeneratorTargetFull = {\n  imports: GeneratorImport[];\n  implementation: string;\n  implementationMock: {\n    function: string;\n    handler: string;\n    handlerName: string;\n  };\n  importsMock: GeneratorImport[];\n  mutators?: GeneratorMutator[];\n  clientMutators?: GeneratorMutator[];\n  formData?: GeneratorMutator[];\n  formUrlEncoded?: GeneratorMutator[];\n  paramsSerializer?: GeneratorMutator[];\n  fetchReviver?: GeneratorMutator[];\n};\n\nexport type GeneratorOperation = {\n  imports: GeneratorImport[];\n  implementation: string;\n  implementationMock: {\n    function: string;\n    handler: string;\n    handlerName: string;\n  };\n  importsMock: GeneratorImport[];\n  tags: string[];\n  mutator?: GeneratorMutator;\n  clientMutators?: GeneratorMutator[];\n  formData?: GeneratorMutator;\n  formUrlEncoded?: GeneratorMutator;\n  paramsSerializer?: GeneratorMutator;\n  fetchReviver?: GeneratorMutator;\n  operationName: string;\n  types?: {\n    result: (title?: string) => string;\n  };\n};\n\nexport type GeneratorVerbOptions = {\n  verb: Verbs;\n  route: string;\n  pathRoute: string;\n  summary?: string;\n  doc: string;\n  tags: string[];\n  operationId: string;\n  operationName: string;\n  response: GetterResponse;\n  body: GetterBody;\n  headers?: GetterQueryParam;\n  queryParams?: GetterQueryParam;\n  params: GetterParams;\n  props: GetterProps;\n  mutator?: GeneratorMutator;\n  formData?: GeneratorMutator;\n  formUrlEncoded?: GeneratorMutator;\n  paramsSerializer?: GeneratorMutator;\n  fetchReviver?: GeneratorMutator;\n  override: NormalizedOverrideOutput;\n  deprecated?: boolean;\n  originalOperation: OperationObject;\n};\n\nexport type GeneratorVerbsOptions = GeneratorVerbOptions[];\n\nexport type GeneratorOptions = {\n  route: string;\n  pathRoute: string;\n  override: NormalizedOverrideOutput;\n  context: ContextSpecs;\n  mock?: GlobalMockOptions | ClientMockBuilder;\n  output: string;\n};\n\nexport type GeneratorClient = {\n  implementation: string;\n  imports: GeneratorImport[];\n  mutators?: GeneratorMutator[];\n};\n\nexport type GeneratorMutatorParsingInfo = {\n  numberOfParams: number;\n  returnNumberOfParams?: number;\n};\nexport type GeneratorMutator = {\n  name: string;\n  path: string;\n  default: boolean;\n  hasErrorType: boolean;\n  errorTypeName: string;\n  hasSecondArg: boolean;\n  hasThirdArg: boolean;\n  isHook: boolean;\n  bodyTypeName?: string;\n};\n\nexport type ClientBuilder = (\n  verbOptions: GeneratorVerbOptions,\n  options: GeneratorOptions,\n  outputClient: OutputClient | OutputClientFunc,\n  output?: NormalizedOutputOptions,\n) => GeneratorClient | Promise<GeneratorClient>;\n\nexport type ClientFileBuilder = {\n  path: string;\n  content: string;\n};\nexport type ClientExtraFilesBuilder = (\n  verbOptions: Record<string, GeneratorVerbOptions>,\n  output: NormalizedOutputOptions,\n  context: ContextSpecs,\n) => Promise<ClientFileBuilder[]>;\n\nexport type ClientHeaderBuilder = (params: {\n  title: string;\n  isRequestOptions: boolean;\n  isMutator: boolean;\n  noFunction?: boolean;\n  isGlobalMutator: boolean;\n  provideIn: boolean | 'root' | 'any';\n  hasAwaitedType: boolean;\n  output: NormalizedOutputOptions;\n  verbOptions: Record<string, GeneratorVerbOptions>;\n  tag?: string;\n  clientImplementation: string;\n}) => string;\n\nexport type ClientFooterBuilder = (params: {\n  noFunction?: boolean | undefined;\n  operationNames: string[];\n  title?: string;\n  hasAwaitedType: boolean;\n  hasMutator: boolean;\n}) => string;\n\nexport type ClientTitleBuilder = (title: string) => string;\n\nexport type ClientDependenciesBuilder = (\n  hasGlobalMutator: boolean,\n  hasParamsSerializerOptions: boolean,\n  packageJson?: PackageJson,\n  httpClient?: OutputHttpClient,\n  hasTagsMutator?: boolean,\n  override?: NormalizedOverrideOutput,\n) => GeneratorDependency[];\n\nexport type ClientMockGeneratorImplementation = {\n  function: string;\n  handlerName: string;\n  handler: string;\n};\n\nexport type ClientMockGeneratorBuilder = {\n  imports: GeneratorImport[];\n  implementation: ClientMockGeneratorImplementation;\n};\n\nexport type ClientMockBuilder = (\n  verbOptions: GeneratorVerbOptions,\n  generatorOptions: GeneratorOptions,\n) => ClientMockGeneratorBuilder;\n\nexport interface ClientGeneratorsBuilder {\n  client: ClientBuilder;\n  header?: ClientHeaderBuilder;\n  dependencies?: ClientDependenciesBuilder;\n  footer?: ClientFooterBuilder;\n  title?: ClientTitleBuilder;\n  extraFiles?: ClientExtraFilesBuilder;\n}\n\nexport type GeneratorClients = Record<OutputClient, ClientGeneratorsBuilder>;\n\nexport type GetterResponse = {\n  imports: GeneratorImport[];\n  definition: {\n    success: string;\n    errors: string;\n  };\n  isBlob: boolean;\n  types: {\n    success: ResReqTypesValue[];\n    errors: ResReqTypesValue[];\n  };\n  contentTypes: string[];\n  schemas: GeneratorSchema[];\n\n  originalSchema?: ResponsesObject;\n};\n\nexport type GetterBody = {\n  originalSchema: ReferenceObject | RequestBodyObject;\n  imports: GeneratorImport[];\n  definition: string;\n  implementation: string;\n  schemas: GeneratorSchema[];\n  formData?: string;\n  formUrlEncoded?: string;\n  contentType: string;\n  isOptional: boolean;\n};\n\nexport type GetterParameters = {\n  query: { parameter: ParameterObject; imports: GeneratorImport[] }[];\n  path: { parameter: ParameterObject; imports: GeneratorImport[] }[];\n  header: { parameter: ParameterObject; imports: GeneratorImport[] }[];\n};\n\nexport type GetterParam = {\n  name: string;\n  definition: string;\n  implementation: string;\n  default: boolean;\n  required: boolean;\n  imports: GeneratorImport[];\n};\n\nexport type GetterParams = GetterParam[];\nexport type GetterQueryParam = {\n  schema: GeneratorSchema;\n  deps: GeneratorSchema[];\n  isOptional: boolean;\n  originalSchema?: SchemaObject;\n};\n\nexport type GetterPropType =\n  | 'param'\n  | 'body'\n  | 'queryParam'\n  | 'header'\n  | 'namedPathParams';\n\nexport const GetterPropType = {\n  PARAM: 'param',\n  NAMED_PATH_PARAMS: 'namedPathParams',\n  BODY: 'body',\n  QUERY_PARAM: 'queryParam',\n  HEADER: 'header',\n} as const;\n\ntype GetterPropBase = {\n  name: string;\n  definition: string;\n  implementation: string;\n  default: boolean;\n  required: boolean;\n};\n\nexport type GetterProp = GetterPropBase &\n  (\n    | { type: 'namedPathParams'; destructured: string; schema: GeneratorSchema }\n    | { type: Exclude<GetterPropType, 'namedPathParams'> }\n  );\n\nexport type GetterProps = GetterProp[];\n\nexport type SchemaType =\n  | 'integer'\n  | 'number'\n  | 'string'\n  | 'boolean'\n  | 'object'\n  | 'null'\n  | 'array'\n  | 'enum'\n  | 'unknown';\n\nexport const SchemaType = {\n  integer: 'integer',\n  number: 'number',\n  string: 'string',\n  boolean: 'boolean',\n  object: 'object',\n  null: 'null',\n  array: 'array',\n  enum: 'enum',\n  unknown: 'unknown',\n};\n\nexport type ScalarValue = {\n  value: string;\n  isEnum: boolean;\n  hasReadonlyProps: boolean;\n  type: SchemaType;\n  imports: GeneratorImport[];\n  schemas: GeneratorSchema[];\n  isRef: boolean;\n  example?: any;\n  examples?: Record<string, any>;\n};\n\nexport type ResolverValue = ScalarValue & {\n  originalSchema: SchemaObject;\n};\n\nexport type ResReqTypesValue = ScalarValue & {\n  formData?: string;\n  formUrlEncoded?: string;\n  isRef?: boolean;\n  hasReadonlyProps?: boolean;\n  key: string;\n  contentType: string;\n  originalSchema?: SchemaObject;\n};\n\nexport type WriteSpecsBuilder = {\n  operations: GeneratorOperations;\n  schemas: Record<string, GeneratorSchema[]>;\n  verbOptions: Record<string, GeneratorVerbOptions>;\n  title: GeneratorClientTitle;\n  header: GeneratorClientHeader;\n  footer: GeneratorClientFooter;\n  imports: GeneratorClientImports;\n  importsMock: GenerateMockImports;\n  extraFiles: ClientFileBuilder[];\n  info: InfoObject;\n  target: string;\n};\n\nexport type WriteModeProps = {\n  builder: WriteSpecsBuilder;\n  output: NormalizedOutputOptions;\n  workspace: string;\n  specsName: Record<string, string>;\n  header: string;\n  needSchema: boolean;\n};\n\nexport type GeneratorApiOperations = {\n  verbOptions: Record<string, GeneratorVerbOptions>;\n  operations: GeneratorOperations;\n  schemas: GeneratorSchema[];\n};\n\nexport type GeneratorClientExtra = {\n  implementation: string;\n  implementationMock: string;\n};\n\nexport type GeneratorClientTitle = (data: {\n  outputClient?: OutputClient | OutputClientFunc;\n  title: string;\n  customTitleFunc?: (title: string) => string;\n  output: NormalizedOutputOptions;\n}) => GeneratorClientExtra;\n\nexport type GeneratorClientHeader = (data: {\n  outputClient?: OutputClient | OutputClientFunc;\n  isRequestOptions: boolean;\n  isMutator: boolean;\n  isGlobalMutator: boolean;\n  provideIn: boolean | 'root' | 'any';\n  hasAwaitedType: boolean;\n  titles: GeneratorClientExtra;\n  output: NormalizedOutputOptions;\n  verbOptions: Record<string, GeneratorVerbOptions>;\n  tag?: string;\n  clientImplementation: string;\n}) => GeneratorClientExtra;\n\nexport type GeneratorClientFooter = (data: {\n  outputClient: OutputClient | OutputClientFunc;\n  operationNames: string[];\n  hasMutator: boolean;\n  hasAwaitedType: boolean;\n  titles: GeneratorClientExtra;\n  output: NormalizedOutputOptions;\n}) => GeneratorClientExtra;\n\nexport type GeneratorClientImports = (data: {\n  client: OutputClient | OutputClientFunc;\n  implementation: string;\n  imports: {\n    exports: GeneratorImport[];\n    dependency: string;\n  }[];\n  specsName: Record<string, string>;\n  hasSchemaDir: boolean;\n  isAllowSyntheticDefaultImports: boolean;\n  hasGlobalMutator: boolean;\n  hasTagsMutator: boolean;\n  hasParamsSerializerOptions: boolean;\n  packageJson?: PackageJson;\n  output: NormalizedOutputOptions;\n}) => string;\n\nexport type GenerateMockImports = (data: {\n  implementation: string;\n  imports: {\n    exports: GeneratorImport[];\n    dependency: string;\n  }[];\n  specsName: Record<string, string>;\n  hasSchemaDir: boolean;\n  isAllowSyntheticDefaultImports: boolean;\n  options?: GlobalMockOptions;\n}) => string;\n\nexport type GeneratorApiBuilder = GeneratorApiOperations & {\n  title: GeneratorClientTitle;\n  header: GeneratorClientHeader;\n  footer: GeneratorClientFooter;\n  imports: GeneratorClientImports;\n  importsMock: GenerateMockImports;\n  extraFiles: ClientFileBuilder[];\n};\n\nexport interface SchemaWithConst extends SchemaObject {\n  const: string;\n}\n\nexport class ErrorWithTag extends Error {\n  tag: string;\n  constructor(message: string, tag: string, options?: ErrorOptions) {\n    super(message, options);\n    this.tag = tag;\n  }\n}\n","import { Verbs } from './types';\n\nexport const generalJSTypes = [\n  'number',\n  'string',\n  'null',\n  'unknown',\n  'undefined',\n  'object',\n  'blob',\n];\n\nexport const generalJSTypesWithArray = generalJSTypes.reduce<string[]>(\n  (acc, type) => {\n    acc.push(type, `Array<${type}>`, `${type}[]`);\n\n    return acc;\n  },\n  [],\n);\n\nexport const VERBS_WITH_BODY = [\n  Verbs.POST,\n  Verbs.PUT,\n  Verbs.PATCH,\n  Verbs.DELETE,\n];\n\nexport const URL_REGEX =\n  /^(?:http(s)?:\\/\\/)?[\\w.-]+(?:\\.[\\w\\.-]+)+[\\w\\-\\._~:/?#[\\]@!\\$&'\\(\\)\\*\\+,;=.]+$/;\n\nexport const TEMPLATE_TAG_REGEX = /\\${(.+?)}/g; // For replace of 'thing' ${thing}\n","export const getExtension = (path: string) =>\n  path.toLowerCase().includes('.yaml') || path.toLowerCase().includes('.yml')\n    ? 'yaml'\n    : 'json';\n","import debug from 'debug';\n\nconst filter = process.env.ORVAL_DEBUG_FILTER;\nconst DEBUG = process.env.DEBUG;\n\ninterface DebuggerOptions {\n  onlyWhenFocused?: boolean | string;\n}\n\nexport function createDebugger(\n  ns: string,\n  options: DebuggerOptions = {},\n): debug.Debugger['log'] {\n  const log = debug(ns);\n  const { onlyWhenFocused } = options;\n  const focus = typeof onlyWhenFocused === 'string' ? onlyWhenFocused : ns;\n  return (msg: string, ...args: any[]) => {\n    if (filter && !msg.includes(filter)) {\n      return;\n    }\n    if (onlyWhenFocused && !DEBUG?.includes(focus)) {\n      return;\n    }\n    log(msg, ...args);\n  };\n}\n","import readline from 'node:readline';\n\nimport chalk from 'chalk';\n\nexport const log = console.log;\n\nexport const startMessage = ({\n  name,\n  version,\n  description,\n}: {\n  name: string;\n  version: string;\n  description: string;\n}) =>\n  `🍻 ${chalk.cyan.bold(name)} ${chalk.green(`v${version}`)}${\n    description ? ` - ${description}` : ''\n  }`;\n\nexport const logError = (err: unknown, tag?: string) => {\n  log(\n    chalk.red(\n      [\n        '🛑',\n        tag ? `${tag} -` : undefined,\n        err instanceof Error ? err.stack : err,\n      ]\n        .filter(Boolean)\n        .join(' '),\n    ),\n  );\n};\n\nexport const mismatchArgsMessage = (mismatchArgs: string[]) => {\n  log(\n    chalk.yellow(\n      `${mismatchArgs.join(', ')} ${\n        mismatchArgs.length === 1 ? 'is' : 'are'\n      } not defined in your configuration!`,\n    ),\n  );\n};\n\nexport const createSuccessMessage = (backend?: string) => {\n  log(\n    `🎉 ${\n      backend ? `${chalk.green(backend)} - ` : ''\n    }Your OpenAPI spec has been converted into ready to use orval!`,\n  );\n};\n\nexport const ibmOpenapiValidatorWarnings = (\n  warnings: {\n    path: string[];\n    message: string;\n  }[],\n) => {\n  log(chalk.yellow('(!) Warnings'));\n\n  for (const i of warnings)\n    log(chalk.yellow(`Message : ${i.message}\\nPath    : ${i.path.join(', ')}`));\n};\n\nexport const ibmOpenapiValidatorErrors = (\n  errors: {\n    path: string[];\n    message: string;\n  }[],\n) => {\n  log(chalk.red('(!) Errors'));\n\n  for (const i of errors)\n    log(chalk.red(`Message : ${i.message}\\nPath    : ${i.path.join(', ')}`));\n};\n\nexport type LogType = 'error' | 'warn' | 'info';\nexport type LogLevel = LogType | 'silent';\nexport interface Logger {\n  info(msg: string, options?: LogOptions): void;\n  warn(msg: string, options?: LogOptions): void;\n  warnOnce(msg: string, options?: LogOptions): void;\n  error(msg: string, options?: LogOptions): void;\n  clearScreen(type: LogType): void;\n  hasWarned: boolean;\n}\n\nexport interface LogOptions {\n  clear?: boolean;\n  timestamp?: boolean;\n}\n\nexport const LogLevels: Record<LogLevel, number> = {\n  silent: 0,\n  error: 1,\n  warn: 2,\n  info: 3,\n};\n\nlet lastType: LogType | undefined;\nlet lastMsg: string | undefined;\nlet sameCount = 0;\n\nfunction clearScreen() {\n  const repeatCount = process.stdout.rows - 2;\n  const blank = repeatCount > 0 ? '\\n'.repeat(repeatCount) : '';\n  console.log(blank);\n  readline.cursorTo(process.stdout, 0, 0);\n  readline.clearScreenDown(process.stdout);\n}\n\nexport interface LoggerOptions {\n  prefix?: string;\n  allowClearScreen?: boolean;\n}\n\nexport function createLogger(\n  level: LogLevel = 'info',\n  options: LoggerOptions = {},\n): Logger {\n  const { prefix = '[vite]', allowClearScreen = true } = options;\n\n  const thresh = LogLevels[level];\n  const clear =\n    allowClearScreen && process.stdout.isTTY && !process.env.CI\n      ? clearScreen\n      : () => {};\n\n  function output(type: LogType, msg: string, options: LogOptions = {}) {\n    if (thresh >= LogLevels[type]) {\n      const method = type === 'info' ? 'log' : type;\n      const format = () => {\n        if (options.timestamp) {\n          const tag =\n            type === 'info'\n              ? chalk.cyan.bold(prefix)\n              : type === 'warn'\n                ? chalk.yellow.bold(prefix)\n                : chalk.red.bold(prefix);\n          return `${chalk.dim(new Date().toLocaleTimeString())} ${tag} ${msg}`;\n        } else {\n          return msg;\n        }\n      };\n      if (type === lastType && msg === lastMsg) {\n        sameCount++;\n        clear();\n        console[method](format(), chalk.yellow(`(x${sameCount + 1})`));\n      } else {\n        sameCount = 0;\n        lastMsg = msg;\n        lastType = type;\n        if (options.clear) {\n          clear();\n        }\n        console[method](format());\n      }\n    }\n  }\n\n  const warnedMessages = new Set<string>();\n\n  const logger: Logger = {\n    hasWarned: false,\n    info(msg, opts) {\n      output('info', msg, opts);\n    },\n    warn(msg, opts) {\n      logger.hasWarned = true;\n      output('warn', msg, opts);\n    },\n    warnOnce(msg, opts) {\n      if (warnedMessages.has(msg)) return;\n      logger.hasWarned = true;\n      output('warn', msg, opts);\n      warnedMessages.add(msg);\n    },\n    error(msg, opts) {\n      logger.hasWarned = true;\n      output('error', msg, opts);\n    },\n    clearScreen(type) {\n      if (thresh >= LogLevels[type]) {\n        clear();\n      }\n    },\n  };\n\n  return logger;\n}\n","import fs from 'node:fs';\nimport path from 'node:path';\n\nimport chalk from 'chalk';\nimport { build, type PluginBuild } from 'esbuild';\nimport glob from 'globby';\nimport mm from 'micromatch';\n\nimport type { Tsconfig } from '../types';\nimport { isDirectory } from './assertion';\nimport { createDebugger } from './debug';\nimport { createLogger, type LogLevel } from './logger';\nimport { joinSafe, normalizeSafe } from './path';\n\nexport const getFileInfo = (\n  target = '',\n  {\n    backupFilename = 'filename',\n    extension = '.ts',\n  }: { backupFilename?: string; extension?: string } = {},\n) => {\n  const isDir = isDirectory(target);\n  const filePath = isDir\n    ? path.join(target, backupFilename + extension)\n    : target;\n  const pathWithoutExtension = filePath.replace(/\\.[^/.]+$/, '');\n  const dir = path.dirname(filePath);\n  const filename = path.basename(\n    filePath,\n    extension.startsWith('.') ? extension : `.${extension}`,\n  );\n\n  return {\n    path: filePath,\n    pathWithoutExtension,\n    extension,\n    isDirectory: isDir,\n    dirname: dir,\n    filename,\n  };\n};\n\nconst debug = createDebugger('orval:file-load');\n\nconst cache = new Map<string, { file?: any; error?: any }>();\n\nexport async function loadFile<File = any>(\n  filePath?: string,\n  options?: {\n    root?: string;\n    defaultFileName?: string;\n    logLevel?: LogLevel;\n    isDefault?: boolean;\n    alias?: Record<string, string>;\n    tsconfig?: Tsconfig;\n    load?: boolean;\n  },\n): Promise<{\n  path: string;\n  file?: File;\n  error?: any;\n  cached?: boolean;\n}> {\n  const {\n    root = process.cwd(),\n    isDefault = true,\n    defaultFileName,\n    logLevel,\n    alias,\n    tsconfig,\n    load = true,\n  } = options ?? {};\n  const start = Date.now();\n\n  let resolvedPath: string | undefined;\n  let isTS = false;\n  let isMjs = false;\n\n  if (filePath) {\n    // explicit path is always resolved from cwd\n    resolvedPath = path.resolve(filePath);\n    isTS = filePath.endsWith('.ts');\n  } else if (defaultFileName) {\n    // implicit file loaded from inline root (if present)\n    // otherwise from cwd\n    const jsFile = path.resolve(root, `${defaultFileName}.js`);\n    if (fs.existsSync(jsFile)) {\n      resolvedPath = jsFile;\n    }\n\n    if (!resolvedPath) {\n      const mjsFile = path.resolve(root, `${defaultFileName}.mjs`);\n      if (fs.existsSync(mjsFile)) {\n        resolvedPath = mjsFile;\n        isMjs = true;\n      }\n    }\n\n    if (!resolvedPath) {\n      const cjsFile = path.resolve(root, `${defaultFileName}.cjs`);\n      if (fs.existsSync(cjsFile)) {\n        resolvedPath = cjsFile;\n      }\n    }\n\n    if (!resolvedPath) {\n      const tsFile = path.resolve(root, `${defaultFileName}.ts`);\n      if (fs.existsSync(tsFile)) {\n        resolvedPath = tsFile;\n        isTS = true;\n      }\n    }\n  }\n\n  if (!resolvedPath) {\n    if (filePath) {\n      throw new Error(chalk.red(`File not found => ${filePath}`));\n    } else if (defaultFileName) {\n      throw new Error(\n        chalk.red(`File not found => ${defaultFileName}.{js,mjs,cjs,ts}`),\n      );\n    } else {\n      throw new Error(chalk.red(`File not found`));\n    }\n  }\n\n  const normalizeResolvedPath = normalizeSafe(resolvedPath);\n  const cachedData = cache.get(resolvedPath);\n\n  if (cachedData) {\n    return {\n      path: normalizeResolvedPath,\n      ...cachedData,\n      cached: true,\n    };\n  }\n\n  try {\n    let file: File | undefined;\n\n    if (!file && !isTS && !isMjs) {\n      // 1. try to directly require the module (assuming commonjs)\n      try {\n        // clear cache in case of server restart\n        delete require.cache[require.resolve(resolvedPath)];\n\n        file = require(resolvedPath);\n\n        debug(`cjs loaded in ${Date.now() - start}ms`);\n      } catch (error) {\n        const ignored = new RegExp(\n          [\n            `Cannot use import statement`,\n            `Must use import to load ES Module`,\n            // #1635, #2050 some Node 12.x versions don't have esm detection\n            // so it throws normal syntax errors when encountering esm syntax\n            `Unexpected token`,\n            `Unexpected identifier`,\n          ].join('|'),\n        );\n        //@ts-ignore\n        if (!ignored.test(error.message)) {\n          throw error;\n        }\n      }\n    }\n\n    if (!file) {\n      // 2. if we reach here, the file is ts or using es import syntax, or\n      // the user has type: \"module\" in their package.json (#917)\n      // transpile es import syntax to require syntax using rollup.\n      // lazy require rollup (it's actually in dependencies)\n      const { code } = await bundleFile(\n        resolvedPath,\n        isMjs,\n        root || path.dirname(normalizeResolvedPath),\n        alias,\n        tsconfig?.compilerOptions,\n      );\n\n      file = load\n        ? await loadFromBundledFile<File>(resolvedPath, code, isDefault)\n        : (code as any);\n\n      debug(`bundled file loaded in ${Date.now() - start}ms`);\n    }\n\n    cache.set(resolvedPath, { file });\n\n    return {\n      path: normalizeResolvedPath,\n      file,\n    };\n  } catch (error: any) {\n    cache.set(resolvedPath, { error });\n\n    return {\n      path: normalizeResolvedPath,\n      error,\n    };\n  }\n}\n\nasync function bundleFile(\n  fileName: string,\n  mjs = false,\n  workspace: string,\n  alias?: Record<string, string>,\n  compilerOptions?: Tsconfig['compilerOptions'],\n): Promise<{ code: string; dependencies: string[] }> {\n  const result = await build({\n    absWorkingDir: process.cwd(),\n    entryPoints: [fileName],\n    outfile: 'out.js',\n    write: false,\n    platform: 'node',\n    bundle: true,\n    format: mjs ? 'esm' : 'cjs',\n    sourcemap: 'inline',\n    metafile: true,\n    target: compilerOptions?.target || 'es6',\n    minify: false,\n    minifyIdentifiers: false,\n    minifySyntax: false,\n    minifyWhitespace: false,\n    treeShaking: false,\n    keepNames: false,\n    plugins: [\n      ...(alias || compilerOptions?.paths\n        ? [\n            {\n              name: 'aliasing',\n              setup(build: PluginBuild) {\n                build.onResolve(\n                  { filter: /^[\\w@][^:]/ },\n                  async ({ path: id }) => {\n                    if (alias) {\n                      const matchKeys = Object.keys(alias);\n                      const match = matchKeys.find(\n                        (key) =>\n                          id.startsWith(key) || mm.isMatch(id, matchKeys),\n                      );\n\n                      if (match) {\n                        const find = mm.scan(match);\n                        const replacement = mm.scan(alias[match]);\n\n                        const base = path.resolve(workspace, replacement.base);\n                        const newPath = find.base\n                          ? id.replace(find.base, base)\n                          : joinSafe(base, id);\n\n                        const ext = path.extname(newPath);\n\n                        const aliased = ext ? newPath : `${newPath}.ts`;\n\n                        if (!fs.existsSync(aliased)) {\n                          return;\n                        }\n\n                        return {\n                          path: aliased,\n                        };\n                      }\n                    }\n\n                    if (compilerOptions?.paths) {\n                      const matchKeys = Object.keys(compilerOptions?.paths);\n                      const match = matchKeys.find(\n                        (key) =>\n                          id.startsWith(key) || mm.isMatch(id, matchKeys),\n                      );\n\n                      if (match) {\n                        const find = mm.scan(match);\n                        const replacement = mm.scan(\n                          compilerOptions?.paths[match][0],\n                        );\n\n                        const base = path.resolve(workspace, replacement.base);\n                        const newPath = find.base\n                          ? id.replace(find.base, base)\n                          : joinSafe(base, id);\n\n                        const ext = path.extname(newPath);\n\n                        const aliased = ext ? newPath : `${newPath}.ts`;\n\n                        if (!fs.existsSync(aliased)) {\n                          return;\n                        }\n\n                        return {\n                          path: aliased,\n                        };\n                      }\n                    }\n                  },\n                );\n              },\n            },\n          ]\n        : []),\n      {\n        name: 'externalize-deps',\n        setup(build) {\n          build.onResolve({ filter: /.*/ }, (args) => {\n            const id = args.path;\n            if (!id.startsWith('.') && !path.isAbsolute(id)) {\n              return {\n                external: true,\n              };\n            }\n          });\n        },\n      },\n      {\n        name: 'replace-import-meta',\n        setup(build) {\n          build.onLoad({ filter: /\\.[jt]s$/ }, async (args) => {\n            const contents = await fs.promises.readFile(args.path, 'utf8');\n            return {\n              loader: args.path.endsWith('.ts') ? 'ts' : 'js',\n              contents: contents\n                .replaceAll(\n                  /\\bimport\\.meta\\.url\\b/g,\n                  JSON.stringify(`file://${args.path}`),\n                )\n                .replaceAll(\n                  /\\b__dirname\\b/g,\n                  JSON.stringify(path.dirname(args.path)),\n                )\n                .replaceAll(/\\b__filename\\b/g, JSON.stringify(args.path)),\n            };\n          });\n        },\n      },\n    ],\n  });\n  const { text } = result.outputFiles[0];\n  return {\n    code: text,\n    dependencies: result.metafile ? Object.keys(result.metafile.inputs) : [],\n  };\n}\n\ninterface NodeModuleWithCompile extends NodeModule {\n  _compile(code: string, filename: string): any;\n}\n\nasync function loadFromBundledFile<File = unknown>(\n  fileName: string,\n  bundledCode: string,\n  isDefault: boolean,\n): Promise<File> {\n  const extension = path.extname(fileName);\n  const defaultLoader = require.extensions[extension]!;\n  require.extensions[extension] = (module: NodeModule, filename: string) => {\n    if (filename === fileName) {\n      (module as NodeModuleWithCompile)._compile(bundledCode, filename);\n    } else {\n      defaultLoader(module, filename);\n    }\n  };\n  // clear cache in case of server restart\n  delete require.cache[require.resolve(fileName)];\n  const raw = require(fileName);\n  const file = isDefault && raw.__esModule ? raw.default : raw;\n  require.extensions[extension] = defaultLoader;\n  return file;\n}\n\nexport async function removeFilesAndEmptyFolders(\n  patterns: string[],\n  dir: string,\n) {\n  const files = await glob(patterns, {\n    cwd: dir,\n    absolute: true,\n  });\n\n  // Remove files\n  await Promise.all(files.map((file) => fs.promises.unlink(file)));\n\n  // Find and remove empty directories\n  const directories = await glob(['**/*'], {\n    cwd: dir,\n    absolute: true,\n    onlyDirectories: true,\n  });\n\n  // Sort directories by depth (deepest first) to ensure we can remove nested empty folders\n  const sortedDirectories = directories.sort((a, b) => {\n    const depthA = a.split('/').length;\n    const depthB = b.split('/').length;\n    return depthB - depthA;\n  });\n\n  // Remove empty directories\n  for (const directory of sortedDirectories) {\n    try {\n      const contents = await fs.promises.readdir(directory);\n      if (contents.length === 0) {\n        await fs.promises.rmdir(directory);\n      }\n    } catch {\n      // Directory might have been removed already or doesn't exist\n      // Continue with next directory\n    }\n  }\n}\n","import basepath from 'node:path';\n\nimport { isUrl } from './assertion';\nimport { getExtension } from './extension';\nimport { getFileInfo } from './file';\n\n// override path to support windows paths\n// https://github.com/anodynos/upath/blob/master/source/code/upath.coffee\ntype Path = typeof basepath;\nconst path = {} as Path;\n\nconst isFunction = (val: any) => typeof val == 'function';\n\nconst isString = (val: any) => {\n  if (typeof val === 'string') {\n    return true;\n  }\n\n  if (typeof val === 'object' && val !== null) {\n    return Object.toString.call(val) == '[object String]';\n  }\n\n  return false;\n};\n\nfor (const [propName, propValue] of Object.entries(basepath)) {\n  if (isFunction(propValue)) {\n    // @ts-ignore\n    path[propName] = ((propName) => {\n      return (...args: any[]) => {\n        args = args.map((p) => {\n          return isString(p) ? toUnix(p) : p;\n        });\n\n        // @ts-ignore\n        const result = basepath[propName](...args);\n        return isString(result) ? toUnix(result) : result;\n      };\n    })(propName);\n  } else {\n    // @ts-ignore\n    path[propName] = propValue;\n  }\n}\n\nconst { join, resolve, extname, dirname, basename, isAbsolute } = path;\nexport { basename, dirname, extname, isAbsolute, join, resolve };\n\n/**\n * Behaves exactly like `path.relative(from, to)`, but keeps the first meaningful \"./\"\n */\nexport const relativeSafe = (from: string, to: string) => {\n  const normalizedRelativePath = path.relative(from, to);\n  /**\n   * Prepend \"./\" to every path and then use normalizeSafe method to normalize it\n   * normalizeSafe doesn't remove meaningful leading \"./\"\n   */\n  const relativePath = normalizeSafe(`.${separator}${normalizedRelativePath}`);\n  return relativePath;\n};\n\nexport const getSpecName = (specKey: string, target: string) => {\n  if (isUrl(specKey)) {\n    const url = new URL(target);\n    return specKey\n      .replace(url.origin, '')\n      .replace(getFileInfo(url.pathname).dirname, '')\n      .replace(`.${getExtension(specKey)}`, '');\n  }\n\n  return (\n    '/' +\n    path\n      .normalize(path.relative(getFileInfo(target).dirname, specKey))\n      .split('../')\n      .join('')\n      .replace(`.${getExtension(specKey)}`, '')\n  );\n};\n\nexport const getSchemaFileName = (path: string) => {\n  return path\n    .replace(`.${getExtension(path)}`, '')\n    .slice(path.lastIndexOf('/') + 1);\n};\n\nexport const separator = '/';\n\nconst toUnix = function (value: string) {\n  value = value.replaceAll('\\\\', '/');\n  value = value.replaceAll(/(?<!^)\\/+/g, '/'); // replace doubles except beginning for UNC path\n  return value;\n};\n\nexport const normalizeSafe = (value: string) => {\n  let result;\n  value = toUnix(value);\n  result = path.normalize(value);\n  if (\n    value.startsWith('./') &&\n    !result.startsWith('./') &&\n    !result.startsWith('..')\n  ) {\n    result = './' + result;\n  } else if (value.startsWith('//') && !result.startsWith('//')) {\n    result = value.startsWith('//./') ? '//.' + result : '/' + result;\n  }\n  return result;\n};\n\nexport const joinSafe = function (...values: string[]) {\n  let result = path.join(...values);\n\n  if (values.length > 0) {\n    const firstValue = toUnix(values[0]);\n    if (\n      firstValue.startsWith('./') &&\n      !result.startsWith('./') &&\n      !result.startsWith('..')\n    ) {\n      result = './' + result;\n    } else if (firstValue.startsWith('//') && !result.startsWith('//')) {\n      result = firstValue.startsWith('//./') ? '//.' + result : '/' + result;\n    }\n  }\n  return result;\n};\n","import type { ReferenceObject, SchemaObject } from 'openapi3-ts/oas30';\n\nimport { SchemaType, Verbs } from '../types';\nimport { extname } from './path';\n\n/**\n * Discriminator helper for `ReferenceObject`\n *\n * @param property\n */\nexport const isReference = (property: any): property is ReferenceObject => {\n  return Boolean(property?.$ref);\n};\n\nexport const isDirectory = (path: string) => {\n  return !extname(path);\n};\n\nexport function isObject(x: any): x is Record<string, unknown> {\n  return Object.prototype.toString.call(x) === '[object Object]';\n}\n\nexport function isModule(x: any): x is Record<string, unknown> {\n  return Object.prototype.toString.call(x) === '[object Module]';\n}\n\nexport function isString(x: any): x is string {\n  return typeof x === 'string';\n}\n\nexport function isNumber(x: any): x is number {\n  return typeof x === 'number';\n}\n\nexport function isNumeric(x: any): x is number {\n  return /^-?\\d+$/.test(x);\n}\n\nexport function isBoolean(x: any): x is boolean {\n  return typeof x === 'boolean';\n}\n\nexport function isFunction(x: any): x is Function {\n  return typeof x === 'function';\n}\n\nexport function isUndefined(x: any): x is undefined {\n  return x === undefined;\n}\n\nexport function isNull(x: any): x is null {\n  return x === null;\n}\n\nexport function isSchema(x: any): x is SchemaObject {\n  if (!isObject(x)) {\n    return false;\n  }\n\n  if (isString(x.type) && Object.values(SchemaType).includes(x.type)) {\n    return true;\n  }\n\n  const combine = x.allOf || x.anyOf || x.oneOf;\n  if (Array.isArray(combine)) {\n    return true;\n  }\n\n  if (isObject(x.properties)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport const isVerb = (verb: string): verb is Verbs =>\n  Object.values(Verbs).includes(verb as Verbs);\n\nexport const isRootKey = (specKey: string, target: string) => {\n  return specKey === target;\n};\n\nexport const isUrl = (str: string) => {\n  let givenURL;\n  try {\n    givenURL = new URL(str);\n  } catch {\n    return false;\n  }\n  return givenURL.protocol === 'http:' || givenURL.protocol === 'https:';\n};\n","export async function asyncReduce<IterationItem, AccValue>(\n  array: IterationItem[],\n  reducer: (\n    accumulate: AccValue,\n    current: IterationItem,\n  ) => AccValue | Promise<AccValue>,\n  initValue: AccValue,\n): Promise<AccValue> {\n  let accumulate =\n    typeof initValue === 'object'\n      ? Object.create(initValue as unknown as object)\n      : initValue;\n\n  for (const item of array) {\n    accumulate = await reducer(accumulate, item);\n  }\n\n  return accumulate;\n}\n","import { NamingConvention } from '../types';\n\nconst unicodes = function (s: string, prefix: string) {\n  prefix = prefix || '';\n  return s\n    .replaceAll(/(^|-)/g, String.raw`$1\\u` + prefix)\n    .replaceAll(',', String.raw`\\u` + prefix);\n};\n\nconst symbols = unicodes('20-26,28-2F,3A-40,5B-60,7B-7E,A0-BF,D7,F7', '00');\nconst lowers = 'a-z' + unicodes('DF-F6,F8-FF', '00');\nconst uppers = 'A-Z' + unicodes('C0-D6,D8-DE', '00');\nconst impropers = String.raw`A|An|And|As|At|But|By|En|For|If|In|Of|On|Or|The|To|Vs?\\.?|Via`;\n\nconst regexps = {\n  capitalize: new RegExp('(^|[' + symbols + '])([' + lowers + '])', 'g'),\n  pascal: new RegExp('(^|[' + symbols + '])+([' + lowers + uppers + '])', 'g'),\n  fill: new RegExp('[' + symbols + ']+(.|$)', 'g'),\n  sentence: new RegExp(\n    String.raw`(^\\s*|[\\?\\!\\.]+\"?\\s+\"?|,\\s+\")([` + lowers + '])',\n    'g',\n  ),\n  improper: new RegExp(String.raw`\\b(` + impropers + String.raw`)\\b`, 'g'),\n  relax: new RegExp(\n    '([^' +\n      uppers +\n      '])([' +\n      uppers +\n      ']*)([' +\n      uppers +\n      '])(?=[^' +\n      uppers +\n      ']|$)',\n    'g',\n  ),\n  upper: new RegExp('^[^' + lowers + ']+$'),\n  hole: /[^\\s]\\s[^\\s]/,\n  apostrophe: /'/g,\n  room: new RegExp('[' + symbols + ']'),\n};\n\nconst deapostrophe = (s: string) => {\n  return s.replace(regexps.apostrophe, '');\n};\n\nconst up = String.prototype.toUpperCase;\nconst low = String.prototype.toLowerCase;\n\nconst fill = (s: string, fillWith: string, isDeapostrophe = false) => {\n  s = s.replace(regexps.fill, function (m, next) {\n    return next ? fillWith + next : '';\n  });\n\n  if (isDeapostrophe) {\n    s = deapostrophe(s);\n  }\n  return s;\n};\n\nconst decap = (s: string, char = 0) => {\n  return low.call(s.charAt(char)) + s.slice(char + 1);\n};\n\nconst relax = (\n  m: string,\n  before: string,\n  acronym: string | undefined,\n  caps: string,\n) => {\n  return before + ' ' + (acronym ? acronym + ' ' : '') + caps;\n};\n\nconst prep = (s: string, isFill = false, isPascal = false, isUpper = false) => {\n  s = s == undefined ? '' : s + ''; // force to string\n  if (!isUpper && regexps.upper.test(s)) {\n    s = low.call(s);\n  }\n  if (!isFill && !regexps.hole.test(s)) {\n    // eslint-disable-next-line no-var\n    var holey = fill(s, ' ');\n    if (regexps.hole.test(holey)) {\n      s = holey;\n    }\n  }\n  if (!isPascal && !regexps.room.test(s)) {\n    s = s.replace(regexps.relax, relax);\n  }\n  return s;\n};\n\nconst lower = (s: string, fillWith: string, isDeapostrophe: boolean) => {\n  return fill(low.call(prep(s, !!fillWith)), fillWith, isDeapostrophe);\n};\n\n// Caches the previously converted strings to improve performance\nconst pascalMemory: Record<string, string> = {};\n\nexport const pascal = (s: string) => {\n  if (pascalMemory[s]) {\n    return pascalMemory[s];\n  }\n\n  const isStartWithUnderscore = s?.startsWith('_');\n\n  if (regexps.upper.test(s)) {\n    s = low.call(s);\n  }\n\n  const pascalString = (s?.match(/[a-zA-Z0-9\\u00C0-\\u017F]+/g) || [])\n    .map((w) => w.charAt(0).toUpperCase() + w.slice(1))\n    .join('');\n\n  const pascalWithUnderscore = isStartWithUnderscore\n    ? `_${pascalString}`\n    : pascalString;\n\n  pascalMemory[s] = pascalWithUnderscore;\n\n  return pascalWithUnderscore;\n};\n\nexport const camel = (s: string) => {\n  const isStartWithUnderscore = s?.startsWith('_');\n  const camelString = decap(pascal(s), isStartWithUnderscore ? 1 : 0);\n  return isStartWithUnderscore ? `_${camelString}` : camelString;\n};\n\nexport const snake = (s: string) => {\n  return lower(s, '_', true);\n};\n\nexport const kebab = (s: string) => {\n  return lower(s, '-', true);\n};\n\nexport const upper = (\n  s: string,\n  fillWith: string,\n  isDeapostrophe?: boolean,\n) => {\n  return fill(\n    up.call(prep(s, !!fillWith, false, true)),\n    fillWith,\n    isDeapostrophe,\n  );\n};\n\nexport const conventionName = (name: string, convention: NamingConvention) => {\n  let nameConventionTransform = camel;\n  switch (convention) {\n    case NamingConvention.PASCAL_CASE: {\n      nameConventionTransform = pascal;\n\n      break;\n    }\n    case NamingConvention.SNAKE_CASE: {\n      nameConventionTransform = snake;\n\n      break;\n    }\n    case NamingConvention.KEBAB_CASE: {\n      nameConventionTransform = kebab;\n\n      break;\n    }\n    // No default\n  }\n\n  return nameConventionTransform(name);\n};\n","import { compare, type CompareOperator } from 'compare-versions';\n\nexport const compareVersions = (\n  firstVersion: string,\n  secondVersions: string,\n  operator: CompareOperator = '>=',\n) => {\n  if (firstVersion === 'latest' || firstVersion === '*') {\n    return true;\n  }\n\n  return compare(\n    firstVersion.replace(/(\\s(.*))/, ''),\n    secondVersions,\n    operator,\n  );\n};\n","import type { ContextSpecs } from '../types';\n\nconst search = String.raw`\\*/`; // Find '*/'\nconst replacement = String.raw`*\\/`; // Replace With '*\\/'\n\nconst regex = new RegExp(search, 'g');\n\nexport function jsDoc(\n  schema: {\n    description?: string[] | string;\n    deprecated?: boolean;\n    summary?: string;\n    minLength?: number;\n    maxLength?: number;\n    minimum?: number;\n    maximum?: number;\n    exclusiveMinimum?: boolean;\n    exclusiveMaximum?: boolean;\n    minItems?: number;\n    maxItems?: number;\n    nullable?: boolean;\n    pattern?: string;\n  },\n  tryOneLine = false,\n  context?: ContextSpecs,\n): string {\n  if (context?.output?.override?.jsDoc) {\n    const { filter } = context.output.override.jsDoc;\n    if (filter) {\n      return keyValuePairsToJsDoc(filter(schema));\n    }\n  }\n  const {\n    description,\n    deprecated,\n    summary,\n    minLength,\n    maxLength,\n    minimum,\n    maximum,\n    exclusiveMinimum,\n    exclusiveMaximum,\n    minItems,\n    maxItems,\n    nullable,\n    pattern,\n  } = schema;\n  // Ensure there aren't any comment terminations in doc\n  const lines = (\n    Array.isArray(description)\n      ? description.filter((d) => !d.includes('eslint-disable'))\n      : [description || '']\n  ).map((line) => line.replaceAll(regex, replacement));\n\n  const count = [\n    description,\n    deprecated,\n    summary,\n    minLength?.toString(),\n    maxLength?.toString(),\n    minimum?.toString(),\n    maximum?.toString(),\n    exclusiveMinimum?.toString(),\n    exclusiveMaximum?.toString(),\n    minItems?.toString(),\n    maxItems?.toString(),\n    nullable?.toString(),\n    pattern,\n  ].reduce((acc, it) => (it ? acc + 1 : acc), 0);\n\n  if (!count) {\n    return '';\n  }\n\n  const oneLine = count === 1 && tryOneLine;\n  const eslintDisable = Array.isArray(description)\n    ? description\n        .find((d) => d.includes('eslint-disable'))\n        ?.replaceAll(regex, replacement)\n    : undefined;\n  let doc = `${eslintDisable ? `/* ${eslintDisable} */\\n` : ''}/**`;\n\n  if (description) {\n    if (!oneLine) {\n      doc += `\\n${tryOneLine ? '  ' : ''} *`;\n    }\n    doc += ` ${lines.join('\\n * ')}`;\n  }\n\n  function appendPrefix() {\n    if (!oneLine) {\n      doc += `\\n${tryOneLine ? '  ' : ''} *`;\n    }\n  }\n\n  function tryAppendStringDocLine(key: string, value?: string) {\n    if (value) {\n      appendPrefix();\n      doc += ` @${key} ${value.replaceAll(regex, replacement)}`;\n    }\n  }\n\n  function tryAppendBooleanDocLine(key: string, value?: boolean) {\n    if (value === true) {\n      appendPrefix();\n      doc += ` @${key}`;\n    }\n  }\n\n  function tryAppendNumberDocLine(key: string, value?: number) {\n    if (value !== undefined) {\n      appendPrefix();\n      doc += ` @${key} ${value}`;\n    }\n  }\n\n  tryAppendBooleanDocLine('deprecated', deprecated);\n  tryAppendStringDocLine('summary', summary?.replaceAll(regex, replacement));\n  tryAppendNumberDocLine('minLength', minLength);\n  tryAppendNumberDocLine('maxLength', maxLength);\n  tryAppendNumberDocLine('minimum', minimum);\n  tryAppendNumberDocLine('maximum', maximum);\n  tryAppendBooleanDocLine('exclusiveMinimum', exclusiveMinimum);\n  tryAppendBooleanDocLine('exclusiveMaximum', exclusiveMaximum);\n  tryAppendNumberDocLine('minItems', minItems);\n  tryAppendNumberDocLine('maxItems', maxItems);\n  tryAppendBooleanDocLine('nullable', nullable);\n  tryAppendStringDocLine('pattern', pattern);\n\n  doc += oneLine ? ' ' : `\\n ${tryOneLine ? '  ' : ''}`;\n\n  doc += '*/\\n';\n\n  return doc;\n}\n\nexport function keyValuePairsToJsDoc(\n  keyValues: {\n    key: string;\n    value: string;\n  }[],\n) {\n  if (keyValues.length === 0) return '';\n  let doc = '/**\\n';\n  for (const { key, value } of keyValues) {\n    doc += ` * @${key} ${value}\\n`;\n  }\n  doc += ' */\\n';\n  return doc;\n}\n","import path from 'node:path';\nimport { pathToFileURL } from 'node:url';\n\nimport { isModule, isObject, isString } from './assertion';\n\nexport const dynamicImport = async <T>(\n  toImport: T | string,\n  from = process.cwd(),\n  takeDefault = true,\n): Promise<T> => {\n  if (!toImport) {\n    return toImport as T;\n  }\n\n  try {\n    if (isString(toImport)) {\n      const filePath = path.resolve(from, toImport);\n      // use pathToFileURL to solve issue #1332.\n      // https://github.com/nodejs/node/issues/31710\n      const fileUrl = pathToFileURL(filePath);\n      const isJson = path.extname(fileUrl.href) === '.json';\n      const data = isJson\n        ? await import(fileUrl.href, { with: { type: 'json' } })\n        : await import(fileUrl.href);\n      if (takeDefault && (isObject(data) || isModule(data)) && data.default) {\n        return (data as any).default as T;\n      }\n\n      return data;\n    }\n\n    return toImport;\n  } catch (error) {\n    throw new Error(`Oups... 🍻. Path: ${toImport} => ${error}`);\n  }\n};\n","import type { ClientMockBuilder, GlobalMockOptions } from '../types';\nimport { isFunction } from './assertion';\n\nexport const getMockFileExtensionByTypeName = (\n  mock: GlobalMockOptions | ClientMockBuilder,\n) => {\n  if (isFunction(mock)) {\n    return 'msw';\n  }\n  switch (mock.type) {\n    default: {\n      // case 'msw':\n      return 'msw';\n    }\n  }\n};\n","import { VERBS_WITH_BODY } from '../constants';\nimport { Verbs } from '../types';\n\nexport const getIsBodyVerb = (verb: Verbs) => VERBS_WITH_BODY.includes(verb);\n","const isObject = (obj: unknown) => obj && typeof obj === 'object';\n\nexport function mergeDeep<\n  T extends Record<string, any>,\n  U extends Record<string, any>,\n>(source: T, target: U): T & U {\n  if (!isObject(target) || !isObject(source)) {\n    return source as T & U;\n  }\n\n  return Object.entries(target).reduce(\n    (acc, [key, value]) => {\n      const sourceValue = acc[key];\n\n      if (Array.isArray(sourceValue) && Array.isArray(value)) {\n        (acc[key] as any) = [...sourceValue, ...value];\n      } else if (isObject(sourceValue) && isObject(value)) {\n        (acc[key] as any) = mergeDeep(sourceValue, value);\n      } else {\n        (acc[key] as any) = value;\n      }\n\n      return acc;\n    },\n    Object.assign({}, source),\n  ) as T & U;\n}\n","export const count = (str = '', key: string) => {\n  if (!str) {\n    return 0;\n  }\n\n  return (str.match(new RegExp(key, 'g')) ?? []).length;\n};\n","import chalk from 'chalk';\nimport type { OpenAPIObject } from 'openapi3-ts/oas30';\nimport { type ConvertInputOptions, convertObj } from 'swagger2openapi';\n\nimport { log } from './logger';\n\nexport const openApiConverter = async (\n  schema: any,\n  options: Partial<ConvertInputOptions> = {},\n  specKey: string,\n): Promise<OpenAPIObject> => {\n  try {\n    return new Promise((resolve) => {\n      if (!schema.openapi && schema.swagger === '2.0') {\n        convertObj(schema, options, (err, value) => {\n          if (err) {\n            log(chalk.yellow(`${specKey}\\n=> ${err}`));\n            resolve(schema);\n          } else {\n            resolve(value.openapi as OpenAPIObject);\n          }\n        });\n      } else {\n        resolve(schema);\n      }\n    });\n  } catch (error) {\n    throw new Error(`Oups... 🍻.\\nPath: ${specKey}\\nParsing Error: ${error}`);\n  }\n};\n","export const sortByPriority = <T>(\n  arr: (T & { default?: boolean; required?: boolean })[],\n) =>\n  arr.sort((a, b) => {\n    if (a.default) {\n      return 1;\n    }\n\n    if (b.default) {\n      return -1;\n    }\n\n    if (a.required && b.required) {\n      return 0;\n    }\n\n    if (a.required) {\n      return -1;\n    }\n\n    if (b.required) {\n      return 1;\n    }\n    return 0;\n  });\n","import { keyword } from 'esutils';\n\nimport {\n  isBoolean,\n  isFunction,\n  isNull,\n  isNumber,\n  isString,\n  isUndefined,\n} from './assertion';\n\nexport const stringify = (\n  data?: string | any[] | Record<string, any>,\n): string | undefined => {\n  if (isUndefined(data) || isNull(data)) {\n    return;\n  }\n\n  if (isString(data)) {\n    return `'${data}'`;\n  }\n\n  if (isNumber(data) || isBoolean(data) || isFunction(data)) {\n    return `${data}`;\n  }\n\n  if (Array.isArray(data)) {\n    return `[${data.map(stringify).join(', ')}]`;\n  }\n\n  return Object.entries(data).reduce((acc, [key, value], index, arr) => {\n    const strValue = stringify(value);\n    if (arr.length === 1) {\n      return `{ ${key}: ${strValue}, }`;\n    }\n\n    if (!index) {\n      return `{ ${key}: ${strValue}, `;\n    }\n\n    if (arr.length - 1 === index) {\n      return acc + `${key}: ${strValue}, }`;\n    }\n\n    return acc + `${key}: ${strValue}, `;\n  }, '');\n};\n\nexport const sanitize = (\n  value: string,\n  options?: {\n    whitespace?: string | true;\n    underscore?: string | true;\n    dot?: string | true;\n    dash?: string | true;\n    es5keyword?: boolean;\n    es5IdentifierName?: boolean;\n    special?: boolean;\n  },\n) => {\n  const {\n    whitespace = '',\n    underscore = '',\n    dot = '',\n    dash = '',\n    es5keyword = false,\n    es5IdentifierName = false,\n    special = false,\n  } = options ?? {};\n  let newValue = value;\n\n  if (!special) {\n    newValue = newValue.replaceAll(\n      /[!\"`'#%&,:;<>=@{}~\\$\\(\\)\\*\\+\\/\\\\\\?\\[\\]\\^\\|]/g,\n      '',\n    );\n  }\n\n  if (whitespace !== true) {\n    newValue = newValue.replaceAll(/[\\s]/g, whitespace);\n  }\n\n  if (underscore !== true) {\n    newValue = newValue.replaceAll(/['_']/g, underscore);\n  }\n\n  if (dot !== true) {\n    newValue = newValue.replaceAll(/[.]/g, dot);\n  }\n\n  if (dash !== true) {\n    newValue = newValue.replaceAll(/[-]/g, dash);\n  }\n\n  if (es5keyword) {\n    newValue = keyword.isKeywordES5(newValue, true) ? `_${newValue}` : newValue;\n  }\n\n  if (es5IdentifierName) {\n    if (/^[0-9]/.test(newValue)) {\n      newValue = `N${newValue}`;\n    } else {\n      newValue = keyword.isIdentifierNameES5(newValue)\n        ? newValue\n        : `_${newValue}`;\n    }\n  }\n\n  return newValue;\n};\n\nexport const toObjectString = <T>(props: T[], path?: keyof T) => {\n  if (props.length === 0) {\n    return '';\n  }\n\n  const arrayOfString =\n    typeof path === 'string'\n      ? props.map((prop) =>\n          path\n            .split('.')\n            .reduce(\n              (obj: any, key: string) =>\n                obj && typeof obj === 'object' ? obj[key] : undefined,\n              prop,\n            ),\n        )\n      : props;\n\n  return arrayOfString.join(',\\n    ') + ',';\n};\n\nconst NUMBERS = {\n  '0': 'zero',\n  '1': 'one',\n  '2': 'two',\n  '3': 'three',\n  '4': 'four',\n  '5': 'five',\n  '6': 'six',\n  '7': 'seven',\n  '8': 'eight',\n  '9': 'nine',\n};\n\nexport const getNumberWord = (num: number) => {\n  const arrayOfNumber = num.toString().split('') as (keyof typeof NUMBERS)[];\n  return arrayOfNumber.reduce((acc, n) => acc + NUMBERS[n], '');\n};\n\nexport const escape = (str: string | null, char = \"'\") =>\n  str?.replace(char, `\\\\${char}`);\n\n/**\n * Escape all characters not included in SingleStringCharacters and\n * DoubleStringCharacters on\n * http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.4\n *\n * Based on https://github.com/joliss/js-string-escape/blob/master/index.js\n *\n * @param input String to escape\n */\nexport const jsStringEscape = (input: string) =>\n  input.replaceAll(/[\"'\\\\\\n\\r\\u2028\\u2029]/g, (character) => {\n    switch (character) {\n      case '\"':\n      case \"'\":\n      case '\\\\': {\n        return '\\\\' + character;\n      }\n      // Four possible LineTerminator characters need to be escaped:\n      case '\\n': {\n        return String.raw`\\n`;\n      }\n      case '\\r': {\n        return String.raw`\\r`;\n      }\n      case '\\u2028': {\n        return String.raw`\\u2028`;\n      }\n      case '\\u2029': {\n        return String.raw`\\u2029`;\n      }\n      default: {\n        return '';\n      }\n    }\n  });\n","import type { Tsconfig } from '../types';\n\nexport const isSyntheticDefaultImportsAllow = (config?: Tsconfig) => {\n  if (!config) {\n    return true;\n  }\n\n  return !!(\n    config?.compilerOptions?.allowSyntheticDefaultImports ??\n    config?.compilerOptions?.esModuleInterop\n  );\n};\n","// @ts-expect-error no types exists for this package :(\nimport ibmOpenapiRuleset from '@ibm-cloud/openapi-ruleset';\nimport { Spectral } from '@stoplight/spectral-core';\nimport type { OpenAPIObject } from 'openapi3-ts/oas30';\n\nimport {\n  ibmOpenapiValidatorErrors,\n  ibmOpenapiValidatorWarnings,\n} from './logger';\n\n/**\n * Validate the spec with ibm-openapi-validator (with a custom pretty logger).\n * More information: https://github.com/IBM/openapi-validator/#configuration\n * @param specs openAPI spec\n */\nexport const ibmOpenapiValidator = async (\n  specs: OpenAPIObject,\n  validation: boolean | object,\n) => {\n  const ruleset =\n    typeof validation === 'boolean' ? ibmOpenapiRuleset : validation;\n  const spectral = new Spectral();\n  spectral.setRuleset(ruleset);\n  const results = await spectral.run(\n    specs as unknown as Record<string, unknown>,\n  );\n\n  const errors: { message: string; path: string[] }[] = [];\n  const warnings: { message: string; path: string[] }[] = [];\n\n  for (const { severity, message, path } of results) {\n    const entry = { message, path: path.map((x) => x.toString()) };\n    // 0: error, 1: \"warning\", see: https://github.com/IBM/openapi-validator/blob/a93e18a156108b6b946727d0b24bbcc69095b72e/packages/validator/src/spectral/spectral-validator.js#L222\n    switch (severity) {\n      case 0: {\n        errors.push(entry);\n        break;\n      }\n      case 1: {\n        warnings.push(entry);\n        break;\n      }\n    }\n  }\n\n  if (warnings.length > 0) {\n    ibmOpenapiValidatorWarnings(warnings);\n  }\n\n  if (errors.length > 0) {\n    ibmOpenapiValidatorErrors(errors);\n    throw new Error('Spec validation failed');\n  }\n};\n","import { keyword } from 'esutils';\nimport type { SchemaObject } from 'openapi3-ts/oas30';\n\nimport { EnumGeneration, NamingConvention } from '../types';\nimport { conventionName, isNumeric, sanitize } from '../utils';\n\nexport const getEnumNames = (schemaObject: SchemaObject | undefined) => {\n  return (\n    schemaObject?.['x-enumNames'] ||\n    schemaObject?.['x-enumnames'] ||\n    schemaObject?.['x-enum-varnames']\n  );\n};\n\nexport const getEnumDescriptions = (schemaObject: SchemaObject | undefined) => {\n  return (\n    schemaObject?.['x-enumDescriptions'] ||\n    schemaObject?.['x-enumdescriptions'] ||\n    schemaObject?.['x-enum-descriptions']\n  );\n};\n\nexport const getEnum = (\n  value: string,\n  enumName: string,\n  names: string[] | undefined,\n  enumGenerationType: EnumGeneration,\n  descriptions?: string[],\n  enumNamingConvention?: NamingConvention,\n) => {\n  if (enumGenerationType === EnumGeneration.CONST)\n    return getTypeConstEnum(\n      value,\n      enumName,\n      names,\n      descriptions,\n      enumNamingConvention,\n    );\n  if (enumGenerationType === EnumGeneration.ENUM)\n    return getNativeEnum(value, enumName, names, enumNamingConvention);\n  if (enumGenerationType === EnumGeneration.UNION)\n    return getUnion(value, enumName);\n  throw new Error(`Invalid enumGenerationType: ${enumGenerationType}`);\n};\n\nconst getTypeConstEnum = (\n  value: string,\n  enumName: string,\n  names?: string[],\n  descriptions?: string[],\n  enumNamingConvention?: NamingConvention,\n) => {\n  let enumValue = `export type ${enumName} = typeof ${enumName}[keyof typeof ${enumName}]`;\n\n  if (value.endsWith(' | null')) {\n    value = value.replace(' | null', '');\n    enumValue += ' | null';\n  }\n\n  enumValue += ';\\n';\n\n  const implementation = getEnumImplementation(\n    value,\n    names,\n    descriptions,\n    enumNamingConvention,\n  );\n\n  enumValue += '\\n\\n';\n\n  enumValue += '// eslint-disable-next-line @typescript-eslint/no-redeclare\\n';\n\n  enumValue += `export const ${enumName} = {\\n${implementation}} as const;\\n`;\n\n  return enumValue;\n};\n\nexport const getEnumImplementation = (\n  value: string,\n  names?: string[],\n  descriptions?: string[],\n  enumNamingConvention?: NamingConvention,\n) => {\n  // empty enum or null-only enum\n  if (value === '') return '';\n\n  return [...new Set(value.split(' | '))].reduce((acc, val, index) => {\n    const name = names?.[index];\n    const description = descriptions?.[index];\n    const comment = description ? `  /** ${description} */\\n` : '';\n\n    if (name) {\n      return (\n        acc +\n        comment +\n        `  ${keyword.isIdentifierNameES5(name) ? name : `'${name}'`}: ${val},\\n`\n      );\n    }\n\n    let key = val.startsWith(\"'\") ? val.slice(1, -1) : val;\n\n    const isNumber = isNumeric(key);\n\n    if (isNumber) {\n      key = toNumberKey(key);\n    }\n\n    if (key.length > 1) {\n      key = sanitize(key, {\n        whitespace: '_',\n        underscore: true,\n        dash: true,\n        special: true,\n      });\n    }\n\n    if (enumNamingConvention) {\n      key = conventionName(key, enumNamingConvention);\n    }\n\n    return (\n      acc +\n      comment +\n      `  ${keyword.isIdentifierNameES5(key) ? key : `'${key}'`}: ${val},\\n`\n    );\n  }, '');\n};\n\nconst getNativeEnum = (\n  value: string,\n  enumName: string,\n  names?: string[],\n  enumNamingConvention?: NamingConvention,\n) => {\n  const enumItems = getNativeEnumItems(value, names, enumNamingConvention);\n  const enumValue = `export enum ${enumName} {\\n${enumItems}\\n}`;\n\n  return enumValue;\n};\n\nconst getNativeEnumItems = (\n  value: string,\n  names?: string[],\n  enumNamingConvention?: NamingConvention,\n) => {\n  if (value === '') return '';\n\n  return [...new Set(value.split(' | '))].reduce((acc, val, index) => {\n    const name = names?.[index];\n    if (name) {\n      return (\n        acc +\n        `  ${keyword.isIdentifierNameES5(name) ? name : `'${name}'`}= ${val},\\n`\n      );\n    }\n\n    let key = val.startsWith(\"'\") ? val.slice(1, -1) : val;\n\n    const isNumber = isNumeric(key);\n\n    if (isNumber) {\n      key = toNumberKey(key);\n    }\n\n    if (key.length > 1) {\n      key = sanitize(key, {\n        whitespace: '_',\n        underscore: true,\n        dash: true,\n        special: true,\n      });\n    }\n\n    if (enumNamingConvention) {\n      key = conventionName(key, enumNamingConvention);\n    }\n\n    return (\n      acc +\n      `  ${keyword.isIdentifierNameES5(key) ? key : `'${key}'`}= ${val},\\n`\n    );\n  }, '');\n};\n\nconst toNumberKey = (value: string) => {\n  if (value.startsWith('-')) {\n    return `NUMBER_MINUS_${value.slice(1)}`;\n  }\n  if (value.startsWith('+')) {\n    return `NUMBER_PLUS_${value.slice(1)}`;\n  }\n  return `NUMBER_${value}`;\n};\n\nconst getUnion = (value: string, enumName: string) => {\n  return `export type ${enumName} = ${value};`;\n};\n","import type { ReferenceObject } from 'openapi3-ts/oas30';\n\nimport type { ContextSpecs, NormalizedOverrideOutput } from '../types';\nimport { getFileInfo, isUrl, pascal, sanitize, upath } from '../utils';\n\ntype RefComponent = 'schemas' | 'responses' | 'parameters' | 'requestBodies';\n\nconst RefComponent = {\n  schemas: 'schemas' as RefComponent,\n  responses: 'responses' as RefComponent,\n  parameters: 'parameters' as RefComponent,\n  requestBodies: 'requestBodies' as RefComponent,\n};\n\nexport const RefComponentSuffix: Record<RefComponent, string> = {\n  schemas: '',\n  responses: 'Response',\n  parameters: 'Parameter',\n  requestBodies: 'Body',\n};\n\nconst regex = new RegExp('~1', 'g');\n\nconst resolveUrl = (from: string, to: string): string => {\n  const resolvedUrl = new URL(to, new URL(from, 'resolve://'));\n  if (resolvedUrl.protocol === 'resolve:') {\n    // `from` is a relative URL.\n    const { pathname, search, hash } = resolvedUrl;\n    return pathname + search + hash;\n  }\n  return resolvedUrl.toString();\n};\n\nexport interface RefInfo {\n  name: string;\n  originalName: string;\n  refPaths?: string[];\n  specKey?: string;\n}\n/**\n * Return the output type from the $ref\n *\n * @param $ref\n */\nexport const getRefInfo = (\n  $ref: ReferenceObject['$ref'],\n  context: ContextSpecs,\n): RefInfo => {\n  const [pathname, ref] = $ref.split('#');\n\n  const refPaths = ref\n    ?.slice(1)\n    .split('/')\n    .map((part) => decodeURIComponent(part.replaceAll(regex, '/')));\n\n  const getOverrideSuffix = (\n    override: NormalizedOverrideOutput,\n    paths: string[],\n  ) => {\n    const firstLevel = override[paths[0] as keyof NormalizedOverrideOutput];\n    if (!firstLevel) return '';\n\n    const secondLevel = (firstLevel as Record<string, { suffix?: string }>)[\n      paths[1]\n    ];\n    return secondLevel?.suffix ?? '';\n  };\n\n  const suffix = refPaths\n    ? getOverrideSuffix(context.output.override, refPaths)\n    : '';\n\n  const originalName = ref\n    ? refPaths[refPaths.length - 1]\n    : upath.getSchemaFileName(pathname);\n\n  if (!pathname) {\n    return {\n      name: sanitize(pascal(originalName) + suffix, {\n        es5keyword: true,\n        es5IdentifierName: true,\n        underscore: true,\n        dash: true,\n      }),\n      originalName,\n      refPaths,\n    };\n  }\n\n  const path = isUrl(context.specKey)\n    ? resolveUrl(context.specKey, pathname)\n    : upath.resolve(getFileInfo(context.specKey).dirname, pathname);\n\n  return {\n    name: sanitize(pascal(originalName) + suffix, {\n      es5keyword: true,\n      es5IdentifierName: true,\n      underscore: true,\n      dash: true,\n    }),\n    originalName,\n    specKey: path,\n    refPaths,\n  };\n};\n","import type {\n  ExampleObject,\n  ParameterObject,\n  ReferenceObject,\n  RequestBodyObject,\n  ResponseObject,\n  SchemaObject,\n} from 'openapi3-ts/oas30';\n\nimport { getRefInfo, type RefInfo } from '../getters/ref';\nimport type { ContextSpecs, GeneratorImport } from '../types';\nimport { isReference } from '../utils';\n\ntype ComponentObject =\n  | SchemaObject\n  | ResponseObject\n  | ParameterObject\n  | RequestBodyObject\n  | ReferenceObject;\nexport const resolveRef = <Schema extends ComponentObject = ComponentObject>(\n  schema: ComponentObject,\n  context: ContextSpecs,\n  imports: GeneratorImport[] = [],\n): {\n  schema: Schema;\n  imports: GeneratorImport[];\n} => {\n  // the schema is referring to another object\n  if ((schema as any)?.schema?.$ref) {\n    const resolvedRef = resolveRef<Schema>(\n      (schema as any)?.schema,\n      context,\n      imports,\n    );\n    if ('examples' in schema) {\n      schema.examples = resolveExampleRefs(schema.examples, context);\n    }\n    if ('examples' in resolvedRef.schema) {\n      resolvedRef.schema.examples = resolveExampleRefs(\n        resolvedRef.schema.examples,\n        context,\n      );\n    }\n    return {\n      schema: {\n        ...schema,\n        schema: resolvedRef.schema,\n      } as Schema,\n      imports,\n    };\n  }\n\n  if (!isReference(schema)) {\n    if ('examples' in schema) {\n      schema.examples = resolveExampleRefs(schema.examples, context);\n    }\n    return { schema: schema as Schema, imports };\n  }\n\n  const {\n    currentSchema,\n    refInfo: { specKey, name, originalName },\n  } = getSchema(schema, context);\n\n  if (!currentSchema) {\n    throw new Error(`Oops... 🍻. Ref not found: ${schema.$ref}`);\n  }\n\n  return resolveRef<Schema>(\n    currentSchema,\n    { ...context, specKey: specKey || context.specKey },\n    [...imports, { name, specKey, schemaName: originalName }],\n  );\n};\n\nfunction getSchema<Schema extends ComponentObject = ComponentObject>(\n  schema: ReferenceObject,\n  context: ContextSpecs,\n): {\n  refInfo: RefInfo;\n  currentSchema: Schema | undefined;\n} {\n  const refInfo = getRefInfo(schema.$ref, context);\n\n  const { specKey, refPaths } = refInfo;\n\n  let schemaByRefPaths: Schema | undefined =\n    refPaths && Array.isArray(refPaths)\n      ? refPaths.reduce(\n          (obj: any, key: string) => (obj && key in obj ? obj[key] : undefined),\n          context.specs[specKey || context.specKey],\n        )\n      : undefined;\n\n  if (!schemaByRefPaths) {\n    schemaByRefPaths = context.specs?.[\n      specKey || context.specKey\n    ] as unknown as Schema;\n  }\n\n  if (isReference(schemaByRefPaths)) {\n    return getSchema(schemaByRefPaths, context);\n  }\n  const currentSchema = schemaByRefPaths\n    ? schemaByRefPaths\n    : (context.specs[specKey || context.specKey] as unknown as Schema);\n  return {\n    currentSchema,\n    refInfo,\n  };\n}\n\ntype Example = ExampleObject | ReferenceObject;\ntype Examples = Example[] | Record<string, Example> | undefined;\nexport const resolveExampleRefs = (\n  examples: Examples,\n  context: ContextSpecs,\n): Examples => {\n  if (!examples) {\n    return undefined;\n  }\n  return Array.isArray(examples)\n    ? examples.map((example) => {\n        if (isReference(example)) {\n          const { schema } = resolveRef<ExampleObject>(example, context);\n          return schema.value;\n        }\n        return example;\n      })\n    : Object.entries(examples).reduce((acc, [key, example]) => {\n        let schema = example;\n        if (isReference(example)) {\n          schema = resolveRef<ExampleObject>(example, context).schema.value;\n        }\n        return {\n          ...acc,\n          [key]: schema,\n        };\n      }, {});\n};\n","import type { ReferenceObject, SchemaObject } from 'openapi3-ts/oas30';\n\nimport { getScalar } from '../getters';\nimport { type ContextSpecs, type ResolverValue, SchemaType } from '../types';\nimport { isReference } from '../utils';\nimport { resolveRef } from './ref';\n\nexport const resolveValue = ({\n  schema,\n  name,\n  context,\n}: {\n  schema: SchemaObject | ReferenceObject;\n  name?: string;\n  context: ContextSpecs;\n}): ResolverValue => {\n  if (isReference(schema)) {\n    const { schema: schemaObject, imports } = resolveRef<SchemaObject>(\n      schema,\n      context,\n    );\n\n    const resolvedImport = imports[0];\n\n    const importSpecKey =\n      resolvedImport.specKey ||\n      (context.specKey === context.target ? undefined : context.specKey);\n\n    let hasReadonlyProps = false;\n\n    // Avoid infinite loop\n    if (!name || !context.parents?.includes(name)) {\n      const scalar = getScalar({\n        item: schemaObject,\n        name: resolvedImport.name,\n        context: {\n          ...context,\n          specKey: importSpecKey || context.specKey,\n          ...(name ? { parents: [...(context.parents || []), name] } : {}),\n        },\n      });\n\n      hasReadonlyProps = scalar.hasReadonlyProps;\n    }\n\n    return {\n      value: resolvedImport.name,\n      imports: [\n        {\n          name: resolvedImport.name,\n          specKey: importSpecKey,\n          schemaName: resolvedImport.schemaName,\n        },\n      ],\n      type: (schemaObject?.type as SchemaType) || 'object',\n      schemas: [],\n      isEnum: !!schemaObject?.enum,\n      originalSchema: schemaObject,\n      hasReadonlyProps,\n      isRef: true,\n    };\n  }\n\n  const scalar = getScalar({ item: schema, name, context });\n\n  return {\n    ...scalar,\n    originalSchema: schema,\n    isRef: false,\n  };\n};\n","import type { ReferenceObject, SchemaObject } from 'openapi3-ts/oas30';\n\nimport { getEnum, getEnumDescriptions, getEnumNames } from '../getters/enum';\nimport type { ContextSpecs, ResolverValue } from '../types';\nimport { jsDoc } from '../utils';\nimport { resolveValue } from './value';\n\nconst resolveObjectOriginal = ({\n  schema,\n  propName,\n  combined = false,\n  context,\n}: {\n  schema: SchemaObject | ReferenceObject;\n  propName?: string;\n  combined?: boolean;\n  context: ContextSpecs;\n}): ResolverValue => {\n  const resolvedValue = resolveValue({\n    schema,\n    name: propName,\n    context,\n  });\n  const doc = jsDoc(resolvedValue.originalSchema ?? {});\n\n  if (\n    propName &&\n    !resolvedValue.isEnum &&\n    resolvedValue?.type === 'object' &&\n    new RegExp(/{|&|\\|/).test(resolvedValue.value)\n  ) {\n    let model = '';\n    const isConstant = 'const' in schema;\n    const constantIsString =\n      'type' in schema &&\n      (schema.type === 'string' ||\n        (Array.isArray(schema.type) && schema.type.includes('string')));\n\n    model += isConstant\n      ? `${doc}export const ${propName} = ${constantIsString ? `'${schema.const}'` : schema.const} as const;\\n`\n      : `${doc}export type ${propName} = ${resolvedValue.value};\\n`;\n\n    return {\n      value: propName,\n      imports: [{ name: propName, isConstant }],\n      schemas: [\n        ...resolvedValue.schemas,\n        {\n          name: propName,\n          model,\n          imports: resolvedValue.imports,\n        },\n      ],\n      isEnum: false,\n      type: 'object',\n      originalSchema: resolvedValue.originalSchema,\n      isRef: resolvedValue.isRef,\n      hasReadonlyProps: resolvedValue.hasReadonlyProps,\n    };\n  }\n\n  if (propName && resolvedValue.isEnum && !combined && !resolvedValue.isRef) {\n    const enumValue = getEnum(\n      resolvedValue.value,\n      propName,\n      getEnumNames(resolvedValue.originalSchema),\n      context.output.override.enumGenerationType,\n      getEnumDescriptions(resolvedValue.originalSchema),\n      context.output.override.namingConvention?.enum,\n    );\n\n    return {\n      value: propName,\n      imports: [{ name: propName }],\n      schemas: [\n        ...resolvedValue.schemas,\n        {\n          name: propName,\n          model: doc + enumValue,\n          imports: resolvedValue.imports,\n        },\n      ],\n      isEnum: false,\n      type: 'enum',\n      originalSchema: resolvedValue.originalSchema,\n      isRef: resolvedValue.isRef,\n      hasReadonlyProps: resolvedValue.hasReadonlyProps,\n    };\n  }\n\n  return resolvedValue;\n};\n\nconst resolveObjectCacheMap = new Map<string, ResolverValue>();\n\nexport const resolveObject = ({\n  schema,\n  propName,\n  combined = false,\n  context,\n}: {\n  schema: SchemaObject | ReferenceObject;\n  propName?: string;\n  combined?: boolean;\n  context: ContextSpecs;\n}): ResolverValue => {\n  const hashKey = JSON.stringify({\n    schema,\n    propName,\n    combined,\n    specKey: context.specKey,\n  });\n\n  if (resolveObjectCacheMap.has(hashKey)) {\n    return resolveObjectCacheMap.get(hashKey)!;\n  }\n\n  const result = resolveObjectOriginal({\n    schema,\n    propName,\n    combined,\n    context,\n  });\n\n  resolveObjectCacheMap.set(hashKey, result);\n\n  return result;\n};\n","import type { ReferenceObject, SchemaObject } from 'openapi3-ts/oas30';\nimport type { SchemaObject as SchemaObject31 } from 'openapi3-ts/oas31';\n\nimport { resolveExampleRefs } from '../resolvers';\nimport { resolveObject } from '../resolvers/object';\nimport type { ContextSpecs, ScalarValue } from '../types';\nimport { compareVersions } from '../utils';\n\n/**\n * Return the output type from an array\n *\n * @param item item with type === \"array\"\n */\nexport const getArray = ({\n  schema,\n  name,\n  context,\n}: {\n  schema: SchemaObject;\n  name?: string;\n  context: ContextSpecs;\n}): ScalarValue => {\n  const schema31 = schema as SchemaObject31;\n  if (schema31.prefixItems) {\n    const resolvedObjects = schema31.prefixItems.map((item, index) =>\n      resolveObject({\n        schema: item as SchemaObject | ReferenceObject,\n        propName:\n          name + context.output.override.components.schemas.itemSuffix + index,\n        context,\n      }),\n    );\n    if (schema31.items) {\n      const additional = resolveObject({\n        schema: schema31.items as SchemaObject | ReferenceObject,\n        propName:\n          name +\n          context.output.override.components.schemas.itemSuffix +\n          'Additional',\n        context,\n      });\n      resolvedObjects.push({\n        ...additional,\n        value: `...${additional.value}[]`,\n      });\n    }\n    return {\n      type: 'array',\n      isEnum: false,\n      isRef: false,\n      value: `[${resolvedObjects.map((o) => o.value).join(', ')}]`,\n      imports: resolvedObjects.flatMap((o) => o.imports),\n      schemas: resolvedObjects.flatMap((o) => o.schemas),\n      hasReadonlyProps: resolvedObjects.some((o) => o.hasReadonlyProps),\n      example: schema.example,\n      examples: resolveExampleRefs(schema.examples, context),\n    };\n  }\n  if (schema.items) {\n    const resolvedObject = resolveObject({\n      schema: schema.items,\n      propName: name + context.output.override.components.schemas.itemSuffix,\n      context,\n    });\n    return {\n      value: `${\n        schema.readOnly === true &&\n        !context.output.override.suppressReadonlyModifier\n          ? 'readonly '\n          : ''\n      }${\n        resolvedObject.value.includes('|')\n          ? `(${resolvedObject.value})[]`\n          : `${resolvedObject.value}[]`\n      }`,\n      imports: resolvedObject.imports,\n      schemas: resolvedObject.schemas,\n      isEnum: false,\n      type: 'array',\n      isRef: false,\n      hasReadonlyProps: resolvedObject.hasReadonlyProps,\n      example: schema.example,\n      examples: resolveExampleRefs(schema.examples, context),\n    };\n  } else if (\n    compareVersions(context.specs[context.specKey].openapi, '3.1', '>=')\n  ) {\n    return {\n      value: 'unknown[]',\n      imports: [],\n      schemas: [],\n      isEnum: false,\n      type: 'array',\n      isRef: false,\n      hasReadonlyProps: false,\n    };\n  } else {\n    throw new Error(\n      `All arrays must have an \\`items\\` key defined (name=${name}, schema=${JSON.stringify(schema)})`,\n    );\n  }\n};\n","import { keyword } from 'esutils';\nimport type { ValueIteratee } from 'lodash';\nimport uniqBy from 'lodash.uniqby';\nimport type {\n  MediaTypeObject,\n  ReferenceObject,\n  RequestBodyObject,\n  ResponseObject,\n  SchemaObject,\n} from 'openapi3-ts/oas30';\n\nimport { resolveObject } from '../resolvers/object';\nimport { resolveExampleRefs, resolveRef } from '../resolvers/ref';\nimport {\n  type ContextSpecs,\n  FormDataArrayHandling,\n  type GeneratorImport,\n  type ResReqTypesValue,\n} from '../types';\nimport { camel } from '../utils';\nimport { isReference } from '../utils/assertion';\nimport { pascal } from '../utils/case';\nimport { getNumberWord } from '../utils/string';\n\nconst formDataContentTypes = new Set(['multipart/form-data']);\n\nconst formUrlEncodedContentTypes = new Set([\n  'application/x-www-form-urlencoded',\n]);\n\nconst getResReqContentTypes = ({\n  mediaType,\n  propName,\n  context,\n}: {\n  mediaType: MediaTypeObject;\n  propName?: string;\n  context: ContextSpecs;\n}) => {\n  if (!mediaType.schema) {\n    return;\n  }\n\n  const resolvedObject = resolveObject({\n    schema: mediaType.schema,\n    propName,\n    context,\n  });\n\n  return resolvedObject;\n};\n\nexport const getResReqTypes = (\n  responsesOrRequests: [\n    string,\n    ResponseObject | ReferenceObject | RequestBodyObject,\n  ][],\n  name: string,\n  context: ContextSpecs,\n  defaultType = 'unknown',\n  uniqueKey: ValueIteratee<ResReqTypesValue> = 'value',\n): ResReqTypesValue[] => {\n  const typesArray = responsesOrRequests\n    .filter(([_, res]) => Boolean(res))\n    .map(([key, res]) => {\n      if (isReference(res)) {\n        const {\n          schema: bodySchema,\n          imports: [{ name, specKey, schemaName }],\n        } = resolveRef<RequestBodyObject | ResponseObject>(res, context);\n\n        const [contentType, mediaType] =\n          Object.entries(bodySchema.content ?? {})[0] ?? [];\n\n        const isFormData = formDataContentTypes.has(contentType);\n        const isFormUrlEncoded = formUrlEncodedContentTypes.has(contentType);\n\n        if ((!isFormData && !isFormUrlEncoded) || !mediaType?.schema) {\n          return [\n            {\n              value: name,\n              imports: [{ name, specKey, schemaName }],\n              schemas: [],\n              type: 'unknown',\n              isEnum: false,\n              isRef: true,\n              hasReadonlyProps: false,\n              originalSchema: mediaType?.schema,\n              example: mediaType?.example,\n              examples: resolveExampleRefs(mediaType?.examples, context),\n              key,\n              contentType,\n            },\n          ] as ResReqTypesValue[];\n        }\n\n        const formData = isFormData\n          ? getSchemaFormDataAndUrlEncoded({\n              name,\n              schemaObject: mediaType?.schema,\n              context: {\n                ...context,\n                specKey: specKey || context.specKey,\n              },\n              isRequestBodyOptional:\n                // Even though required is false by default, we only consider required to be false if specified. (See pull 1277)\n                'required' in bodySchema && bodySchema.required === false,\n              isRef: true,\n            })\n          : undefined;\n\n        const formUrlEncoded = isFormUrlEncoded\n          ? getSchemaFormDataAndUrlEncoded({\n              name,\n              schemaObject: mediaType?.schema,\n              context: {\n                ...context,\n                specKey: specKey || context.specKey,\n              },\n              isRequestBodyOptional:\n                'required' in bodySchema && bodySchema.required === false,\n              isUrlEncoded: true,\n              isRef: true,\n            })\n          : undefined;\n\n        const additionalImports = getFormDataAdditionalImports({\n          schemaObject: mediaType?.schema,\n          context: {\n            ...context,\n            specKey: specKey || context.specKey,\n          },\n        });\n\n        return [\n          {\n            value: name,\n            imports: [{ name, specKey, schemaName }, ...additionalImports],\n            schemas: [],\n            type: 'unknown',\n            isEnum: false,\n            hasReadonlyProps: false,\n            formData,\n            formUrlEncoded,\n            isRef: true,\n            originalSchema: mediaType?.schema,\n            example: mediaType.example,\n            examples: resolveExampleRefs(mediaType.examples, context),\n            key,\n            contentType,\n          },\n        ] as ResReqTypesValue[];\n      }\n\n      if (res.content) {\n        const contents = Object.entries(res.content).map(\n          ([contentType, mediaType], index, arr) => {\n            let propName = key ? pascal(name) + pascal(key) : undefined;\n\n            if (propName && arr.length > 1) {\n              propName = propName + pascal(getNumberWord(index + 1));\n            }\n\n            const resolvedValue = getResReqContentTypes({\n              mediaType,\n              propName,\n              context,\n            });\n\n            if (!resolvedValue) {\n              return;\n            }\n\n            const isFormData = formDataContentTypes.has(contentType);\n            const isFormUrlEncoded =\n              formUrlEncodedContentTypes.has(contentType);\n\n            if ((!isFormData && !isFormUrlEncoded) || !propName) {\n              return {\n                ...resolvedValue,\n                imports: resolvedValue.imports,\n                contentType,\n                example: mediaType.example,\n                examples: resolveExampleRefs(mediaType.examples, context),\n              };\n            }\n\n            const formData = isFormData\n              ? getSchemaFormDataAndUrlEncoded({\n                  name: propName,\n                  schemaObject: mediaType.schema!,\n                  context,\n                  isRequestBodyOptional:\n                    'required' in res && res.required === false,\n                })\n              : undefined;\n\n            const formUrlEncoded = isFormUrlEncoded\n              ? getSchemaFormDataAndUrlEncoded({\n                  name: propName,\n                  schemaObject: mediaType.schema!,\n                  context,\n                  isUrlEncoded: true,\n                  isRequestBodyOptional:\n                    'required' in res && res.required === false,\n                })\n              : undefined;\n\n            const additionalImports = getFormDataAdditionalImports({\n              schemaObject: mediaType.schema!,\n              context,\n            });\n            return {\n              ...resolvedValue,\n              imports: [...resolvedValue.imports, ...additionalImports],\n              formData,\n              formUrlEncoded,\n              contentType,\n              example: mediaType.example,\n              examples: resolveExampleRefs(mediaType.examples, context),\n            };\n          },\n        );\n\n        return contents\n          .filter(Boolean)\n          .map((x) => ({ ...x, key })) as ResReqTypesValue[];\n      }\n\n      return [\n        {\n          value: defaultType,\n          imports: [],\n          schemas: [],\n          type: defaultType,\n          isEnum: false,\n          key,\n          isRef: false,\n          hasReadonlyProps: false,\n          contentType: 'application/json',\n        },\n      ] as ResReqTypesValue[];\n    });\n\n  return uniqBy(typesArray.flat(), uniqueKey);\n};\n\nconst getFormDataAdditionalImports = ({\n  schemaObject,\n  context,\n}: {\n  schemaObject: SchemaObject | ReferenceObject;\n  context: ContextSpecs;\n}): GeneratorImport[] => {\n  const { schema } = resolveRef<SchemaObject>(schemaObject, context);\n\n  if (schema.type !== 'object') {\n    return [];\n  }\n\n  const combinedSchemas = schema.oneOf || schema.anyOf;\n\n  if (!combinedSchemas) {\n    return [];\n  }\n\n  return combinedSchemas\n    .map((schema) => resolveRef<SchemaObject>(schema, context).imports[0])\n    .filter(Boolean);\n};\n\nconst getSchemaFormDataAndUrlEncoded = ({\n  name,\n  schemaObject,\n  context,\n  isRequestBodyOptional,\n  isUrlEncoded,\n  isRef,\n}: {\n  name: string;\n  schemaObject: SchemaObject | ReferenceObject;\n  context: ContextSpecs;\n  isRequestBodyOptional: boolean;\n  isUrlEncoded?: boolean;\n  isRef?: boolean;\n}): string => {\n  const { schema, imports } = resolveRef<SchemaObject>(schemaObject, context);\n  const propName = camel(\n    !isRef && isReference(schemaObject) ? imports[0].name : name,\n  );\n  const additionalImports: GeneratorImport[] = [];\n\n  const variableName = isUrlEncoded ? 'formUrlEncoded' : 'formData';\n  let form = isUrlEncoded\n    ? `const ${variableName} = new URLSearchParams();\\n`\n    : `const ${variableName} = new FormData();\\n`;\n\n  const combinedSchemas = schema.oneOf || schema.anyOf || schema.allOf;\n  if (\n    schema.type === 'object' ||\n    (schema.type === undefined && combinedSchemas)\n  ) {\n    if (combinedSchemas) {\n      const shouldCast = !!schema.oneOf || !!schema.anyOf;\n\n      const combinedSchemasFormData = combinedSchemas!\n        .map((schema) => {\n          const { schema: combinedSchema, imports } = resolveRef<SchemaObject>(\n            schema,\n            context,\n          );\n\n          let newPropName = propName;\n          let newPropDefinition = '';\n\n          // If the schema is a union type (oneOf, anyOf) and includes a reference (has imports),\n          // we need to cast the property to the specific type to avoid TypeScript errors.\n          if (shouldCast && imports[0]) {\n            additionalImports.push(imports[0]);\n            newPropName = `${propName}${pascal(imports[0].name)}`;\n            newPropDefinition = `const ${newPropName} = (${propName} as ${imports[0].name}${isRequestBodyOptional ? ' | undefined' : ''});\\n`;\n          }\n\n          return (\n            newPropDefinition +\n            resolveSchemaPropertiesToFormData({\n              schema: combinedSchema,\n              variableName,\n              propName: newPropName,\n              context,\n              isRequestBodyOptional,\n            })\n          );\n        })\n        .filter(Boolean)\n        .join('\\n');\n\n      form += combinedSchemasFormData;\n    }\n\n    if (schema.properties) {\n      const formDataValues = resolveSchemaPropertiesToFormData({\n        schema,\n        variableName,\n        propName,\n        context,\n        isRequestBodyOptional,\n      });\n\n      form += formDataValues;\n    }\n\n    return form;\n  }\n\n  if (schema.type === 'array') {\n    let valueStr = 'value';\n    if (schema.items) {\n      const { schema: itemSchema } = resolveRef<SchemaObject>(\n        schema.items,\n        context,\n      );\n      if (itemSchema.type === 'object' || itemSchema.type === 'array') {\n        valueStr = 'JSON.stringify(value)';\n      } else if (\n        itemSchema.type === 'number' ||\n        itemSchema.type === 'integer' ||\n        itemSchema.type === 'boolean'\n      ) {\n        valueStr = 'value.toString()';\n      }\n    }\n\n    return `${form}${propName}.forEach(value => ${variableName}.append('data', ${valueStr}))\\n`;\n  }\n\n  if (\n    schema.type === 'number' ||\n    schema.type === 'integer' ||\n    schema.type === 'boolean'\n  ) {\n    return `${form}${variableName}.append('data', ${propName}.toString())\\n`;\n  }\n\n  return `${form}${variableName}.append('data', ${propName})\\n`;\n};\n\nconst resolveSchemaPropertiesToFormData = ({\n  schema,\n  variableName,\n  propName,\n  context,\n  isRequestBodyOptional,\n  keyPrefix = '',\n  depth = 0,\n}: {\n  schema: SchemaObject;\n  variableName: string;\n  propName: string;\n  context: ContextSpecs;\n  isRequestBodyOptional: boolean;\n  keyPrefix?: string;\n  depth?: number;\n}) => {\n  const formDataValues = Object.entries(schema.properties ?? {}).reduce(\n    (acc, [key, value]) => {\n      const { schema: property } = resolveRef<SchemaObject>(value, context);\n\n      // Skip readOnly properties for formData\n      if (property.readOnly) {\n        return acc;\n      }\n\n      let formDataValue = '';\n\n      const formattedKeyPrefix = isRequestBodyOptional\n        ? keyword.isIdentifierNameES5(key)\n          ? '?'\n          : '?.'\n        : '';\n      const formattedKey = keyword.isIdentifierNameES5(key)\n        ? `.${key}`\n        : `['${key}']`;\n\n      const valueKey = `${propName}${formattedKeyPrefix}${formattedKey}`;\n      const nonOptionalValueKey = `${propName}${formattedKey}`;\n\n      if (property.type === 'object') {\n        formDataValue =\n          context.output.override.formData.arrayHandling ===\n          FormDataArrayHandling.EXPLODE\n            ? resolveSchemaPropertiesToFormData({\n                schema: property,\n                variableName,\n                propName: nonOptionalValueKey,\n                context,\n                isRequestBodyOptional,\n                keyPrefix: `${keyPrefix}${key}.`,\n                depth: depth + 1,\n              })\n            : `${variableName}.append(\\`${keyPrefix}${key}\\`, JSON.stringify(${nonOptionalValueKey}));\\n`;\n      } else if (property.type === 'array') {\n        let valueStr = 'value';\n        let hasNonPrimitiveChild = false;\n        if (property.items) {\n          const { schema: itemSchema } = resolveRef<SchemaObject>(\n            property.items,\n            context,\n          );\n          if (itemSchema.type === 'object' || itemSchema.type === 'array') {\n            if (\n              context.output.override.formData.arrayHandling ===\n              FormDataArrayHandling.EXPLODE\n            ) {\n              hasNonPrimitiveChild = true;\n              const resolvedValue = resolveSchemaPropertiesToFormData({\n                schema: itemSchema,\n                variableName,\n                propName: 'value',\n                context,\n                isRequestBodyOptional,\n                keyPrefix: `${keyPrefix}${key}[\\${index${depth > 0 ? depth : ''}}].`,\n                depth: depth + 1,\n              });\n              formDataValue = `${valueKey}.forEach((value, index${depth > 0 ? depth : ''}) => {\n    ${resolvedValue}});\\n`;\n            } else {\n              valueStr = 'JSON.stringify(value)';\n            }\n          } else if (\n            itemSchema.type === 'number' ||\n            itemSchema.type?.includes('number') ||\n            itemSchema.type === 'integer' ||\n            itemSchema.type?.includes('integer') ||\n            itemSchema.type === 'boolean' ||\n            itemSchema.type?.includes('boolean')\n          ) {\n            valueStr = 'value.toString()';\n          }\n        }\n        if (\n          context.output.override.formData.arrayHandling ===\n          FormDataArrayHandling.EXPLODE\n        ) {\n          if (!hasNonPrimitiveChild) {\n            formDataValue = `${valueKey}.forEach((value, index${depth > 0 ? depth : ''}) => ${variableName}.append(\\`${keyPrefix}${key}[\\${index${depth > 0 ? depth : ''}}]\\`, ${valueStr}));\\n`;\n          }\n        } else {\n          formDataValue = `${valueKey}.forEach(value => ${variableName}.append(\\`${keyPrefix}${key}${context.output.override.formData.arrayHandling === FormDataArrayHandling.SERIALIZE_WITH_BRACKETS ? '[]' : ''}\\`, ${valueStr}));\\n`;\n        }\n      } else if (\n        property.type === 'number' ||\n        property.type?.includes('number') ||\n        property.type === 'integer' ||\n        property.type?.includes('integer') ||\n        property.type === 'boolean' ||\n        property.type?.includes('boolean')\n      ) {\n        formDataValue = `${variableName}.append(\\`${keyPrefix}${key}\\`, ${nonOptionalValueKey}.toString())\\n`;\n      } else {\n        formDataValue = `${variableName}.append(\\`${keyPrefix}${key}\\`, ${nonOptionalValueKey})\\n`;\n      }\n\n      let existSubSchemaNullable = false;\n      if (property.allOf || property.anyOf || property.oneOf) {\n        const combine = property.allOf || property.anyOf || property.oneOf;\n        const subSchemas = combine?.map((c) =>\n          resolveObject({ schema: c, combined: true, context: context }),\n        );\n        if (\n          subSchemas?.some((subSchema) => {\n            return ['number', 'integer', 'boolean'].includes(subSchema.type);\n          })\n        ) {\n          formDataValue = `${variableName}.append(\\`${key}\\`, ${nonOptionalValueKey}.toString())\\n`;\n        }\n\n        if (\n          subSchemas?.some((subSchema) => {\n            return subSchema.type === 'null';\n          })\n        ) {\n          existSubSchemaNullable = true;\n        }\n      }\n\n      const isRequired =\n        schema.required?.includes(key) && !isRequestBodyOptional;\n\n      if (\n        property.nullable ||\n        property.type?.includes('null') ||\n        existSubSchemaNullable\n      ) {\n        if (isRequired) {\n          return acc + `if(${valueKey} !== null) {\\n ${formDataValue} }\\n`;\n        }\n\n        return (\n          acc +\n          `if(${valueKey} !== undefined && ${nonOptionalValueKey} !== null) {\\n ${formDataValue} }\\n`\n        );\n      }\n\n      if (isRequired) {\n        return acc + formDataValue;\n      }\n\n      return acc + `if(${valueKey} !== undefined) {\\n ${formDataValue} }\\n`;\n    },\n    '',\n  );\n\n  return formDataValues;\n};\n","import type { ReferenceObject, RequestBodyObject } from 'openapi3-ts/oas30';\n\nimport { generalJSTypesWithArray } from '../constants';\nimport { resolveRef } from '../resolvers';\nimport type {\n  ContextSpecs,\n  GetterBody,\n  OverrideOutputContentType,\n} from '../types';\nimport { camel, isReference, sanitize } from '../utils';\nimport { getResReqTypes } from './res-req-types';\n\nexport const getBody = ({\n  requestBody,\n  operationName,\n  context,\n  contentType,\n}: {\n  requestBody: ReferenceObject | RequestBodyObject;\n  operationName: string;\n  context: ContextSpecs;\n  contentType?: OverrideOutputContentType;\n}): GetterBody => {\n  const allBodyTypes = getResReqTypes(\n    [[context.output.override.components.requestBodies.suffix, requestBody]],\n    operationName,\n    context,\n  );\n\n  const filteredBodyTypes = contentType\n    ? allBodyTypes.filter((type) => {\n        let include = true;\n        let exclude = false;\n\n        if (contentType.include) {\n          include = contentType.include.includes(type.contentType);\n        }\n\n        if (contentType.exclude) {\n          exclude = contentType.exclude.includes(type.contentType);\n        }\n\n        return include && !exclude;\n      })\n    : allBodyTypes;\n\n  const imports = filteredBodyTypes.flatMap(({ imports }) => imports);\n  const schemas = filteredBodyTypes.flatMap(({ schemas }) => schemas);\n\n  const definition = filteredBodyTypes.map(({ value }) => value).join(' | ');\n  const hasReadonlyProps = filteredBodyTypes.some((x) => x.hasReadonlyProps);\n  const nonReadonlyDefinition =\n    hasReadonlyProps && definition ? `NonReadonly<${definition}>` : definition;\n\n  let implementation =\n    generalJSTypesWithArray.includes(definition.toLowerCase()) ||\n    filteredBodyTypes.length > 1\n      ? camel(operationName) +\n        context.output.override.components.requestBodies.suffix\n      : camel(definition);\n\n  let isOptional = false;\n  if (implementation) {\n    implementation = sanitize(implementation, {\n      underscore: '_',\n      whitespace: '_',\n      dash: true,\n      es5keyword: true,\n      es5IdentifierName: true,\n    });\n    if (isReference(requestBody)) {\n      const { schema: bodySchema } = resolveRef<RequestBodyObject>(\n        requestBody,\n        context,\n      );\n      if (bodySchema.required !== undefined) {\n        isOptional = !bodySchema.required;\n      }\n    } else if (requestBody.required !== undefined) {\n      isOptional = !requestBody.required;\n    }\n  }\n\n  return {\n    originalSchema: requestBody,\n    definition: nonReadonlyDefinition,\n    implementation,\n    imports,\n    schemas,\n    isOptional,\n    ...(filteredBodyTypes.length === 1\n      ? {\n          formData: filteredBodyTypes[0].formData,\n          formUrlEncoded: filteredBodyTypes[0].formUrlEncoded,\n          contentType: filteredBodyTypes[0].contentType,\n        }\n      : {\n          formData: '',\n          formUrlEncoded: '',\n          contentType: '',\n        }),\n  };\n};\n","import type { ContextSpecs, GeneratorImport, ResolverValue } from '../types';\nimport { pascal } from '../utils';\nimport { getSpecName } from '../utils/path';\n\nexport const getAliasedImports = ({\n  name,\n  resolvedValue,\n  existingImports,\n  context,\n}: {\n  name?: string;\n  resolvedValue: ResolverValue;\n  existingImports: GeneratorImport[];\n  context: ContextSpecs;\n}): GeneratorImport[] =>\n  context.output.schemas && resolvedValue.isRef\n    ? resolvedValue.imports.map((imp) => {\n        if (\n          !needCreateImportAlias({\n            name,\n            imp,\n            existingImports,\n          })\n        ) {\n          return imp;\n        }\n\n        const specName = pascal(\n          getSpecName(imp.specKey ?? '', context.specKey),\n        );\n\n        // for spec starts from digit\n        const normalizedSpecName = /^\\d/.test(specName)\n          ? `__${specName}`\n          : specName;\n\n        return {\n          ...imp,\n          alias: `${normalizedSpecName}__${imp.name}`,\n        };\n      })\n    : resolvedValue.imports;\n\nexport const needCreateImportAlias = ({\n  existingImports,\n  imp,\n  name,\n}: {\n  name?: string;\n  imp: GeneratorImport;\n  existingImports: GeneratorImport[];\n}): boolean =>\n  !imp.alias &&\n  // !!imp.specKey &&\n  (imp.name === name ||\n    existingImports.some(\n      (existingImport) =>\n        imp.name === existingImport.name &&\n        imp.specKey !== existingImport.specKey,\n    ));\n\nexport const getImportAliasForRefOrValue = ({\n  context,\n  imports,\n  resolvedValue,\n}: {\n  resolvedValue: ResolverValue;\n  imports: GeneratorImport[];\n  context: ContextSpecs;\n}): string => {\n  if (!context.output.schemas || !resolvedValue.isRef) {\n    return resolvedValue.value;\n  }\n  const importWithSameName = imports.find(\n    (imp) => imp.name === resolvedValue.value,\n  );\n  return importWithSameName?.alias ?? resolvedValue.value;\n};\n","import { keyword } from 'esutils';\n\nexport const getKey = (key: string) => {\n  return keyword.isIdentifierNameES5(key) ? key : `'${key}'`;\n};\n","import type { ReferenceObject, SchemaObject } from 'openapi3-ts/oas30';\n\nimport { resolveExampleRefs, resolveValue } from '../resolvers';\nimport { resolveObject } from '../resolvers/object';\nimport {\n  type ContextSpecs,\n  PropertySortOrder,\n  type ScalarValue,\n  SchemaType,\n  type SchemaWithConst,\n} from '../types';\nimport { isBoolean, isReference, jsDoc, pascal } from '../utils';\nimport { combineSchemas } from './combine';\nimport { getAliasedImports, getImportAliasForRefOrValue } from './imports';\nimport { getKey } from './keys';\nimport { getRefInfo } from './ref';\n\n/**\n * Return the output type from an object\n *\n * @param item item with type === \"object\"\n */\nexport const getObject = ({\n  item,\n  name,\n  context,\n  nullable,\n}: {\n  item: SchemaObject;\n  name?: string;\n  context: ContextSpecs;\n  nullable: string;\n}): ScalarValue => {\n  if (isReference(item)) {\n    const { name, specKey } = getRefInfo(item.$ref, context);\n    return {\n      value: name + nullable,\n      imports: [{ name, specKey }],\n      schemas: [],\n      isEnum: false,\n      type: 'object',\n      isRef: true,\n      hasReadonlyProps: item.readOnly || false,\n      example: item.example,\n      examples: resolveExampleRefs(item.examples, context),\n    };\n  }\n\n  if (item.allOf || item.oneOf || item.anyOf) {\n    const separator = item.allOf ? 'allOf' : item.oneOf ? 'oneOf' : 'anyOf';\n\n    return combineSchemas({\n      schema: item,\n      name,\n      separator,\n      context,\n      nullable,\n    });\n  }\n\n  if (Array.isArray(item.type)) {\n    return combineSchemas({\n      schema: {\n        anyOf: item.type.map((type) => ({\n          ...item,\n          type,\n        })),\n      },\n      name,\n      separator: 'anyOf',\n      context,\n      nullable,\n    });\n  }\n\n  if (item.properties && Object.entries(item.properties).length > 0) {\n    const entries = Object.entries(item.properties);\n    if (context.output.propertySortOrder === PropertySortOrder.ALPHABETICAL) {\n      entries.sort((a, b) => {\n        return a[0].localeCompare(b[0]);\n      });\n    }\n    return entries.reduce(\n      (\n        acc,\n        [key, schema]: [string, ReferenceObject | SchemaObject],\n        index,\n        arr,\n      ) => {\n        const isRequired = (\n          Array.isArray(item.required) ? item.required : []\n        ).includes(key);\n\n        let propName = '';\n\n        if (name) {\n          const isKeyStartWithUnderscore = key.startsWith('_');\n\n          propName += pascal(\n            `${isKeyStartWithUnderscore ? '_' : ''}${name}_${key}`,\n          );\n        }\n\n        const allSpecSchemas =\n          context.specs[context.target]?.components?.schemas ?? {};\n\n        const isNameAlreadyTaken = Object.keys(allSpecSchemas).some(\n          (schemaName) => pascal(schemaName) === propName,\n        );\n\n        if (isNameAlreadyTaken) {\n          propName = propName + 'Property';\n        }\n\n        const resolvedValue = resolveObject({\n          schema,\n          propName,\n          context,\n        });\n\n        const isReadOnly = item.readOnly || (schema as SchemaObject).readOnly;\n        if (!index) {\n          acc.value += '{';\n        }\n\n        const doc = jsDoc(schema as SchemaObject, true, context);\n\n        acc.hasReadonlyProps ||= isReadOnly || false;\n\n        const aliasedImports = getAliasedImports({\n          name,\n          context,\n          resolvedValue,\n          existingImports: acc.imports,\n        });\n\n        acc.imports.push(...aliasedImports);\n\n        const propValue = getImportAliasForRefOrValue({\n          context,\n          resolvedValue,\n          imports: aliasedImports,\n        });\n\n        acc.value += `\\n  ${doc ? `${doc}  ` : ''}${\n          isReadOnly && !context.output.override.suppressReadonlyModifier\n            ? 'readonly '\n            : ''\n        }${getKey(key)}${isRequired ? '' : '?'}: ${propValue};`;\n        acc.schemas.push(...resolvedValue.schemas);\n\n        if (arr.length - 1 === index) {\n          if (item.additionalProperties) {\n            if (isBoolean(item.additionalProperties)) {\n              acc.value += `\\n  [key: string]: unknown;\\n }`;\n            } else {\n              const resolvedValue = resolveValue({\n                schema: item.additionalProperties,\n                name,\n                context,\n              });\n              acc.value += `\\n  [key: string]: ${resolvedValue.value};\\n}`;\n            }\n          } else {\n            acc.value += '\\n}';\n          }\n\n          acc.value += nullable;\n        }\n\n        return acc;\n      },\n      {\n        imports: [],\n        schemas: [],\n        value: '',\n        isEnum: false,\n        type: 'object' as SchemaType,\n        isRef: false,\n        schema: {},\n        hasReadonlyProps: false,\n        example: item.example,\n        examples: resolveExampleRefs(item.examples, context),\n      } as ScalarValue,\n    );\n  }\n\n  if (item.additionalProperties) {\n    if (isBoolean(item.additionalProperties)) {\n      return {\n        value: `{ [key: string]: unknown }` + nullable,\n        imports: [],\n        schemas: [],\n        isEnum: false,\n        type: 'object',\n        isRef: false,\n        hasReadonlyProps: item.readOnly || false,\n      };\n    }\n    const resolvedValue = resolveValue({\n      schema: item.additionalProperties,\n      name,\n      context,\n    });\n    return {\n      value: `{[key: string]: ${resolvedValue.value}}` + nullable,\n      imports: resolvedValue.imports ?? [],\n      schemas: resolvedValue.schemas ?? [],\n      isEnum: false,\n      type: 'object',\n      isRef: false,\n      hasReadonlyProps: resolvedValue.hasReadonlyProps,\n    };\n  }\n\n  const itemWithConst = item as SchemaWithConst;\n  if (itemWithConst.const) {\n    return {\n      value: `'${itemWithConst.const}'` + nullable,\n      imports: [],\n      schemas: [],\n      isEnum: false,\n      type: 'string',\n      isRef: false,\n      hasReadonlyProps: item.readOnly || false,\n    };\n  }\n\n  return {\n    value:\n      (item.type === 'object' ? '{ [key: string]: unknown }' : 'unknown') +\n      nullable,\n    imports: [],\n    schemas: [],\n    isEnum: false,\n    type: 'object',\n    isRef: false,\n    hasReadonlyProps: item.readOnly || false,\n  };\n};\n","import type { SchemaObject } from 'openapi3-ts/oas30';\n\nimport { resolveExampleRefs } from '../resolvers';\nimport type { ContextSpecs, ScalarValue, SchemaWithConst } from '../types';\nimport { escape, isString } from '../utils';\nimport { getArray } from './array';\nimport { combineSchemas } from './combine';\nimport { getObject } from './object';\n\n/**\n * Return the typescript equivalent of open-api data type\n *\n * @param item\n * @ref https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md#data-types\n */\nexport const getScalar = ({\n  item,\n  name,\n  context,\n}: {\n  item: SchemaObject;\n  name?: string;\n  context: ContextSpecs;\n}): ScalarValue => {\n  const nullable = item.nullable ? ' | null' : '';\n\n  const enumItems = item.enum?.filter((enumItem) => enumItem !== null);\n\n  if (!item.type && item.items) {\n    item.type = 'array';\n  }\n\n  switch (item.type) {\n    case 'number':\n    case 'integer': {\n      let value =\n        context.output.override.useBigInt &&\n        (item.format === 'int64' || item.format === 'uint64')\n          ? 'bigint'\n          : 'number';\n      let isEnum = false;\n\n      if (enumItems) {\n        value = enumItems\n          .map((enumItem: number | null) => `${enumItem}`)\n          .join(' | ');\n        isEnum = true;\n      }\n\n      const itemWithConst = item as SchemaWithConst;\n      if (itemWithConst.const !== undefined) {\n        value = itemWithConst.const;\n      }\n\n      return {\n        value: value + nullable,\n        isEnum,\n        type: 'number',\n        schemas: [],\n        imports: [],\n        isRef: false,\n        hasReadonlyProps: item.readOnly || false,\n        example: item.example,\n        examples: resolveExampleRefs(item.examples, context),\n      };\n    }\n\n    case 'boolean': {\n      let value = 'boolean';\n\n      const itemWithConst = item as SchemaWithConst;\n      if (itemWithConst.const !== undefined) {\n        value = itemWithConst.const;\n      }\n\n      return {\n        value: value + nullable,\n        type: 'boolean',\n        isEnum: false,\n        schemas: [],\n        imports: [],\n        isRef: false,\n        hasReadonlyProps: item.readOnly || false,\n        example: item.example,\n        examples: resolveExampleRefs(item.examples, context),\n      };\n    }\n\n    case 'array': {\n      const { value, ...rest } = getArray({\n        schema: item,\n        name,\n        context,\n      });\n      return {\n        value: value + nullable,\n        ...rest,\n      };\n    }\n\n    case 'string': {\n      let value = 'string';\n      let isEnum = false;\n\n      if (enumItems) {\n        value = enumItems\n          .map((enumItem: string | null) =>\n            isString(enumItem) ? `'${escape(enumItem)}'` : `${enumItem}`,\n          )\n          .filter(Boolean)\n          .join(` | `);\n\n        isEnum = true;\n      }\n\n      if (item.format === 'binary') {\n        value = 'Blob';\n      }\n\n      if (\n        context.output.override.useDates &&\n        (item.format === 'date' || item.format === 'date-time')\n      ) {\n        value = 'Date';\n      }\n\n      const itemWithConst = item as SchemaWithConst;\n      if (itemWithConst.const) {\n        value = `'${itemWithConst.const}'`;\n      }\n\n      return {\n        value: value + nullable,\n        isEnum,\n        type: 'string',\n        imports: [],\n        schemas: [],\n        isRef: false,\n        hasReadonlyProps: item.readOnly || false,\n        example: item.example,\n        examples: resolveExampleRefs(item.examples, context),\n      };\n    }\n\n    case 'null': {\n      return {\n        value: 'null',\n        isEnum: false,\n        type: 'null',\n        imports: [],\n        schemas: [],\n        isRef: false,\n        hasReadonlyProps: item.readOnly || false,\n      };\n    }\n\n    case 'object':\n    default: {\n      if (Array.isArray(item.type)) {\n        return combineSchemas({\n          schema: {\n            anyOf: item.type.map((type) => ({\n              ...item,\n              type,\n            })),\n          },\n          name,\n          separator: 'anyOf',\n          context,\n          nullable,\n        });\n      }\n\n      if (enumItems) {\n        const value = enumItems\n          .map((enumItem: unknown) =>\n            isString(enumItem) ? `'${escape(enumItem)}'` : `${enumItem}`,\n          )\n          .filter(Boolean)\n          .join(` | `);\n\n        return {\n          value: value + nullable,\n          isEnum: true,\n          type: 'string',\n          imports: [],\n          schemas: [],\n          isRef: false,\n          hasReadonlyProps: item.readOnly || false,\n          example: item.example,\n          examples: resolveExampleRefs(item.examples, context),\n        };\n      }\n\n      const { value, ...rest } = getObject({\n        item,\n        name,\n        context,\n        nullable,\n      });\n      return { value: value, ...rest };\n    }\n  }\n};\n","import uniq from 'lodash.uniq';\nimport type { SchemaObject } from 'openapi3-ts/oas30';\n\nimport { resolveExampleRefs, resolveObject } from '../resolvers';\nimport {\n  type ContextSpecs,\n  type GeneratorImport,\n  type GeneratorSchema,\n  type ScalarValue,\n  SchemaType,\n} from '../types';\nimport { getNumberWord, isSchema, pascal } from '../utils';\nimport {\n  getEnumDescriptions,\n  getEnumImplementation,\n  getEnumNames,\n} from './enum';\nimport { getAliasedImports, getImportAliasForRefOrValue } from './imports';\nimport { getScalar } from './scalar';\n\ntype CombinedData = {\n  imports: GeneratorImport[];\n  schemas: GeneratorSchema[];\n  originalSchema: (SchemaObject | undefined)[];\n  values: string[];\n  isRef: boolean[];\n  isEnum: boolean[];\n  types: string[];\n  hasReadonlyProps: boolean;\n  /**\n   * List of all properties in all subschemas\n   * - used to add missing properties in subschemas to avoid TS error described in @see https://github.com/orval-labs/orval/issues/935\n   */\n  allProperties: string[];\n  requiredProperties: string[];\n};\n\ntype Separator = 'allOf' | 'anyOf' | 'oneOf';\n\nconst combineValues = ({\n  resolvedData,\n  resolvedValue,\n  separator,\n  context,\n}: {\n  resolvedData: CombinedData;\n  resolvedValue?: ScalarValue;\n  separator: Separator;\n  context: ContextSpecs;\n}) => {\n  const isAllEnums = resolvedData.isEnum.every(Boolean);\n\n  if (isAllEnums) {\n    return `${resolvedData.values.join(` | `)}${\n      resolvedValue ? ` | ${resolvedValue.value}` : ''\n    }`;\n  }\n\n  if (separator === 'allOf') {\n    let resolvedDataValue = resolvedData.values.join(` & `);\n    if (resolvedData.originalSchema.length > 0 && resolvedValue) {\n      const discriminatedPropertySchemas = resolvedData.originalSchema.filter(\n        (s) =>\n          s?.discriminator &&\n          resolvedValue.value.includes(` ${s.discriminator.propertyName}:`),\n      ) as SchemaObject[];\n      if (discriminatedPropertySchemas.length > 0) {\n        resolvedDataValue = `Omit<${resolvedDataValue}, '${discriminatedPropertySchemas.map((s) => s.discriminator?.propertyName).join(\"' | '\")}'>`;\n      }\n    }\n    const joined = `${resolvedDataValue}${\n      resolvedValue ? ` & ${resolvedValue.value}` : ''\n    }`;\n\n    // Parent object may have set required properties that only exist in child\n    // objects. Make sure the resulting object has these properties as required,\n    // but there is no need to override properties that are already required\n    const overrideRequiredProperties = resolvedData.requiredProperties.filter(\n      (prop) =>\n        !resolvedData.originalSchema.some(\n          (schema) =>\n            schema?.properties?.[prop] && schema.required?.includes(prop),\n        ),\n    );\n    if (overrideRequiredProperties.length > 0) {\n      return `${joined} & Required<Pick<${joined}, '${overrideRequiredProperties.join(\"' | '\")}'>>`;\n    }\n    return joined;\n  }\n\n  let values = resolvedData.values;\n  const hasObjectSubschemas = resolvedData.allProperties.length;\n  if (hasObjectSubschemas && context.output.unionAddMissingProperties) {\n    values = []; // the list of values will be rebuilt to add missing properties (if exist) in subschemas\n    for (let i = 0; i < resolvedData.values.length; i += 1) {\n      const subSchema = resolvedData.originalSchema[i];\n      if (subSchema?.type !== 'object') {\n        values.push(resolvedData.values[i]);\n        continue;\n      }\n\n      const missingProperties = uniq(\n        resolvedData.allProperties.filter(\n          (p) => !Object.keys(subSchema.properties!).includes(p),\n        ),\n      );\n      values.push(\n        `${resolvedData.values[i]}${\n          missingProperties.length > 0\n            ? ` & {${missingProperties.map((p) => `${p}?: never`).join('; ')}}`\n            : ''\n        }`,\n      );\n    }\n  }\n\n  if (resolvedValue) {\n    return `(${values.join(` & ${resolvedValue.value}) | (`)} & ${\n      resolvedValue.value\n    })`;\n  }\n\n  return values.join(' | ');\n};\n\nexport const combineSchemas = ({\n  name,\n  schema,\n  separator,\n  context,\n  nullable,\n}: {\n  name?: string;\n  schema: SchemaObject;\n  separator: Separator;\n  context: ContextSpecs;\n  nullable: string;\n}): ScalarValue => {\n  const items = schema[separator] ?? [];\n\n  const resolvedData = items.reduce<CombinedData>(\n    (acc, subSchema) => {\n      let propName = name ? name + pascal(separator) : undefined;\n      if (propName && acc.schemas.length > 0) {\n        propName = propName + pascal(getNumberWord(acc.schemas.length + 1));\n      }\n\n      if (separator === 'allOf' && isSchema(subSchema) && subSchema.required) {\n        acc.requiredProperties.push(...subSchema.required);\n      }\n\n      const resolvedValue = resolveObject({\n        schema: subSchema,\n        propName,\n        combined: true,\n        context,\n      });\n\n      const aliasedImports = getAliasedImports({\n        context,\n        name,\n        resolvedValue,\n        existingImports: acc.imports,\n      });\n\n      const value = getImportAliasForRefOrValue({\n        context,\n        resolvedValue,\n        imports: aliasedImports,\n      });\n\n      acc.values.push(value);\n      acc.imports.push(...aliasedImports);\n      acc.schemas.push(...resolvedValue.schemas);\n      acc.isEnum.push(resolvedValue.isEnum);\n      acc.types.push(resolvedValue.type);\n      acc.isRef.push(resolvedValue.isRef);\n      acc.originalSchema.push(resolvedValue.originalSchema);\n      acc.hasReadonlyProps ||= resolvedValue.hasReadonlyProps;\n\n      if (\n        resolvedValue.type === 'object' &&\n        resolvedValue.originalSchema.properties\n      ) {\n        acc.allProperties.push(\n          ...Object.keys(resolvedValue.originalSchema.properties),\n        );\n      }\n\n      return acc;\n    },\n    {\n      values: [],\n      imports: [],\n      schemas: [],\n      isEnum: [], // check if only enums\n      isRef: [],\n      types: [],\n      originalSchema: [],\n      allProperties: [],\n      hasReadonlyProps: false,\n      example: schema.example,\n      examples: resolveExampleRefs(schema.examples, context),\n      requiredProperties: separator === 'allOf' ? (schema.required ?? []) : [],\n    } as CombinedData,\n  );\n\n  const isAllEnums = resolvedData.isEnum.every(Boolean);\n\n  if (isAllEnums && name && items.length > 1) {\n    const newEnum = `// eslint-disable-next-line @typescript-eslint/no-redeclare\\nexport const ${pascal(\n      name,\n    )} = ${getCombineEnumValue(resolvedData)}`;\n\n    return {\n      value: `typeof ${pascal(name)}[keyof typeof ${pascal(name)}] ${nullable}`,\n      imports: [\n        {\n          name: pascal(name),\n        },\n      ],\n      schemas: [\n        ...resolvedData.schemas,\n        {\n          imports: resolvedData.imports.map<GeneratorImport>((toImport) => ({\n            ...toImport,\n            values: true,\n          })),\n          model: newEnum,\n          name: name,\n        },\n      ],\n      isEnum: false,\n      type: 'object' as SchemaType,\n      isRef: false,\n      hasReadonlyProps: resolvedData.hasReadonlyProps,\n      example: schema.example,\n      examples: resolveExampleRefs(schema.examples, context),\n    };\n  }\n\n  let resolvedValue: ScalarValue | undefined;\n\n  if (schema.properties) {\n    resolvedValue = getScalar({\n      item: Object.fromEntries(\n        Object.entries(schema).filter(([key]) => key !== separator),\n      ),\n      name,\n      context,\n    });\n  }\n\n  const value = combineValues({\n    resolvedData,\n    separator,\n    resolvedValue,\n    context,\n  });\n\n  return {\n    value: value + nullable,\n    imports: resolvedValue\n      ? [...resolvedData.imports, ...resolvedValue.imports]\n      : resolvedData.imports,\n    schemas: resolvedValue\n      ? [...resolvedData.schemas, ...resolvedValue.schemas]\n      : resolvedData.schemas,\n    isEnum: false,\n    type: 'object' as SchemaType,\n    isRef: false,\n    hasReadonlyProps:\n      resolvedData?.hasReadonlyProps ||\n      resolvedValue?.hasReadonlyProps ||\n      false,\n    example: schema.example,\n    examples: resolveExampleRefs(schema.examples, context),\n  };\n};\n\nconst getCombineEnumValue = ({\n  values,\n  isRef,\n  originalSchema,\n}: CombinedData) => {\n  if (values.length === 1) {\n    if (isRef[0]) {\n      return values[0];\n    }\n\n    return `{${getEnumImplementation(values[0])}} as const`;\n  }\n\n  const enums = values\n    .map((e, i) => {\n      if (isRef[i]) {\n        return `...${e},`;\n      }\n\n      const names = getEnumNames(originalSchema[i]);\n      const descriptions = getEnumDescriptions(originalSchema[i]);\n\n      return getEnumImplementation(e, names, descriptions);\n    })\n    .join('');\n\n  return `{${enums}} as const`;\n};\n","import type { SchemaObject, SchemasObject } from 'openapi3-ts/oas30';\n\nimport type { ContextSpecs } from '../types';\nimport { pascal } from '../utils';\nimport { getRefInfo } from './ref';\n\nexport const resolveDiscriminators = (\n  schemas: SchemasObject,\n  context: ContextSpecs,\n): SchemasObject => {\n  const transformedSchemas = { ...schemas };\n\n  for (const schema of Object.values(transformedSchemas)) {\n    if (schema.discriminator?.mapping) {\n      const { mapping, propertyName } = schema.discriminator;\n\n      for (const [mappingKey, mappingValue] of Object.entries(mapping)) {\n        let subTypeSchema;\n\n        try {\n          const { originalName } = getRefInfo(mappingValue, context);\n          // name from getRefInfo may contain a suffix, which we don't want\n          const name = pascal(originalName);\n          subTypeSchema =\n            transformedSchemas[name] ?? transformedSchemas[originalName];\n        } catch {\n          subTypeSchema = transformedSchemas[mappingValue];\n        }\n\n        if (!subTypeSchema) {\n          continue;\n        }\n        const property = subTypeSchema.properties?.[\n          propertyName\n        ] as SchemaObject;\n        subTypeSchema.properties = {\n          ...subTypeSchema.properties,\n          [propertyName]: {\n            type: 'string',\n            enum: [\n              ...(property?.enum?.filter((value) => value !== mappingKey) ??\n                []),\n              mappingKey,\n            ],\n          },\n        };\n        subTypeSchema.required = [\n          ...(subTypeSchema.required ?? []),\n          propertyName,\n        ];\n      }\n    }\n  }\n\n  return transformedSchemas;\n};\n","import type { OperationObject } from 'openapi3-ts/oas30';\n\nimport { Verbs } from '../types';\nimport { pascal, sanitize } from '../utils';\n\nexport const getOperationId = (\n  operation: OperationObject,\n  route: string,\n  verb: Verbs,\n): string => {\n  if (operation.operationId) {\n    return operation.operationId;\n  }\n\n  return pascal(\n    [\n      verb,\n      ...route.split('/').map((p) =>\n        sanitize(p, {\n          dash: true,\n          underscore: '-',\n          dot: '-',\n          whitespace: '-',\n        }),\n      ),\n    ].join('-'),\n  );\n};\n","import type { ParameterObject, ReferenceObject } from 'openapi3-ts/oas30';\n\nimport { resolveRef } from '../resolvers/ref';\nimport type { ContextSpecs, GetterParameters } from '../types';\nimport { isReference } from '../utils';\n\nexport const getParameters = ({\n  parameters = [],\n  context,\n}: {\n  parameters: (ReferenceObject | ParameterObject)[];\n  context: ContextSpecs;\n}): GetterParameters => {\n  return parameters.reduce<GetterParameters>(\n    (acc, p) => {\n      if (isReference(p)) {\n        const { schema: parameter, imports } = resolveRef<ParameterObject>(\n          p,\n          context,\n        );\n\n        if (\n          parameter.in === 'path' ||\n          parameter.in === 'query' ||\n          parameter.in === 'header'\n        ) {\n          acc[parameter.in].push({ parameter, imports });\n        }\n      } else {\n        if (p.in === 'query' || p.in === 'path' || p.in === 'header') {\n          acc[p.in].push({ parameter: p, imports: [] });\n        }\n      }\n\n      return acc;\n    },\n    {\n      path: [],\n      query: [],\n      header: [],\n    },\n  );\n};\n","import { resolveValue } from '../resolvers';\nimport type {\n  ContextSpecs,\n  GetterParameters,\n  GetterParams,\n  NormalizedOutputOptions,\n} from '../types';\nimport { camel, sanitize, stringify } from '../utils';\n\n/**\n * Return every params in a path\n *\n * @example\n * ```\n * getParamsInPath(\"/pet/{category}/{name}/\");\n * // => [\"category\", \"name\"]\n * ```\n * @param path\n */\nexport const getParamsInPath = (path: string) => {\n  let n;\n  const output = [];\n  const templatePathRegex = /\\{(.*?)\\}/g;\n  while ((n = templatePathRegex.exec(path)) !== null) {\n    output.push(n[1]);\n  }\n\n  return output;\n};\n\nexport const getParams = ({\n  route,\n  pathParams = [],\n  operationId,\n  context,\n  output,\n}: {\n  route: string;\n  pathParams?: GetterParameters['query'];\n  operationId: string;\n  context: ContextSpecs;\n  output: NormalizedOutputOptions;\n}): GetterParams => {\n  const params = getParamsInPath(route);\n  return params.map((p) => {\n    const pathParam = pathParams.find(\n      ({ parameter }) =>\n        sanitize(camel(parameter.name), {\n          es5keyword: true,\n          underscore: true,\n          dash: true,\n        }) === p,\n    );\n\n    if (!pathParam) {\n      throw new Error(\n        `The path params ${p} can't be found in parameters (${operationId})`,\n      );\n    }\n\n    const {\n      name: nameWithoutSanitize,\n      required = false,\n      schema,\n    } = pathParam.parameter;\n\n    const name = sanitize(camel(nameWithoutSanitize), { es5keyword: true });\n\n    if (!schema) {\n      return {\n        name,\n        definition: `${name}${required ? '' : '?'}: unknown`,\n        implementation: `${name}${required ? '' : '?'}: unknown`,\n        default: false,\n        required,\n        imports: [],\n      };\n    }\n\n    const resolvedValue = resolveValue({\n      schema,\n      context: {\n        ...context,\n        ...(pathParam.imports.length > 0\n          ? {\n              specKey: pathParam.imports[0].specKey,\n            }\n          : {}),\n      },\n    });\n\n    let paramType = resolvedValue.value;\n    if (output.allParamsOptional) {\n      paramType = `${paramType} | undefined | null`; // TODO: maybe check that `paramType` isn't already undefined or null\n    }\n\n    const definition = `${name}${\n      !required || resolvedValue.originalSchema!.default ? '?' : ''\n    }: ${paramType}`;\n\n    const implementation = `${name}${\n      !required && !resolvedValue.originalSchema!.default ? '?' : ''\n    }${\n      resolvedValue.originalSchema!.default\n        ? `: ${paramType} = ${stringify(resolvedValue.originalSchema!.default)}`\n        : `: ${paramType}` // FIXME: in Vue if we have `version: MaybeRef<number | undefined | null> = 1` and we don't pass version, the unref(version) will be `undefined` and not `1`, so we need to handle default value somewhere in implementation and not in the definition\n    }`;\n\n    return {\n      name,\n      definition,\n      implementation,\n      default: resolvedValue.originalSchema!.default,\n      required,\n      imports: resolvedValue.imports,\n      originalSchema: resolvedValue.originalSchema,\n    };\n  });\n};\n","import {\n  type ContextSpecs,\n  type GetterBody,\n  type GetterParams,\n  type GetterProps,\n  GetterPropType,\n  type GetterQueryParam,\n  OutputClient,\n} from '../types';\nimport { isUndefined, pascal, sortByPriority } from '../utils';\n\nexport const getProps = ({\n  body,\n  queryParams,\n  params,\n  operationName,\n  headers,\n  context,\n}: {\n  body: GetterBody;\n  queryParams?: GetterQueryParam;\n  params: GetterParams;\n  operationName: string;\n  headers?: GetterQueryParam;\n  context: ContextSpecs;\n}): GetterProps => {\n  const bodyProp = {\n    name: body.implementation,\n    definition: `${body.implementation}${body.isOptional ? '?' : ''}: ${body.definition}`,\n    implementation: `${body.implementation}${body.isOptional ? '?' : ''}: ${body.definition}`,\n    default: false,\n    required: !body.isOptional,\n    type: GetterPropType.BODY,\n  };\n\n  const queryParamsProp = {\n    name: 'params',\n    definition: getQueryParamDefinition(queryParams, context),\n    implementation: getQueryParamDefinition(queryParams, context),\n    default: false,\n    required: isUndefined(queryParams?.isOptional)\n      ? !context.output.allParamsOptional\n      : !queryParams?.isOptional && !context.output.allParamsOptional,\n    type: GetterPropType.QUERY_PARAM,\n  };\n\n  const headersProp = {\n    name: 'headers',\n    definition: `headers${headers?.isOptional ? '?' : ''}: ${\n      headers?.schema.name\n    }`,\n    implementation: `headers${headers?.isOptional ? '?' : ''}: ${\n      headers?.schema.name\n    }`,\n    default: false,\n    required: isUndefined(headers?.isOptional) ? false : !headers?.isOptional,\n    type: GetterPropType.HEADER,\n  };\n\n  let paramGetterProps: GetterProps;\n  if (context.output.override.useNamedParameters && params.length > 0) {\n    const parameterTypeName = `${pascal(operationName)}PathParameters`;\n\n    const name = 'pathParams';\n\n    // needs a special model\n    const namedParametersTypeDefinition = `export type ${parameterTypeName} = {\\n ${params\n      .map((property) => property.definition)\n      .join(',\\n    ')},\\n }`;\n\n    const isOptional = params.every((param) => param.default);\n\n    const implementation = `{ ${params\n      .map((property) =>\n        property.default\n          ? `${property.name} = ${property.default}` // if we use property.implementation, we will get `{ version: number = 1 }: ListPetsPathParameters = {}` which isn't valid\n          : property.name,\n      )\n      .join(', ')} }: ${parameterTypeName}${isOptional ? ' = {}' : ''}`;\n\n    const destructured = `{ ${params\n      .map((property) => property.name)\n      .join(', ')} }`;\n\n    paramGetterProps = [\n      {\n        type: GetterPropType.NAMED_PATH_PARAMS,\n        name,\n        definition: `${name}: ${parameterTypeName}`,\n        implementation,\n        default: false,\n        destructured,\n        required: true,\n        schema: {\n          name: parameterTypeName,\n          model: namedParametersTypeDefinition,\n          imports: params.flatMap((property) => property.imports),\n        },\n      },\n    ];\n  } else {\n    paramGetterProps = params.map((param) => ({\n      ...param,\n      type: GetterPropType.PARAM,\n    }));\n  }\n\n  const props = [\n    ...paramGetterProps,\n    ...(body.definition ? [bodyProp] : []),\n    ...(queryParams ? [queryParamsProp] : []),\n    ...(headers ? [headersProp] : []),\n  ];\n\n  const sortedProps = sortByPriority(props);\n\n  return sortedProps;\n};\n\nfunction getQueryParamDefinition(\n  queryParams: GetterQueryParam | undefined,\n  context: ContextSpecs,\n): string {\n  let paramType = queryParams?.schema.name;\n  if (OutputClient.ANGULAR === context.output.client) {\n    paramType = `DeepNonNullable<${paramType}>`;\n  }\n  return `params${queryParams?.isOptional || context.output.allParamsOptional ? '?' : ''}: ${paramType}`;\n}\n","import type { ContentObject, SchemaObject } from 'openapi3-ts/oas30';\n\nimport { resolveValue } from '../resolvers';\nimport type {\n  ContextSpecs,\n  GeneratorImport,\n  GeneratorSchema,\n  GetterParameters,\n  GetterQueryParam,\n} from '../types';\nimport { jsDoc, pascal, sanitize } from '../utils';\nimport { getEnum, getEnumDescriptions, getEnumNames } from './enum';\nimport { getKey } from './keys';\n\ntype QueryParamsType = {\n  definition: string;\n  imports: GeneratorImport[];\n  schemas: GeneratorSchema[];\n  originalSchema: SchemaObject;\n};\n\nconst getQueryParamsTypes = (\n  queryParams: GetterParameters['query'],\n  operationName: string,\n  context: ContextSpecs,\n): QueryParamsType[] => {\n  return queryParams.map(({ parameter, imports: parameterImports }) => {\n    const {\n      name,\n      required,\n      schema: schemaParam,\n      content,\n    } = parameter as {\n      name: string;\n      required: boolean;\n      schema: SchemaObject;\n      content: ContentObject;\n    };\n\n    const queryName = sanitize(`${pascal(operationName)}${pascal(name)}`, {\n      underscore: '_',\n      whitespace: '_',\n      dash: true,\n      es5keyword: true,\n      es5IdentifierName: true,\n    });\n\n    const schema = (schemaParam || content['application/json'].schema)!;\n\n    const resolvedValue = resolveValue({\n      schema,\n      context,\n      name: queryName,\n    });\n\n    const key = getKey(name);\n    const doc = jsDoc(\n      {\n        description: parameter.description,\n        ...schema,\n      },\n      void 0,\n      context,\n    );\n\n    if (parameterImports.length > 0) {\n      return {\n        definition: `${doc}${key}${!required || schema.default ? '?' : ''}: ${\n          parameterImports[0].name\n        };`,\n        imports: parameterImports,\n        schemas: [],\n        originalSchema: resolvedValue.originalSchema,\n      };\n    }\n\n    if (resolvedValue.isEnum && !resolvedValue.isRef) {\n      const enumName = queryName;\n      const enumValue = getEnum(\n        resolvedValue.value,\n        enumName,\n        getEnumNames(resolvedValue.originalSchema),\n        context.output.override.enumGenerationType,\n        getEnumDescriptions(resolvedValue.originalSchema),\n        context.output.override.namingConvention?.enum,\n      );\n\n      return {\n        definition: `${doc}${key}${\n          !required || schema.default ? '?' : ''\n        }: ${enumName};`,\n        imports: [{ name: enumName }],\n        schemas: [\n          ...resolvedValue.schemas,\n          { name: enumName, model: enumValue, imports: resolvedValue.imports },\n        ],\n        originalSchema: resolvedValue.originalSchema,\n      };\n    }\n\n    const definition = `${doc}${key}${\n      !required || schema.default ? '?' : ''\n    }: ${resolvedValue.value};`;\n\n    return {\n      definition,\n      imports: resolvedValue.imports,\n      schemas: resolvedValue.schemas,\n      originalSchema: resolvedValue.originalSchema,\n    };\n  });\n};\n\nexport const getQueryParams = ({\n  queryParams = [],\n  operationName,\n  context,\n  suffix = 'params',\n}: {\n  queryParams: GetterParameters['query'];\n  operationName: string;\n  context: ContextSpecs;\n  suffix?: string;\n}): GetterQueryParam | undefined => {\n  if (queryParams.length === 0) {\n    return;\n  }\n  const types = getQueryParamsTypes(queryParams, operationName, context);\n  const imports = types.flatMap(({ imports }) => imports);\n  const schemas = types.flatMap(({ schemas }) => schemas);\n  const name = `${pascal(operationName)}${pascal(suffix)}`;\n\n  const type = types.map(({ definition }) => definition).join('\\n');\n  const allOptional = queryParams.every(({ parameter }) => !parameter.required);\n\n  const schema = {\n    name,\n    model: `export type ${name} = {\\n${type}\\n};\\n`,\n    imports,\n  };\n\n  return {\n    schema,\n    deps: schemas,\n    isOptional: allOptional,\n  };\n};\n","import type { ResponsesObject } from 'openapi3-ts/oas30';\n\nimport type {\n  ContextSpecs,\n  GetterResponse,\n  OverrideOutputContentType,\n  ResReqTypesValue,\n} from '../types';\nimport { getResReqTypes } from './res-req-types';\n\nexport const getResponse = ({\n  responses,\n  operationName,\n  context,\n  contentType,\n}: {\n  responses: ResponsesObject;\n  operationName: string;\n  context: ContextSpecs;\n  contentType?: OverrideOutputContentType;\n}): GetterResponse => {\n  if (!responses) {\n    return {\n      imports: [],\n      definition: {\n        success: '',\n        errors: '',\n      },\n      isBlob: false,\n      types: { success: [], errors: [] },\n      schemas: [],\n      contentTypes: [],\n    };\n  }\n\n  const types = getResReqTypes(\n    Object.entries(responses),\n    operationName,\n    context,\n    'void',\n    (type) => `${type.key}-${type.value}`,\n  );\n\n  const filteredTypes = contentType\n    ? types.filter((type) => {\n        let include = true;\n        let exclude = false;\n\n        if (contentType.include) {\n          include = contentType.include.includes(type.contentType);\n        }\n\n        if (contentType.exclude) {\n          exclude = contentType.exclude.includes(type.contentType);\n        }\n\n        return include && !exclude;\n      })\n    : types;\n\n  const imports = filteredTypes.flatMap(({ imports }) => imports);\n  const schemas = filteredTypes.flatMap(({ schemas }) => schemas);\n\n  const contentTypes = [\n    ...new Set(filteredTypes.map(({ contentType }) => contentType)),\n  ];\n\n  const groupedByStatus = filteredTypes.reduce<{\n    success: ResReqTypesValue[];\n    errors: ResReqTypesValue[];\n  }>(\n    (acc, type) => {\n      if (type.key.startsWith('2')) {\n        acc.success.push(type);\n      } else {\n        acc.errors.push(type);\n      }\n      return acc;\n    },\n    { success: [], errors: [] },\n  );\n\n  const success = groupedByStatus.success\n    .map(({ value, formData }) => (formData ? 'Blob' : value))\n    .join(' | ');\n  const errors = groupedByStatus.errors.map(({ value }) => value).join(' | ');\n\n  const defaultType = filteredTypes.find(({ key }) => key === 'default')?.value;\n\n  return {\n    imports,\n    definition: {\n      success: success || (defaultType ?? 'unknown'),\n      errors: errors || (defaultType ?? 'unknown'),\n    },\n    isBlob: success === 'Blob',\n    types: groupedByStatus,\n    contentTypes,\n    schemas,\n    originalSchema: responses,\n  };\n};\n","import type { ServerObject } from 'openapi3-ts/oas31';\n\nimport { TEMPLATE_TAG_REGEX } from '../constants';\nimport type { BaseUrlFromConstant, BaseUrlFromSpec } from '../types';\nimport { camel, sanitize } from '../utils';\n\nconst TEMPLATE_TAG_IN_PATH_REGEX = /\\/([\\w]+)(?:\\$\\{)/g; // all dynamic parts of path\n\nconst hasParam = (path: string): boolean => /[^{]*{[\\w*_-]*}.*/.test(path);\n\nconst getRoutePath = (path: string): string => {\n  const matches = /([^{]*){?([\\w*_-]*)}?(.*)/.exec(path);\n  if (!matches?.length) return path; // impossible due to regexp grouping here, but for TS\n\n  const prev = matches[1];\n  const param = sanitize(camel(matches[2]), {\n    es5keyword: true,\n    underscore: true,\n    dash: true,\n    dot: true,\n  });\n  const next = hasParam(matches[3]) ? getRoutePath(matches[3]) : matches[3];\n\n  return hasParam(path)\n    ? `${prev}\\${${param}}${next}`\n    : `${prev}${param}${next}`;\n};\n\nexport const getRoute = (route: string) => {\n  const splittedRoute = route.split('/');\n\n  return splittedRoute.reduce((acc, path, i) => {\n    if (!path && !i) {\n      return acc;\n    }\n\n    if (!path.includes('{')) {\n      return `${acc}/${path}`;\n    }\n\n    return `${acc}/${getRoutePath(path)}`;\n  }, '');\n};\n\nexport const getFullRoute = (\n  route: string,\n  servers: ServerObject[] | undefined,\n  baseUrl: string | BaseUrlFromConstant | BaseUrlFromSpec | undefined,\n): string => {\n  const getBaseUrl = (): string => {\n    if (!baseUrl) return '';\n    if (typeof baseUrl === 'string') return baseUrl;\n    if (baseUrl.getBaseUrlFromSpecification) {\n      if (!servers) {\n        throw new Error(\n          \"Orval is configured to use baseUrl from the specifications 'servers' field, but there exist no servers in the specification.\",\n        );\n      }\n      const server = servers.at(\n        Math.min(baseUrl.index ?? 0, servers.length - 1),\n      );\n      if (!server) return '';\n      if (!server.variables) return server.url;\n\n      let url = server.url;\n      const variables = baseUrl.variables;\n      for (const variableKey of Object.keys(server.variables)) {\n        const variable = server.variables[variableKey];\n        if (variables?.[variableKey]) {\n          if (\n            variable.enum &&\n            !variable.enum.some((e) => e == variables[variableKey])\n          ) {\n            throw new Error(\n              `Invalid variable value '${variables[variableKey]}' for variable '${variableKey}' when resolving ${server.url}. Valid values are: ${variable.enum.join(', ')}.`,\n            );\n          }\n          url = url.replaceAll(`{${variableKey}}`, variables[variableKey]);\n        } else {\n          url = url.replaceAll(`{${variableKey}}`, String(variable.default));\n        }\n      }\n      return url;\n    }\n    return baseUrl.baseUrl;\n  };\n\n  let fullRoute = route;\n  const base = getBaseUrl();\n  if (base) {\n    if (base.endsWith('/') && route.startsWith('/')) {\n      fullRoute = route.slice(1);\n    }\n    fullRoute = `${base}${fullRoute}`;\n  }\n  return fullRoute;\n};\n\n// Creates a mixed use array with path variables and string from template string route\nexport const getRouteAsArray = (route: string): string =>\n  route\n    .replaceAll(TEMPLATE_TAG_IN_PATH_REGEX, '/$1/${')\n    .split('/')\n    .filter((i) => i !== '')\n    .map((i) =>\n      // @note - array is mixed with string and var\n      i.includes('${') ? i.replace(TEMPLATE_TAG_REGEX, '$1') : `'${i}'`,\n    )\n    .join(',')\n    .replace(',,', '');\n","import isEmpty from 'lodash.isempty';\nimport type {\n  ComponentsObject,\n  ReferenceObject,\n  RequestBodyObject,\n  ResponseObject,\n} from 'openapi3-ts/oas30';\n\nimport { getResReqTypes } from '../getters';\nimport type { ContextSpecs, GeneratorSchema } from '../types';\nimport { jsDoc, pascal, sanitize } from '../utils';\n\nexport const generateComponentDefinition = (\n  responses:\n    | ComponentsObject['responses']\n    | ComponentsObject['requestBodies'] = {},\n  context: ContextSpecs,\n  suffix: string,\n): GeneratorSchema[] => {\n  if (isEmpty(responses)) {\n    return [];\n  }\n\n  return Object.entries(responses).reduce<GeneratorSchema[]>(\n    (\n      acc,\n      [name, response]: [\n        string,\n        ReferenceObject | RequestBodyObject | ResponseObject,\n      ],\n    ) => {\n      const allResponseTypes = getResReqTypes(\n        [[suffix, response]],\n        name,\n        context,\n        'void',\n      );\n\n      const imports = allResponseTypes.flatMap(({ imports }) => imports);\n      const schemas = allResponseTypes.flatMap(({ schemas }) => schemas);\n\n      const type = allResponseTypes.map(({ value }) => value).join(' | ');\n\n      const modelName = sanitize(`${pascal(name)}${suffix}`, {\n        underscore: '_',\n        whitespace: '_',\n        dash: true,\n        es5keyword: true,\n        es5IdentifierName: true,\n      });\n      const doc = jsDoc(response as ResponseObject | RequestBodyObject);\n      const model = `${doc}export type ${modelName} = ${type || 'unknown'};\\n`;\n\n      acc.push(...schemas);\n\n      if (modelName !== type) {\n        acc.push({\n          name: modelName,\n          model,\n          imports,\n        });\n      }\n\n      return acc;\n    },\n    [],\n  );\n};\n","import uniq from 'lodash.uniq';\nimport uniqWith from 'lodash.uniqwith';\n\nimport {\n  type GeneratorImport,\n  type GeneratorMutator,\n  type GeneratorVerbOptions,\n  GetterPropType,\n  NamingConvention,\n} from '../types';\nimport { conventionName, upath } from '../utils';\n\nexport const generateImports = ({\n  imports = [],\n  target,\n  isRootKey,\n  specsName,\n  specKey: currentSpecKey,\n  namingConvention = NamingConvention.CAMEL_CASE,\n}: {\n  imports: GeneratorImport[];\n  target: string;\n  isRootKey: boolean;\n  specsName: Record<string, string>;\n  specKey: string;\n  namingConvention?: NamingConvention;\n}) => {\n  if (imports.length === 0) {\n    return '';\n  }\n\n  return uniqWith(\n    imports,\n    (a, b) =>\n      a.name === b.name && a.default === b.default && a.specKey === b.specKey,\n  )\n    .sort()\n    .map(({ specKey, name, values, alias, isConstant }) => {\n      const isSameSpecKey = currentSpecKey === specKey;\n\n      const fileName = conventionName(name, namingConvention);\n\n      if (specKey && !isSameSpecKey) {\n        const path = specKey === target ? '' : specsName[specKey];\n\n        if (!isRootKey && specKey) {\n          return `import ${!values && !isConstant ? 'type ' : ''}{ ${name}${\n            alias ? ` as ${alias}` : ''\n          } } from \\'../${upath.join(path, fileName)}\\';`;\n        }\n\n        return `import ${!values && !isConstant ? 'type ' : ''}{ ${name}${\n          alias ? ` as ${alias}` : ''\n        } } from \\'./${upath.join(path, fileName)}\\';`;\n      }\n\n      return `import ${!values && !isConstant ? 'type ' : ''}{ ${name}${\n        alias ? ` as ${alias}` : ''\n      } } from \\'./${fileName}\\';`;\n    })\n    .join('\\n');\n};\n\nexport const generateMutatorImports = ({\n  mutators,\n  implementation,\n  oneMore,\n}: {\n  mutators: GeneratorMutator[];\n  implementation?: string;\n  oneMore?: boolean;\n}) => {\n  const imports = uniqWith(\n    mutators,\n    (a, b) => a.name === b.name && a.default === b.default,\n  ).reduce((acc, mutator) => {\n    const path = `${oneMore ? '../' : ''}${mutator.path}`;\n    const importDefault = mutator.default\n      ? mutator.name\n      : `{ ${mutator.name} }`;\n\n    acc += `import ${importDefault} from '${path}';`;\n    acc += '\\n';\n\n    if (implementation && (mutator.hasErrorType || mutator.bodyTypeName)) {\n      let errorImportName = '';\n      const targetErrorImportName = mutator.default\n        ? `ErrorType as ${mutator.errorTypeName}`\n        : mutator.errorTypeName;\n      if (\n        mutator.hasErrorType &&\n        implementation.includes(mutator.errorTypeName) &&\n        !acc.includes(`{ ${targetErrorImportName} `)\n      ) {\n        errorImportName = targetErrorImportName;\n      }\n\n      let bodyImportName = '';\n      const targetBodyImportName = mutator.default\n        ? `BodyType as ${mutator.bodyTypeName}`\n        : mutator.bodyTypeName;\n      if (\n        mutator.bodyTypeName &&\n        implementation.includes(mutator.bodyTypeName) &&\n        !acc.includes(` ${targetBodyImportName} }`)\n      ) {\n        bodyImportName = targetBodyImportName!;\n      }\n\n      if (bodyImportName || errorImportName) {\n        acc += `import type { ${errorImportName}${\n          errorImportName && bodyImportName ? ' , ' : ''\n        }${bodyImportName} } from '${path}';`;\n        acc += '\\n';\n      }\n    }\n\n    return acc;\n  }, '');\n\n  return imports;\n};\n\nconst generateDependency = ({\n  deps,\n  isAllowSyntheticDefaultImports,\n  dependency,\n  specsName,\n  key,\n  onlyTypes,\n}: {\n  key: string;\n  deps: GeneratorImport[];\n  dependency: string;\n  specsName: Record<string, string>;\n  isAllowSyntheticDefaultImports: boolean;\n  onlyTypes: boolean;\n}) => {\n  const defaultDep = deps.find(\n    (e) =>\n      e.default &&\n      (isAllowSyntheticDefaultImports || !e.syntheticDefaultImport),\n  );\n  const syntheticDefaultImportDep = isAllowSyntheticDefaultImports\n    ? undefined\n    : deps.find((e) => e.syntheticDefaultImport);\n\n  const depsString = uniq(\n    deps\n      .filter((e) => !e.default && !e.syntheticDefaultImport)\n      .map(({ name, alias }) => (alias ? `${name} as ${alias}` : name)),\n  )\n    .sort()\n    .join(',\\n  ');\n\n  let importString = '';\n\n  const syntheticDefaultImport = syntheticDefaultImportDep\n    ? `import * as ${syntheticDefaultImportDep.name} from '${dependency}';`\n    : '';\n\n  if (syntheticDefaultImport) {\n    if (deps.length === 1) {\n      return syntheticDefaultImport;\n    }\n    importString += `${syntheticDefaultImport}\\n`;\n  }\n\n  importString += `import ${onlyTypes ? 'type ' : ''}${\n    defaultDep ? `${defaultDep.name}${depsString ? ',' : ''}` : ''\n  }${depsString ? `{\\n  ${depsString}\\n}` : ''} from '${dependency}${\n    key !== 'default' && specsName[key] ? `/${specsName[key]}` : ''\n  }';`;\n\n  return importString;\n};\n\nexport const addDependency = ({\n  implementation,\n  exports,\n  dependency,\n  specsName,\n  hasSchemaDir,\n  isAllowSyntheticDefaultImports,\n}: {\n  implementation: string;\n  exports: GeneratorImport[];\n  dependency: string;\n  specsName: Record<string, string>;\n  hasSchemaDir: boolean;\n  isAllowSyntheticDefaultImports: boolean;\n}) => {\n  const toAdds = exports.filter((e) => {\n    const searchWords = [e.alias, e.name].filter((p) => p?.length).join('|');\n    const pattern = new RegExp(`\\\\b(${searchWords})\\\\b`, 'g');\n\n    return implementation.match(pattern);\n  });\n\n  if (toAdds.length === 0) {\n    return;\n  }\n\n  const groupedBySpecKey = toAdds.reduce<\n    Record<string, { types: GeneratorImport[]; values: GeneratorImport[] }>\n  >((acc, dep) => {\n    const key = hasSchemaDir && dep.specKey ? dep.specKey : 'default';\n\n    if (\n      dep.values &&\n      (isAllowSyntheticDefaultImports || !dep.syntheticDefaultImport)\n    ) {\n      acc[key] = {\n        ...acc[key],\n        values: [...(acc[key]?.values ?? []), dep],\n      };\n\n      return acc;\n    }\n\n    acc[key] = {\n      ...acc[key],\n      types: [...(acc[key]?.types ?? []), dep],\n    };\n\n    return acc;\n  }, {});\n\n  return (\n    Object.entries(groupedBySpecKey)\n      .map(([key, { values, types }]) => {\n        let dep = '';\n\n        if (values) {\n          dep += generateDependency({\n            deps: values,\n            isAllowSyntheticDefaultImports,\n            dependency,\n            specsName,\n            key,\n            onlyTypes: false,\n          });\n        }\n\n        if (types) {\n          let uniqueTypes = types;\n          if (values) {\n            uniqueTypes = types.filter(\n              (t) => !values.some((v) => v.name === t.name),\n            );\n            dep += '\\n';\n          }\n          dep += generateDependency({\n            deps: uniqueTypes,\n            isAllowSyntheticDefaultImports,\n            dependency,\n            specsName,\n            key,\n            onlyTypes: true,\n          });\n        }\n\n        return dep;\n      })\n      .join('\\n') + '\\n'\n  );\n};\n\nconst getLibName = (code: string) => {\n  const splitString = code.split(' from ');\n  return splitString[splitString.length - 1].split(';')[0].trim();\n};\n\nexport const generateDependencyImports = (\n  implementation: string,\n  imports: {\n    exports: GeneratorImport[];\n    dependency: string;\n  }[],\n  specsName: Record<string, string>,\n  hasSchemaDir: boolean,\n  isAllowSyntheticDefaultImports: boolean,\n): string => {\n  const dependencies = imports\n    .map((dep) =>\n      addDependency({\n        ...dep,\n        implementation,\n        specsName,\n        hasSchemaDir,\n        isAllowSyntheticDefaultImports,\n      }),\n    )\n    .filter(Boolean)\n    .sort((a, b) => {\n      const aLib = getLibName(a!);\n      const bLib = getLibName(b!);\n\n      if (aLib === bLib) {\n        return 0;\n      }\n\n      if (aLib.startsWith(\"'.\") && !bLib.startsWith(\"'.\")) {\n        return 1;\n      }\n      return aLib < bLib ? -1 : 1;\n    })\n    .join('\\n');\n\n  return dependencies ? dependencies + '\\n' : '';\n};\n\nexport const generateVerbImports = ({\n  response,\n  body,\n  queryParams,\n  props,\n  headers,\n  params,\n}: GeneratorVerbOptions): GeneratorImport[] => [\n  ...response.imports,\n  ...body.imports,\n  ...props.flatMap((prop) =>\n    prop.type === GetterPropType.NAMED_PATH_PARAMS\n      ? [{ name: prop.schema.name }]\n      : [],\n  ),\n  ...(queryParams ? [{ name: queryParams.schema.name }] : []),\n  ...(headers ? [{ name: headers.schema.name }] : []),\n  ...params.flatMap<GeneratorImport>(({ imports }) => imports),\n];\n","import type { GeneratorSchema } from '../types';\n\nexport const generateModelInline = (acc: string, model: string): string =>\n  acc + `${model}\\n`;\n\nexport const generateModelsInline = (\n  obj: Record<string, GeneratorSchema[]>,\n): string => {\n  const schemas = Object.values(obj).flat();\n\n  return schemas.reduce<string>(\n    (acc, { model }) => generateModelInline(acc, model),\n    '',\n  );\n};\n","import { type ecmaVersion, Parser } from 'acorn';\nimport chalk from 'chalk';\nimport fs from 'fs-extra';\n\nimport type {\n  GeneratorMutator,\n  GeneratorMutatorParsingInfo,\n  NormalizedMutator,\n  Tsconfig,\n  TsConfigTarget,\n} from '../types';\nimport { createLogger, getFileInfo, loadFile, pascal, upath } from '../utils';\n\nexport const BODY_TYPE_NAME = 'BodyType';\n\nconst getImport = (output: string, mutator: NormalizedMutator) => {\n  const outputFileInfo = getFileInfo(output);\n  const mutatorFileInfo = getFileInfo(mutator.path);\n  const { pathWithoutExtension } = getFileInfo(\n    upath.relativeSafe(outputFileInfo.dirname, mutatorFileInfo.path),\n  );\n\n  return `${pathWithoutExtension}${mutator.extension || ''}`;\n};\n\nexport const generateMutator = async ({\n  output,\n  mutator,\n  name,\n  workspace,\n  tsconfig,\n}: {\n  output?: string;\n  mutator?: NormalizedMutator;\n  name: string;\n  workspace: string;\n  tsconfig?: Tsconfig;\n}): Promise<GeneratorMutator | undefined> => {\n  if (!mutator || !output) {\n    return;\n  }\n  const isDefault = mutator.default;\n  const importName = mutator.name ? mutator.name : `${name}Mutator`;\n  const importPath = mutator.path;\n\n  let rawFile = await fs.readFile(importPath, 'utf8');\n\n  rawFile = removeComments(rawFile);\n\n  const hasErrorType =\n    rawFile.includes('export type ErrorType') ||\n    rawFile.includes('export interface ErrorType');\n\n  const hasBodyType =\n    rawFile.includes(`export type ${BODY_TYPE_NAME}`) ||\n    rawFile.includes(`export interface ${BODY_TYPE_NAME}`);\n\n  const errorTypeName = mutator.default\n    ? `${pascal(name)}ErrorType`\n    : 'ErrorType';\n\n  const bodyTypeName = mutator.default\n    ? `${pascal(name)}${BODY_TYPE_NAME}`\n    : BODY_TYPE_NAME;\n\n  const { file, cached } = await loadFile<string>(importPath, {\n    isDefault: false,\n    root: workspace,\n    alias: mutator.alias,\n    tsconfig,\n    load: false,\n  });\n\n  if (file) {\n    const mutatorInfoName = isDefault ? 'default' : mutator.name!;\n\n    const mutatorInfo = parseFile(\n      file,\n      mutatorInfoName,\n      getEcmaVersion(tsconfig?.compilerOptions?.target),\n    );\n\n    if (!mutatorInfo) {\n      throw new Error(\n        chalk.red(\n          `Your mutator file doesn't have the ${mutatorInfoName} exported function`,\n        ),\n      );\n    }\n\n    const path = getImport(output, mutator);\n\n    const isHook = mutator.name\n      ? !!mutator.name.startsWith('use') && !mutatorInfo.numberOfParams\n      : !mutatorInfo.numberOfParams;\n\n    return {\n      name: mutator.name || !isHook ? importName : `use${pascal(importName)}`,\n      path,\n      default: isDefault,\n      hasErrorType,\n      errorTypeName,\n      hasSecondArg: isHook\n        ? mutatorInfo.returnNumberOfParams! > 1\n        : mutatorInfo.numberOfParams > 1,\n      hasThirdArg: mutatorInfo.numberOfParams > 2,\n      isHook,\n      ...(hasBodyType ? { bodyTypeName } : {}),\n    };\n  } else {\n    const path = getImport(output, mutator);\n\n    if (!cached) {\n      createLogger().warn(\n        chalk.yellow(`Failed to parse provided mutator function`),\n      );\n    }\n\n    return {\n      name: importName,\n      path,\n      default: isDefault,\n      hasSecondArg: false,\n      hasThirdArg: false,\n      isHook: false,\n      hasErrorType,\n      errorTypeName,\n      ...(hasBodyType ? { bodyTypeName } : {}),\n    };\n  }\n};\n\nconst getEcmaVersion = (target?: TsConfigTarget): ecmaVersion | undefined => {\n  if (!target) {\n    return;\n  }\n\n  if (target.toLowerCase() === 'esnext') {\n    return 'latest';\n  }\n\n  try {\n    return Number(target.toLowerCase().replace('es', '')) as ecmaVersion;\n  } catch {\n    return;\n  }\n};\n\nconst removeComments = (file: string) => {\n  // Regular expression to match single-line and multi-line comments\n  const commentRegex = /\\/\\/.*|\\/\\*[\\s\\S]*?\\*\\//g;\n\n  // Remove comments from the rawFile string\n  const cleanedFile = file.replaceAll(commentRegex, '');\n\n  return cleanedFile;\n};\n\nconst parseFile = (\n  file: string,\n  name: string,\n  ecmaVersion: ecmaVersion = 6,\n): GeneratorMutatorParsingInfo | undefined => {\n  try {\n    const ast = Parser.parse(file, { ecmaVersion }) as any;\n\n    const node = ast?.body?.find((childNode: any) => {\n      if (childNode.type === 'ExpressionStatement') {\n        if (\n          childNode.expression.arguments?.[1]?.properties?.some(\n            (p: any) => p.key?.name === name,\n          )\n        ) {\n          return true;\n        }\n\n        if (childNode.expression.left?.property?.name === name) {\n          return true;\n        }\n\n        return childNode.expression.right?.properties?.some(\n          (p: any) => p.key.name === name,\n        );\n      }\n    });\n\n    if (!node) {\n      return;\n    }\n\n    if (node.expression.type === 'AssignmentExpression') {\n      if (\n        node.expression.right.type === 'FunctionExpression' ||\n        node.expression.right.type === 'ArrowFunctionExpression'\n      ) {\n        return {\n          numberOfParams: node.expression.right.params.length,\n        };\n      }\n\n      if (node.expression.right.name) {\n        return parseFunction(ast, node.expression.right.name);\n      }\n\n      const property = node.expression.right?.properties.find(\n        (p: any) => p.key.name === name,\n      );\n\n      if (property.value.name) {\n        return parseFunction(ast, property.value.name);\n      }\n\n      if (\n        property.value.type === 'FunctionExpression' ||\n        property.value.type === 'ArrowFunctionExpression'\n      ) {\n        return {\n          numberOfParams: property.value.params.length,\n        };\n      }\n\n      return;\n    }\n\n    const property = node.expression.arguments[1].properties.find(\n      (p: any) => p.key?.name === name,\n    );\n\n    return parseFunction(ast, property.value.body.name);\n  } catch {\n    return;\n  }\n};\n\nconst parseFunction = (\n  ast: any,\n  name: string,\n): GeneratorMutatorParsingInfo | undefined => {\n  const node = ast?.body?.find((childNode: any) => {\n    if (childNode.type === 'VariableDeclaration') {\n      return childNode.declarations.find((d: any) => d.id.name === name);\n    }\n    if (\n      childNode.type === 'FunctionDeclaration' &&\n      childNode.id.name === name\n    ) {\n      return childNode;\n    }\n  });\n\n  if (!node) {\n    return;\n  }\n\n  if (node.type === 'FunctionDeclaration') {\n    const returnStatement = node.body?.body?.find(\n      (b: any) => b.type === 'ReturnStatement',\n    );\n\n    // If the function directly returns an arrow function\n    if (returnStatement?.argument?.params) {\n      return {\n        numberOfParams: node.params.length,\n        returnNumberOfParams: returnStatement.argument.params.length,\n      };\n      // If the function returns a CallExpression (e.g., return useCallback(...))\n    } else if (\n      returnStatement?.argument?.type === 'CallExpression' &&\n      returnStatement.argument.arguments?.[0]?.type ===\n        'ArrowFunctionExpression'\n    ) {\n      const arrowFn = returnStatement.argument.arguments[0];\n      return {\n        numberOfParams: node.params.length,\n        returnNumberOfParams: arrowFn.params.length,\n      };\n    }\n    return {\n      numberOfParams: node.params.length,\n    };\n  }\n\n  const declaration = node.declarations.find((d: any) => d.id.name === name);\n\n  if (declaration.init.name) {\n    return parseFunction(ast, declaration.init.name);\n  }\n\n  if (declaration.init.body.type === 'ArrowFunctionExpression') {\n    return {\n      numberOfParams: declaration.init.params.length,\n      returnNumberOfParams: declaration.init.body.params.length,\n    };\n  }\n\n  const returnStatement = declaration.init.body?.body?.find(\n    (b: any) => b.type === 'ReturnStatement',\n  );\n\n  if (returnStatement?.argument?.params) {\n    return {\n      numberOfParams: declaration.init.params.length,\n      returnNumberOfParams: returnStatement.argument.params.length,\n    };\n  } else if (\n    returnStatement?.argument?.type === 'CallExpression' &&\n    returnStatement.argument.arguments?.[0]?.type === 'ArrowFunctionExpression'\n  ) {\n    const arrowFn = returnStatement.argument.arguments[0];\n    return {\n      numberOfParams: declaration.init.params.length,\n      returnNumberOfParams: arrowFn.params.length,\n    };\n  }\n\n  return {\n    numberOfParams: declaration.init.params.length,\n  };\n};\n","import {\n  type GeneratorMutator,\n  type GeneratorSchema,\n  type GetterBody,\n  type GetterQueryParam,\n  type GetterResponse,\n  type ParamsSerializerOptions,\n  Verbs,\n} from '../types';\nimport { getIsBodyVerb, isObject, stringify } from '../utils';\n\nexport const generateBodyOptions = (\n  body: GetterBody,\n  isFormData: boolean,\n  isFormUrlEncoded: boolean,\n) => {\n  if (isFormData && body.formData) {\n    return '\\n      formData,';\n  }\n\n  if (isFormUrlEncoded && body.formUrlEncoded) {\n    return '\\n      formUrlEncoded,';\n  }\n\n  if (body.implementation) {\n    return `\\n      ${body.implementation},`;\n  }\n\n  return '';\n};\n\nexport const generateAxiosOptions = ({\n  response,\n  isExactOptionalPropertyTypes,\n  queryParams,\n  headers,\n  requestOptions,\n  hasSignal,\n  isVue,\n  isAngular,\n  paramsSerializer,\n  paramsSerializerOptions,\n}: {\n  response: GetterResponse;\n  isExactOptionalPropertyTypes: boolean;\n  queryParams?: GeneratorSchema;\n  headers?: GeneratorSchema;\n  requestOptions?: object | boolean;\n  hasSignal: boolean;\n  isVue: boolean;\n  isAngular: boolean;\n  paramsSerializer?: GeneratorMutator;\n  paramsSerializerOptions?: ParamsSerializerOptions;\n}) => {\n  const isRequestOptions = requestOptions !== false;\n  if (\n    !queryParams &&\n    !headers &&\n    !response.isBlob &&\n    response.definition.success !== 'string'\n  ) {\n    if (isRequestOptions) {\n      return 'options';\n    }\n    if (hasSignal) {\n      return isExactOptionalPropertyTypes\n        ? '...(signal ? { signal } : {})'\n        : 'signal';\n    }\n    return '';\n  }\n\n  let value = '';\n\n  if (!isRequestOptions) {\n    if (queryParams) {\n      value += '\\n        params,';\n    }\n\n    if (headers) {\n      value += '\\n        headers,';\n    }\n\n    if (hasSignal) {\n      value += isExactOptionalPropertyTypes\n        ? '\\n        ...(signal ? { signal } : {}),'\n        : '\\n        signal,';\n    }\n  }\n\n  if (\n    !isObject(requestOptions) ||\n    !requestOptions.hasOwnProperty('responseType')\n  ) {\n    if (response.isBlob) {\n      value += `\\n        responseType: 'blob',`;\n    } else if (response.definition.success === 'string') {\n      value += `\\n        responseType: 'text',`;\n    }\n  }\n\n  if (isObject(requestOptions)) {\n    value += `\\n ${stringify(requestOptions)?.slice(1, -1)}`;\n  }\n\n  if (isRequestOptions) {\n    value += '\\n    ...options,';\n\n    if (queryParams) {\n      if (isVue) {\n        value += '\\n        params: {...unref(params), ...options?.params},';\n      } else if (isAngular && paramsSerializer) {\n        value += `\\n        params: ${paramsSerializer.name}({...params, ...options?.params}),`;\n      } else {\n        value += '\\n        params: {...params, ...options?.params},';\n      }\n    }\n\n    if (headers) {\n      value += '\\n        headers: {...headers, ...options?.headers},';\n    }\n  }\n\n  if (\n    !isAngular &&\n    queryParams &&\n    (paramsSerializer || paramsSerializerOptions?.qs)\n  ) {\n    value += paramsSerializer\n      ? `\\n        paramsSerializer: ${paramsSerializer.name},`\n      : `\\n        paramsSerializer: (params) => qs.stringify(params, ${JSON.stringify(\n          paramsSerializerOptions!.qs,\n        )}),`;\n  }\n\n  return value;\n};\n\nexport const generateOptions = ({\n  route,\n  body,\n  headers,\n  queryParams,\n  response,\n  verb,\n  requestOptions,\n  isFormData,\n  isFormUrlEncoded,\n  isAngular,\n  isExactOptionalPropertyTypes,\n  hasSignal,\n  isVue,\n  paramsSerializer,\n  paramsSerializerOptions,\n}: {\n  route: string;\n  body: GetterBody;\n  headers?: GetterQueryParam;\n  queryParams?: GetterQueryParam;\n  response: GetterResponse;\n  verb: Verbs;\n  requestOptions?: object | boolean;\n  isFormData: boolean;\n  isFormUrlEncoded: boolean;\n  isAngular?: boolean;\n  isExactOptionalPropertyTypes: boolean;\n  hasSignal: boolean;\n  isVue?: boolean;\n  paramsSerializer?: GeneratorMutator;\n  paramsSerializerOptions?: ParamsSerializerOptions;\n}) => {\n  const bodyOptions = getIsBodyVerb(verb)\n    ? generateBodyOptions(body, isFormData, isFormUrlEncoded)\n    : '';\n\n  const axiosOptions = generateAxiosOptions({\n    response,\n    queryParams: queryParams?.schema,\n    headers: headers?.schema,\n    requestOptions,\n    isExactOptionalPropertyTypes,\n    hasSignal,\n    isVue: isVue ?? false,\n    isAngular: isAngular ?? false,\n    paramsSerializer,\n    paramsSerializerOptions,\n  });\n\n  const options = axiosOptions ? `{${axiosOptions}}` : '';\n\n  if (verb === Verbs.DELETE) {\n    if (!bodyOptions) {\n      return `\\n      \\`${route}\\`,${\n        axiosOptions === 'options' ? axiosOptions : options\n      }\\n    `;\n    }\n\n    return `\\n      \\`${route}\\`,{${\n      isAngular ? 'body' : 'data'\n    }:${bodyOptions} ${\n      axiosOptions === 'options' ? `...${axiosOptions}` : axiosOptions\n    }}\\n    `;\n  }\n\n  return `\\n      \\`${route}\\`,${\n    getIsBodyVerb(verb) ? bodyOptions || 'undefined,' : ''\n  }${axiosOptions === 'options' ? axiosOptions : options}\\n    `;\n};\n\nexport const generateBodyMutatorConfig = (\n  body: GetterBody,\n  isFormData: boolean,\n  isFormUrlEncoded: boolean,\n) => {\n  if (isFormData && body.formData) {\n    return ',\\n       data: formData';\n  }\n\n  if (isFormUrlEncoded && body.formUrlEncoded) {\n    return ',\\n       data: formUrlEncoded';\n  }\n\n  if (body.implementation) {\n    return `,\\n      data: ${body.implementation}`;\n  }\n\n  return '';\n};\n\nexport const generateQueryParamsAxiosConfig = (\n  response: GetterResponse,\n  isVue: boolean,\n  queryParams?: GetterQueryParam,\n) => {\n  if (!queryParams && !response.isBlob) {\n    return '';\n  }\n\n  let value = '';\n\n  if (queryParams) {\n    value += isVue ? ',\\n        params: unref(params)' : ',\\n        params';\n  }\n\n  if (response.isBlob) {\n    value += `,\\n        responseType: 'blob'`;\n  }\n\n  return value;\n};\n\nexport const generateMutatorConfig = ({\n  route,\n  body,\n  headers,\n  queryParams,\n  response,\n  verb,\n  isFormData,\n  isFormUrlEncoded,\n  hasSignal,\n  isExactOptionalPropertyTypes,\n  isVue,\n}: {\n  route: string;\n  body: GetterBody;\n  headers?: GetterQueryParam;\n  queryParams?: GetterQueryParam;\n  response: GetterResponse;\n  verb: Verbs;\n  isFormData: boolean;\n  isFormUrlEncoded: boolean;\n  hasSignal: boolean;\n  isExactOptionalPropertyTypes: boolean;\n  isVue?: boolean;\n}) => {\n  const bodyOptions = getIsBodyVerb(verb)\n    ? generateBodyMutatorConfig(body, isFormData, isFormUrlEncoded)\n    : '';\n\n  const queryParamsOptions = generateQueryParamsAxiosConfig(\n    response,\n    isVue ?? false,\n    queryParams,\n  );\n\n  const headerOptions = body.contentType\n    ? `,\\n      headers: {'Content-Type': '${body.contentType}', ${\n        headers ? '...headers' : ''\n      }}`\n    : headers\n      ? ',\\n      headers'\n      : '';\n\n  return `{url: \\`${route}\\`, method: '${verb.toUpperCase()}'${headerOptions}${bodyOptions}${queryParamsOptions}${\n    hasSignal\n      ? `, ${\n          isExactOptionalPropertyTypes\n            ? '...(signal ? { signal }: {})'\n            : 'signal'\n        }`\n      : ''\n  }\\n    }`;\n};\n\nexport const generateMutatorRequestOptions = (\n  requestOptions: boolean | object | undefined,\n  hasSecondArgument: boolean,\n) => {\n  if (!hasSecondArgument) {\n    return isObject(requestOptions)\n      ? `{${stringify(requestOptions)?.slice(1, -1)}}`\n      : '';\n  }\n\n  if (isObject(requestOptions)) {\n    return `{${stringify(requestOptions)?.slice(1, -1)} ...options}`;\n  }\n\n  return 'options';\n};\n\nexport const generateFormDataAndUrlEncodedFunction = ({\n  body,\n  formData,\n  formUrlEncoded,\n  isFormData,\n  isFormUrlEncoded,\n}: {\n  body: GetterBody;\n  formData?: GeneratorMutator;\n  formUrlEncoded?: GeneratorMutator;\n  isFormData: boolean;\n  isFormUrlEncoded: boolean;\n}) => {\n  if (isFormData && body.formData) {\n    if (formData) {\n      return `const formData = ${formData.name}(${body.implementation})`;\n    }\n\n    return body.formData;\n  }\n\n  if (isFormUrlEncoded && body.formUrlEncoded) {\n    if (formUrlEncoded) {\n      return `const formUrlEncoded = ${formUrlEncoded.name}(${body.implementation})`;\n    }\n\n    return body.formUrlEncoded;\n  }\n\n  return '';\n};\n","import type { ComponentsObject, ParameterObject } from 'openapi3-ts/oas30';\n\nimport { resolveObject, resolveRef } from '../resolvers';\nimport type { ContextSpecs, GeneratorSchema } from '../types';\nimport { jsDoc, pascal, sanitize } from '../utils';\n\nexport const generateParameterDefinition = (\n  parameters: ComponentsObject['parameters'] = {},\n  context: ContextSpecs,\n  suffix: string,\n): GeneratorSchema[] => {\n  return Object.entries(parameters).reduce<GeneratorSchema[]>(\n    (acc, [parameterName, parameter]) => {\n      const modelName = sanitize(`${pascal(parameterName)}${suffix}`, {\n        underscore: '_',\n        whitespace: '_',\n        dash: true,\n        es5keyword: true,\n        es5IdentifierName: true,\n      });\n      const { schema, imports } = resolveRef<ParameterObject>(\n        parameter,\n        context,\n      );\n\n      if (schema.in !== 'query' && schema.in !== 'header') {\n        return acc;\n      }\n\n      if (!schema.schema || imports.length > 0) {\n        acc.push({\n          name: modelName,\n          imports:\n            imports.length > 0\n              ? [\n                  {\n                    name: imports[0].name,\n                    specKey: imports[0].specKey,\n                    schemaName: imports[0].schemaName,\n                  },\n                ]\n              : [],\n          model: `export type ${modelName} = ${\n            imports.length > 0 ? imports[0].name : 'unknown'\n          };\\n`,\n        });\n\n        return acc;\n      }\n\n      const resolvedObject = resolveObject({\n        schema: schema.schema,\n        propName: modelName,\n        context,\n      });\n\n      const doc = jsDoc(parameter as ParameterObject);\n\n      const model = `${doc}export type ${modelName} = ${\n        resolvedObject.value || 'unknown'\n      };\\n`;\n\n      acc.push(...resolvedObject.schemas);\n\n      if (modelName !== resolvedObject.value) {\n        acc.push({\n          name: modelName,\n          model,\n          imports: resolvedObject.imports,\n        });\n      }\n\n      return acc;\n    },\n    [],\n  );\n};\n","import type { SchemaObject } from 'openapi3-ts/oas30';\n\nimport { getScalar } from '../getters';\nimport type { ContextSpecs } from '../types';\nimport { jsDoc } from '../utils';\n\n/**\n * Generate the interface string\n * An eslint comment is insert if the resulted object is empty\n *\n * @param name interface name\n * @param schema\n */\nexport const generateInterface = ({\n  name,\n  schema,\n  context,\n  suffix,\n}: {\n  name: string;\n  schema: SchemaObject;\n  context: ContextSpecs;\n  suffix: string;\n}) => {\n  const scalar = getScalar({\n    item: schema,\n    name,\n    context,\n  });\n  const isEmptyObject = scalar.value === '{}';\n\n  let model = '';\n\n  model += jsDoc(schema);\n\n  if (isEmptyObject) {\n    model +=\n      '// eslint-disable-next-line @typescript-eslint/no-empty-interface\\n';\n  }\n\n  if (\n    scalar.type === 'object' &&\n    !context?.output.override?.useTypeOverInterfaces\n  ) {\n    if (\n      scalar.type === 'object' &&\n      schema.properties &&\n      Object.values(schema.properties).length > 0 &&\n      Object.values(schema.properties).every((item) => 'const' in item)\n    ) {\n      const mappedScalarValue = scalar.value\n        .replaceAll(';', ',')\n        .replaceAll('?:', ':');\n\n      model += `export const ${name}Value = ${mappedScalarValue} as const;\\nexport type ${name} = typeof ${name}Value;\\n`;\n    } else {\n      const blankInterfaceValue =\n        scalar.value === 'unknown' ? '{}' : scalar.value;\n\n      model += `export interface ${name} ${blankInterfaceValue}\\n`;\n    }\n  } else {\n    model += `export type ${name} = ${scalar.value};\\n`;\n  }\n\n  // Filter out imports that refer to the type defined in current file (OpenAPI recursive schema definitions)\n  const externalModulesImportsOnly = scalar.imports.filter((importName) =>\n    importName.alias ? importName.alias !== name : importName.name !== name,\n  );\n\n  return [\n    ...scalar.schemas,\n    {\n      name,\n      model,\n      imports: externalModulesImportsOnly,\n    },\n  ];\n};\n","import isEmpty from 'lodash.isempty';\nimport type { SchemaObject, SchemasObject } from 'openapi3-ts/oas30';\n\nimport {\n  getEnum,\n  getEnumDescriptions,\n  getEnumNames,\n  resolveDiscriminators,\n} from '../getters';\nimport { resolveRef, resolveValue } from '../resolvers';\nimport type {\n  ContextSpecs,\n  GeneratorSchema,\n  InputFiltersOption,\n} from '../types';\nimport {\n  isReference,\n  isString,\n  jsDoc,\n  pascal,\n  sanitize,\n  upath,\n} from '../utils';\nimport { generateInterface } from './interface';\n\n/**\n * Extract all types from #/components/schemas\n *\n * @param schemas\n */\nexport const generateSchemasDefinition = (\n  schemas: SchemasObject = {},\n  context: ContextSpecs,\n  suffix: string,\n  filters?: InputFiltersOption,\n): GeneratorSchema[] => {\n  if (isEmpty(schemas)) {\n    return [];\n  }\n\n  const transformedSchemas = resolveDiscriminators(schemas, context);\n\n  let generateSchemas = Object.entries(transformedSchemas);\n  if (filters?.schemas) {\n    const schemasFilters = filters.schemas;\n    const mode = filters.mode || 'include';\n\n    generateSchemas = generateSchemas.filter(([schemaName]) => {\n      const isMatch = schemasFilters.some((filter) =>\n        isString(filter) ? filter === schemaName : filter.test(schemaName),\n      );\n\n      return mode === 'include' ? isMatch : !isMatch;\n    });\n  }\n\n  const models = generateSchemas.reduce<GeneratorSchema[]>(\n    (acc, [name, schema]) => {\n      const schemaName = sanitize(`${pascal(name)}${suffix}`, {\n        underscore: '_',\n        whitespace: '_',\n        dash: true,\n        es5keyword: true,\n        es5IdentifierName: true,\n      });\n      if (shouldCreateInterface(schema)) {\n        acc.push(\n          ...generateInterface({\n            name: schemaName,\n            schema,\n            context,\n            suffix,\n          }),\n        );\n\n        return acc;\n      } else {\n        const resolvedValue = resolveValue({\n          schema,\n          name: schemaName,\n          context,\n        });\n\n        let output = '';\n\n        let imports = resolvedValue.imports;\n\n        output += jsDoc(schema);\n\n        if (resolvedValue.isEnum && !resolvedValue.isRef) {\n          output += getEnum(\n            resolvedValue.value,\n            schemaName,\n            getEnumNames(resolvedValue.originalSchema),\n            context.output.override.enumGenerationType,\n            getEnumDescriptions(resolvedValue.originalSchema),\n            context.output.override.namingConvention?.enum,\n          );\n        } else if (schemaName === resolvedValue.value && resolvedValue.isRef) {\n          // Don't add type if schema has same name and the referred schema will be an interface\n          const { schema: referredSchema } = resolveRef(schema, context);\n          if (!shouldCreateInterface(referredSchema as SchemaObject)) {\n            const imp = resolvedValue.imports.find(\n              (imp) => imp.name === schemaName,\n            );\n\n            if (imp) {\n              const alias = imp?.specKey\n                ? `${pascal(upath.getSpecName(imp.specKey, context.specKey))}${\n                    resolvedValue.value\n                  }`\n                : `${resolvedValue.value}Bis`;\n\n              output += `export type ${schemaName} = ${alias};\\n`;\n\n              imports = imports.map((imp) =>\n                imp.name === schemaName ? { ...imp, alias } : imp,\n              );\n            } else {\n              output += `export type ${schemaName} = ${resolvedValue.value};\\n`;\n            }\n          }\n        } else {\n          resolvedValue.schemas = resolvedValue.schemas.filter((schema) => {\n            if (schema.name !== schemaName) {\n              return true;\n            }\n\n            output += `${schema.model}\\n`;\n            imports = imports.concat(schema.imports);\n\n            return false;\n          });\n          output += `export type ${schemaName} = ${resolvedValue.value};\\n`;\n        }\n\n        acc.push(...resolvedValue.schemas, {\n          name: schemaName,\n          model: output,\n          imports,\n        });\n\n        return acc;\n      }\n    },\n    [],\n  );\n\n  return models;\n};\n\nfunction shouldCreateInterface(schema: SchemaObject) {\n  return (\n    (!schema.type || schema.type === 'object') &&\n    !schema.allOf &&\n    !schema.oneOf &&\n    !schema.anyOf &&\n    !isReference(schema) &&\n    !schema.nullable &&\n    !schema.enum\n  );\n}\n","import type {\n  ComponentsObject,\n  OperationObject,\n  ParameterObject,\n  PathItemObject,\n  ReferenceObject,\n} from 'openapi3-ts/oas30';\n\nimport {\n  getBody,\n  getOperationId,\n  getParameters,\n  getParams,\n  getProps,\n  getQueryParams,\n  getResponse,\n} from '../getters';\nimport type {\n  ContextSpecs,\n  GeneratorVerbOptions,\n  GeneratorVerbsOptions,\n  NormalizedInputOptions,\n  NormalizedMutator,\n  NormalizedOperationOptions,\n  NormalizedOutputOptions,\n  Verbs,\n} from '../types';\nimport {\n  asyncReduce,\n  camel,\n  dynamicImport,\n  isObject,\n  isString,\n  isVerb,\n  jsDoc,\n  mergeDeep,\n  sanitize,\n} from '../utils';\nimport { generateMutator } from './mutator';\n\nconst generateVerbOptions = async ({\n  verb,\n  output,\n  operation,\n  route,\n  pathRoute,\n  verbParameters = [],\n  context,\n}: {\n  verb: Verbs;\n  output: NormalizedOutputOptions;\n  operation: OperationObject;\n  route: string;\n  pathRoute: string;\n  verbParameters?: (ReferenceObject | ParameterObject)[];\n  components?: ComponentsObject;\n  context: ContextSpecs;\n}): Promise<GeneratorVerbOptions> => {\n  const {\n    responses,\n    requestBody,\n    parameters: operationParameters,\n    tags = [],\n    deprecated,\n    description,\n    summary,\n  } = operation;\n  const operationId = getOperationId(operation, route, verb);\n  const overrideOperation = output.override.operations[operation.operationId!];\n  const overrideTag = Object.entries(\n    output.override.tags,\n  ).reduce<NormalizedOperationOptions>(\n    (acc, [tag, options]) =>\n      tags.includes(tag) ? mergeDeep(acc, options) : acc,\n    {},\n  );\n\n  const override = mergeDeep(\n    mergeDeep(output.override, overrideTag),\n    overrideOperation,\n  );\n\n  const overrideOperationName =\n    overrideOperation?.operationName || output.override?.operationName;\n  const operationName = overrideOperationName\n    ? overrideOperationName(operation, route, verb)\n    : sanitize(camel(operationId), { es5keyword: true });\n\n  const response = getResponse({\n    responses,\n    operationName,\n    context,\n    contentType: override.contentType,\n  });\n\n  const body = getBody({\n    requestBody: requestBody!,\n    operationName,\n    context,\n    contentType: override.contentType,\n  });\n\n  const parameters = getParameters({\n    parameters: [...verbParameters, ...(operationParameters ?? [])],\n    context,\n  });\n\n  const queryParams = getQueryParams({\n    queryParams: parameters.query,\n    operationName,\n    context,\n  });\n\n  const headers = output.headers\n    ? await getQueryParams({\n        queryParams: parameters.header,\n        operationName,\n        context,\n        suffix: 'headers',\n      })\n    : undefined;\n\n  const params = getParams({\n    route,\n    pathParams: parameters.path,\n    operationId: operationId!,\n    context,\n    output,\n  });\n\n  const props = getProps({\n    body,\n    queryParams,\n    params,\n    headers,\n    operationName,\n    context,\n  });\n\n  const mutator = await generateMutator({\n    output: output.target,\n    name: operationName,\n    mutator: override?.mutator,\n    workspace: context.workspace,\n    tsconfig: context.output.tsconfig,\n  });\n\n  const formData =\n    !override.formData.disabled && body.formData\n      ? await generateMutator({\n          output: output.target,\n          name: operationName,\n          mutator: override.formData.mutator,\n          workspace: context.workspace,\n          tsconfig: context.output.tsconfig,\n        })\n      : undefined;\n\n  const formUrlEncoded =\n    isString(override?.formUrlEncoded) || isObject(override?.formUrlEncoded)\n      ? await generateMutator({\n          output: output.target,\n          name: operationName,\n          mutator: override.formUrlEncoded,\n          workspace: context.workspace,\n          tsconfig: context.output.tsconfig,\n        })\n      : undefined;\n\n  const paramsSerializer =\n    isString(override?.paramsSerializer) || isObject(override?.paramsSerializer)\n      ? await generateMutator({\n          output: output.target,\n          name: 'paramsSerializer',\n          mutator: override.paramsSerializer as NormalizedMutator,\n          workspace: context.workspace,\n          tsconfig: context.output.tsconfig,\n        })\n      : undefined;\n\n  const fetchReviver =\n    isString(override?.fetch.jsonReviver) ||\n    isObject(override?.fetch.jsonReviver)\n      ? await generateMutator({\n          output: output.target,\n          name: 'fetchReviver',\n          mutator: override.fetch.jsonReviver as NormalizedMutator,\n          workspace: context.workspace,\n          tsconfig: context.output.tsconfig,\n        })\n      : undefined;\n  const doc = jsDoc({ description, deprecated, summary });\n\n  const verbOption: GeneratorVerbOptions = {\n    verb: verb as Verbs,\n    tags,\n    route,\n    pathRoute,\n    summary: operation.summary,\n    operationId: operationId!,\n    operationName,\n    response,\n    body,\n    headers,\n    queryParams,\n    params,\n    props,\n    mutator,\n    formData,\n    formUrlEncoded,\n    paramsSerializer,\n    fetchReviver,\n    override,\n    doc,\n    deprecated,\n    originalOperation: operation,\n  };\n\n  const transformer = await dynamicImport(\n    override?.transformer,\n    context.workspace,\n  );\n\n  return transformer ? transformer(verbOption) : verbOption;\n};\n\nexport const generateVerbsOptions = ({\n  verbs,\n  input,\n  output,\n  route,\n  pathRoute,\n  context,\n}: {\n  verbs: PathItemObject;\n  input: NormalizedInputOptions;\n  output: NormalizedOutputOptions;\n  route: string;\n  pathRoute: string;\n  context: ContextSpecs;\n}): Promise<GeneratorVerbsOptions> =>\n  asyncReduce(\n    _filteredVerbs(verbs, input.filters),\n    async (acc, [verb, operation]: [string, OperationObject]) => {\n      if (isVerb(verb)) {\n        const verbOptions = await generateVerbOptions({\n          verb,\n          output,\n          verbParameters: verbs.parameters,\n          route,\n          pathRoute,\n          operation,\n          context,\n        });\n\n        acc.push(verbOptions);\n      }\n\n      return acc;\n    },\n    [] as GeneratorVerbsOptions,\n  );\n\nexport const _filteredVerbs = (\n  verbs: PathItemObject,\n  filters: NormalizedInputOptions['filters'],\n) => {\n  if (filters?.tags === undefined) {\n    return Object.entries(verbs);\n  }\n\n  const filterTags = filters.tags || [];\n  const filterMode = filters.mode || 'include';\n\n  return Object.entries(verbs).filter(\n    ([_verb, operation]: [string, OperationObject]) => {\n      const operationTags = operation.tags || [];\n\n      const isMatch = operationTags.some((tag) =>\n        filterTags.some((filterTag) =>\n          filterTag instanceof RegExp ? filterTag.test(tag) : filterTag === tag,\n        ),\n      );\n\n      return filterMode === 'exclude' ? !isMatch : isMatch;\n    },\n  );\n};\n","import fs from 'fs-extra';\n\nimport { generateImports } from '../generators';\nimport { type GeneratorSchema, NamingConvention } from '../types';\nimport { conventionName, upath } from '../utils';\n\nconst getSchema = ({\n  schema: { imports, model },\n  target,\n  isRootKey,\n  specsName,\n  header,\n  specKey,\n  namingConvention = NamingConvention.CAMEL_CASE,\n}: {\n  schema: GeneratorSchema;\n  target: string;\n  isRootKey: boolean;\n  specsName: Record<string, string>;\n  header: string;\n  specKey: string;\n  namingConvention?: NamingConvention;\n}): string => {\n  let file = header;\n  file += generateImports({\n    imports: imports.filter(\n      (imp) =>\n        !model.includes(`type ${imp.alias || imp.name} =`) &&\n        !model.includes(`interface ${imp.alias || imp.name} {`),\n    ),\n    target,\n    isRootKey,\n    specsName,\n    specKey,\n    namingConvention,\n  });\n  file += imports.length > 0 ? '\\n\\n' : '\\n';\n  file += model;\n  return file;\n};\n\nconst getPath = (path: string, name: string, fileExtension: string): string =>\n  upath.join(path, `/${name}${fileExtension}`);\n\nexport const writeModelInline = (acc: string, model: string): string =>\n  acc + `${model}\\n`;\n\nexport const writeModelsInline = (array: GeneratorSchema[]): string =>\n  array.reduce((acc, { model }) => writeModelInline(acc, model), '');\n\nexport const writeSchema = async ({\n  path,\n  schema,\n  target,\n  namingConvention,\n  fileExtension,\n  specKey,\n  isRootKey,\n  specsName,\n  header,\n}: {\n  path: string;\n  schema: GeneratorSchema;\n  target: string;\n  namingConvention: NamingConvention;\n  fileExtension: string;\n  specKey: string;\n  isRootKey: boolean;\n  specsName: Record<string, string>;\n  header: string;\n}) => {\n  const name = conventionName(schema.name, namingConvention);\n\n  try {\n    await fs.outputFile(\n      getPath(path, name, fileExtension),\n      getSchema({\n        schema,\n        target,\n        isRootKey,\n        specsName,\n        header,\n        specKey,\n        namingConvention,\n      }),\n    );\n  } catch (error) {\n    throw new Error(\n      `Oups... 🍻. An Error occurred while writing schema ${name} => ${error}`,\n    );\n  }\n};\n\nexport const writeSchemas = async ({\n  schemaPath,\n  schemas,\n  target,\n  namingConvention,\n  fileExtension,\n  specKey,\n  isRootKey,\n  specsName,\n  header,\n  indexFiles,\n}: {\n  schemaPath: string;\n  schemas: GeneratorSchema[];\n  target: string;\n  namingConvention: NamingConvention;\n  fileExtension: string;\n  specKey: string;\n  isRootKey: boolean;\n  specsName: Record<string, string>;\n  header: string;\n  indexFiles: boolean;\n}) => {\n  await Promise.all(\n    schemas.map((schema) =>\n      writeSchema({\n        path: schemaPath,\n        schema,\n        target,\n        namingConvention,\n        fileExtension,\n        specKey,\n        isRootKey,\n        specsName,\n        header,\n      }),\n    ),\n  );\n\n  if (indexFiles) {\n    const schemaFilePath = upath.join(schemaPath, `/index${fileExtension}`);\n    await fs.ensureFile(schemaFilePath);\n\n    // Ensure separate files are used for parallel schema writing.\n    // Throw an exception, which list all duplicates, before attempting\n    // multiple writes on the same file.\n    const schemaNamesSet = new Set<string>();\n    const duplicateNamesMap = new Map<string, number>();\n    for (const schema of schemas) {\n      if (schemaNamesSet.has(schema.name)) {\n        duplicateNamesMap.set(\n          schema.name,\n          (duplicateNamesMap.get(schema.name) || 1) + 1,\n        );\n      } else {\n        schemaNamesSet.add(schema.name);\n      }\n    }\n    if (duplicateNamesMap.size > 0) {\n      throw new Error(\n        'Duplicate schema names detected:\\n' +\n          [...duplicateNamesMap]\n            .map((duplicate) => `  ${duplicate[1]}x ${duplicate[0]}`)\n            .join('\\n'),\n      );\n    }\n\n    try {\n      const data = await fs.readFile(schemaFilePath);\n\n      const stringData = data.toString();\n\n      const ext = fileExtension.endsWith('.ts')\n        ? fileExtension.slice(0, -3)\n        : fileExtension;\n\n      const importStatements = schemas\n        .filter((schema) => {\n          const name = conventionName(schema.name, namingConvention);\n\n          return (\n            !stringData.includes(`export * from './${name}${ext}'`) &&\n            !stringData.includes(`export * from \"./${name}${ext}\"`)\n          );\n        })\n        .map(\n          (schema) =>\n            `export * from './${conventionName(schema.name, namingConvention)}${ext}';`,\n        );\n\n      const currentFileExports = (stringData\n        .match(/export \\* from(.*)('|\")/g)\n        ?.map((s) => s + ';') ?? []) as string[];\n\n      const exports = [...currentFileExports, ...importStatements]\n        .sort()\n        .join('\\n');\n\n      const fileContent = `${header}\\n${exports}`;\n\n      await fs.writeFile(schemaFilePath, fileContent);\n    } catch (error) {\n      throw new Error(\n        `Oups... 🍻. An Error occurred while writing schema index file ${schemaFilePath} => ${error}`,\n      );\n    }\n  }\n};\n","import uniqBy from 'lodash.uniqby';\n\nimport type { GeneratorImport, NormalizedOutputOptions } from '../types';\nimport { conventionName, upath } from '../utils';\n\nexport const generateImportsForBuilder = (\n  output: NormalizedOutputOptions,\n  imports: GeneratorImport[],\n  relativeSchemasPath: string,\n) => {\n  return output.schemas && !output.indexFiles\n    ? uniqBy(imports, 'name').map((i) => {\n        const name = conventionName(i.name, output.namingConvention);\n        return {\n          exports: [i],\n          dependency: upath.joinSafe(relativeSchemasPath, name),\n        };\n      })\n    : [{ exports: imports, dependency: relativeSchemasPath }];\n};\n","import {\n  type GeneratorTarget,\n  type GeneratorTargetFull,\n  type NormalizedOutputOptions,\n  OutputClient,\n  type WriteSpecsBuilder,\n} from '../types';\nimport { compareVersions, pascal } from '../utils';\n\nexport const generateTarget = (\n  builder: WriteSpecsBuilder,\n  options: NormalizedOutputOptions,\n): GeneratorTarget => {\n  const operationNames = Object.values(builder.operations).map(\n    ({ operationName }) => operationName,\n  );\n  const isAngularClient = options?.client === OutputClient.ANGULAR;\n\n  const titles = builder.title({\n    outputClient: options.client,\n    title: pascal(builder.info.title),\n    customTitleFunc: options.override.title,\n    output: options,\n  });\n\n  const target = Object.values(builder.operations).reduce<\n    Required<GeneratorTargetFull>\n  >(\n    (acc, operation, index, arr) => {\n      acc.imports.push(...operation.imports);\n      acc.importsMock.push(...operation.importsMock);\n      acc.implementation += operation.implementation + '\\n';\n      acc.implementationMock.function += operation.implementationMock.function;\n      acc.implementationMock.handler += operation.implementationMock.handler;\n\n      const handlerNameSeparator =\n        acc.implementationMock.handlerName.length > 0 ? ',\\n  ' : '  ';\n      acc.implementationMock.handlerName +=\n        handlerNameSeparator + operation.implementationMock.handlerName + '()';\n\n      if (operation.mutator) {\n        acc.mutators.push(operation.mutator);\n      }\n\n      if (operation.formData) {\n        acc.formData.push(operation.formData);\n      }\n      if (operation.formUrlEncoded) {\n        acc.formUrlEncoded.push(operation.formUrlEncoded);\n      }\n      if (operation.paramsSerializer) {\n        acc.paramsSerializer.push(operation.paramsSerializer);\n      }\n\n      if (operation.clientMutators) {\n        acc.clientMutators.push(...operation.clientMutators);\n      }\n\n      if (operation.fetchReviver) {\n        acc.fetchReviver.push(operation.fetchReviver);\n      }\n\n      if (index === arr.length - 1) {\n        const isMutator = acc.mutators.some((mutator) =>\n          isAngularClient ? mutator.hasThirdArg : mutator.hasSecondArg,\n        );\n\n        const typescriptVersion =\n          options.packageJson?.dependencies?.typescript ??\n          options.packageJson?.devDependencies?.typescript ??\n          '4.4.0';\n\n        const hasAwaitedType = compareVersions(typescriptVersion, '4.5.0');\n\n        const header = builder.header({\n          outputClient: options.client,\n          isRequestOptions: options.override.requestOptions !== false,\n          isMutator,\n          isGlobalMutator: !!options.override.mutator,\n          provideIn: options.override.angular.provideIn,\n          hasAwaitedType,\n          titles,\n          output: options,\n          verbOptions: builder.verbOptions,\n          clientImplementation: acc.implementation,\n        });\n\n        acc.implementation = header.implementation + acc.implementation;\n        acc.implementationMock.handler =\n          acc.implementationMock.handler +\n          header.implementationMock +\n          acc.implementationMock.handlerName;\n\n        const footer = builder.footer({\n          outputClient: options?.client,\n          operationNames,\n          hasMutator: acc.mutators.length > 0,\n          hasAwaitedType,\n          titles,\n          output: options,\n        });\n        acc.implementation += footer.implementation;\n        acc.implementationMock.handler += footer.implementationMock;\n      }\n      return acc;\n    },\n    {\n      imports: [],\n      implementation: '',\n      implementationMock: {\n        function: '',\n        handler: '',\n        handlerName: '',\n      },\n      importsMock: [],\n      mutators: [],\n      clientMutators: [],\n      formData: [],\n      formUrlEncoded: [],\n      paramsSerializer: [],\n      fetchReviver: [],\n    },\n  );\n\n  return {\n    ...target,\n    implementationMock:\n      target.implementationMock.function + target.implementationMock.handler,\n  };\n};\n","export const getOrvalGeneratedTypes = () => `\n// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497\ntype IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <\nT,\n>() => T extends Y ? 1 : 2\n? A\n: B;\n\ntype WritableKeys<T> = {\n[P in keyof T]-?: IfEquals<\n  { [Q in P]: T[P] },\n  { -readonly [Q in P]: T[P] },\n  P\n>;\n}[keyof T];\n\ntype UnionToIntersection<U> =\n  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;\ntype DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;\n\ntype Writable<T> = Pick<T, WritableKeys<T>>;\ntype NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {\n  [P in keyof Writable<T>]: T[P] extends object\n    ? NonReadonly<NonNullable<T[P]>>\n    : T[P];\n} : DistributeReadOnlyOverUnions<T>;\n`;\n\nexport const getTypedResponse = () => `\ninterface TypedResponse<T> extends Response {\n  json(): Promise<T>;\n}\n`;\n","import fs from 'fs-extra';\n\nimport { generateModelsInline, generateMutatorImports } from '../generators';\nimport type { WriteModeProps } from '../types';\nimport {\n  conventionName,\n  getFileInfo,\n  isFunction,\n  isSyntheticDefaultImportsAllow,\n  upath,\n} from '../utils';\nimport { generateImportsForBuilder } from './generate-imports-for-builder';\nimport { generateTarget } from './target';\nimport { getOrvalGeneratedTypes, getTypedResponse } from './types';\n\nexport const writeSingleMode = async ({\n  builder,\n  output,\n  specsName,\n  header,\n  needSchema,\n}: WriteModeProps): Promise<string[]> => {\n  try {\n    const { path, dirname } = getFileInfo(output.target, {\n      backupFilename: conventionName(\n        builder.info.title,\n        output.namingConvention,\n      ),\n      extension: output.fileExtension,\n    });\n\n    const {\n      imports,\n      importsMock,\n      implementation,\n      implementationMock,\n      mutators,\n      clientMutators,\n      formData,\n      formUrlEncoded,\n      paramsSerializer,\n      fetchReviver,\n    } = generateTarget(builder, output);\n\n    let data = header;\n\n    const schemasPath = output.schemas\n      ? upath.relativeSafe(\n          dirname,\n          getFileInfo(output.schemas, { extension: output.fileExtension })\n            .dirname,\n        )\n      : undefined;\n\n    const isAllowSyntheticDefaultImports = isSyntheticDefaultImportsAllow(\n      output.tsconfig,\n    );\n\n    const importsForBuilder = schemasPath\n      ? generateImportsForBuilder(\n          output,\n          imports.filter(\n            (imp) => !importsMock.some((impMock) => imp.name === impMock.name),\n          ),\n          schemasPath,\n        )\n      : [];\n\n    data += builder.imports({\n      client: output.client,\n      implementation,\n      imports: importsForBuilder,\n      specsName,\n      hasSchemaDir: !!output.schemas,\n      isAllowSyntheticDefaultImports,\n      hasGlobalMutator: !!output.override.mutator,\n      hasTagsMutator: Object.values(output.override.tags).some(\n        (tag) => !!tag.mutator,\n      ),\n      hasParamsSerializerOptions: !!output.override.paramsSerializerOptions,\n      packageJson: output.packageJson,\n      output,\n    });\n\n    if (output.mock) {\n      const importsMockForBuilder = schemasPath\n        ? generateImportsForBuilder(output, importsMock, schemasPath)\n        : [];\n      data += builder.importsMock({\n        implementation: implementationMock,\n        imports: importsMockForBuilder,\n        specsName,\n        hasSchemaDir: !!output.schemas,\n        isAllowSyntheticDefaultImports,\n        options: isFunction(output.mock) ? undefined : output.mock,\n      });\n    }\n\n    if (mutators) {\n      data += generateMutatorImports({ mutators, implementation });\n    }\n\n    if (clientMutators) {\n      data += generateMutatorImports({ mutators: clientMutators });\n    }\n\n    if (formData) {\n      data += generateMutatorImports({ mutators: formData });\n    }\n\n    if (formUrlEncoded) {\n      data += generateMutatorImports({ mutators: formUrlEncoded });\n    }\n\n    if (paramsSerializer) {\n      data += generateMutatorImports({ mutators: paramsSerializer });\n    }\n\n    if (fetchReviver) {\n      data += generateMutatorImports({ mutators: fetchReviver });\n    }\n\n    if (implementation.includes('NonReadonly<')) {\n      data += getOrvalGeneratedTypes();\n      data += '\\n';\n    }\n\n    if (implementation.includes('TypedResponse<')) {\n      data += getTypedResponse();\n      data += '\\n';\n    }\n\n    if (!output.schemas && needSchema) {\n      data += generateModelsInline(builder.schemas);\n    }\n\n    data += `${implementation.trim()}\\n`;\n\n    if (output.mock) {\n      data += '\\n\\n';\n      data += implementationMock;\n    }\n\n    await fs.outputFile(path, data);\n\n    return [path];\n  } catch (error) {\n    throw new Error(\n      `Oups... 🍻. An Error occurred while writing file => ${error}`,\n    );\n  }\n};\n","import fs from 'fs-extra';\n\nimport { generateModelsInline, generateMutatorImports } from '../generators';\nimport { OutputClient, type WriteModeProps } from '../types';\nimport {\n  conventionName,\n  getFileInfo,\n  isFunction,\n  isSyntheticDefaultImportsAllow,\n  upath,\n} from '../utils';\nimport { getMockFileExtensionByTypeName } from '../utils/file-extensions';\nimport { generateImportsForBuilder } from './generate-imports-for-builder';\nimport { generateTarget } from './target';\nimport { getOrvalGeneratedTypes, getTypedResponse } from './types';\n\nexport const writeSplitMode = async ({\n  builder,\n  output,\n  specsName,\n  header,\n  needSchema,\n}: WriteModeProps): Promise<string[]> => {\n  try {\n    const { filename, dirname, extension } = getFileInfo(output.target, {\n      backupFilename: conventionName(\n        builder.info.title,\n        output.namingConvention,\n      ),\n      extension: output.fileExtension,\n    });\n\n    const {\n      imports,\n      implementation,\n      implementationMock,\n      importsMock,\n      mutators,\n      clientMutators,\n      formData,\n      formUrlEncoded,\n      paramsSerializer,\n      fetchReviver,\n    } = generateTarget(builder, output);\n\n    let implementationData = header;\n    let mockData = header;\n\n    const relativeSchemasPath = output.schemas\n      ? upath.relativeSafe(\n          dirname,\n          getFileInfo(output.schemas, { extension: output.fileExtension })\n            .dirname,\n        )\n      : './' + filename + '.schemas';\n\n    const isAllowSyntheticDefaultImports = isSyntheticDefaultImportsAllow(\n      output.tsconfig,\n    );\n\n    const importsForBuilder = generateImportsForBuilder(\n      output,\n      imports,\n      relativeSchemasPath,\n    );\n\n    implementationData += builder.imports({\n      client: output.client,\n      implementation,\n      imports: importsForBuilder,\n      specsName,\n      hasSchemaDir: !!output.schemas,\n      isAllowSyntheticDefaultImports,\n      hasGlobalMutator: !!output.override.mutator,\n      hasTagsMutator: Object.values(output.override.tags).some(\n        (tag) => !!tag.mutator,\n      ),\n      hasParamsSerializerOptions: !!output.override.paramsSerializerOptions,\n      packageJson: output.packageJson,\n      output,\n    });\n\n    const importsMockForBuilder = generateImportsForBuilder(\n      output,\n      importsMock,\n      relativeSchemasPath,\n    );\n\n    mockData += builder.importsMock({\n      implementation: implementationMock,\n      imports: importsMockForBuilder,\n      specsName,\n      hasSchemaDir: !!output.schemas,\n      isAllowSyntheticDefaultImports,\n      options: isFunction(output.mock) ? undefined : output.mock,\n    });\n\n    const schemasPath = output.schemas\n      ? undefined\n      : upath.join(dirname, filename + '.schemas' + extension);\n\n    if (schemasPath && needSchema) {\n      const schemasData = header + generateModelsInline(builder.schemas);\n\n      await fs.outputFile(\n        upath.join(dirname, filename + '.schemas' + extension),\n        schemasData,\n      );\n    }\n\n    if (mutators) {\n      implementationData += generateMutatorImports({\n        mutators,\n        implementation,\n      });\n    }\n\n    if (clientMutators) {\n      implementationData += generateMutatorImports({\n        mutators: clientMutators,\n      });\n    }\n\n    if (formData) {\n      implementationData += generateMutatorImports({ mutators: formData });\n    }\n\n    if (formUrlEncoded) {\n      implementationData += generateMutatorImports({\n        mutators: formUrlEncoded,\n      });\n    }\n\n    if (paramsSerializer) {\n      implementationData += generateMutatorImports({\n        mutators: paramsSerializer,\n      });\n    }\n\n    if (fetchReviver) {\n      implementationData += generateMutatorImports({\n        mutators: fetchReviver,\n      });\n    }\n\n    if (implementation.includes('NonReadonly<')) {\n      implementationData += getOrvalGeneratedTypes();\n      implementationData += '\\n';\n    }\n\n    if (implementation.includes('TypedResponse<')) {\n      implementationData += getTypedResponse();\n      implementationData += '\\n';\n    }\n\n    implementationData += `\\n${implementation}`;\n    mockData += `\\n${implementationMock}`;\n\n    const implementationFilename =\n      filename +\n      (OutputClient.ANGULAR === output.client ? '.service' : '') +\n      extension;\n\n    const implementationPath = upath.join(dirname, implementationFilename);\n    await fs.outputFile(\n      upath.join(dirname, implementationFilename),\n      implementationData,\n    );\n\n    const mockPath = output.mock\n      ? upath.join(\n          dirname,\n          filename +\n            '.' +\n            getMockFileExtensionByTypeName(output.mock) +\n            extension,\n        )\n      : undefined;\n\n    if (mockPath) {\n      await fs.outputFile(mockPath, mockData);\n    }\n\n    return [\n      implementationPath,\n      ...(schemasPath ? [schemasPath] : []),\n      ...(mockPath ? [mockPath] : []),\n    ];\n  } catch (error) {\n    throw new Error(\n      `Oups... 🍻. An Error occurred while splitting => ${error}`,\n    );\n  }\n};\n","import {\n  type GeneratorOperation,\n  type GeneratorTarget,\n  type GeneratorTargetFull,\n  type NormalizedOutputOptions,\n  OutputClient,\n  type WriteSpecsBuilder,\n} from '../types';\nimport { compareVersions, kebab, pascal } from '../utils';\n\nconst addDefaultTagIfEmpty = (operation: GeneratorOperation) => ({\n  ...operation,\n  tags: operation.tags.length > 0 ? operation.tags : ['default'],\n});\n\nconst generateTargetTags = (\n  currentAcc: Record<string, GeneratorTargetFull>,\n  operation: GeneratorOperation,\n): Record<string, GeneratorTargetFull> => {\n  const tag = kebab(operation.tags[0]);\n  const currentOperation = currentAcc[tag];\n\n  if (!currentOperation) {\n    currentAcc[tag] = {\n      imports: operation.imports,\n      importsMock: operation.importsMock,\n      mutators: operation.mutator ? [operation.mutator] : [],\n      clientMutators: operation.clientMutators ?? [],\n      formData: operation.formData ? [operation.formData] : [],\n      formUrlEncoded: operation.formUrlEncoded\n        ? [operation.formUrlEncoded]\n        : [],\n      paramsSerializer: operation.paramsSerializer\n        ? [operation.paramsSerializer]\n        : [],\n      fetchReviver: operation.fetchReviver ? [operation.fetchReviver] : [],\n      implementation: operation.implementation,\n      implementationMock: {\n        function: operation.implementationMock.function,\n        handler: operation.implementationMock.handler,\n        handlerName: '  ' + operation.implementationMock.handlerName + '()',\n      },\n    };\n\n    return currentAcc;\n  }\n\n  currentAcc[tag] = {\n    implementation: currentOperation.implementation + operation.implementation,\n    imports: [...currentOperation.imports, ...operation.imports],\n    importsMock: [...currentOperation.importsMock, ...operation.importsMock],\n    implementationMock: {\n      function:\n        currentOperation.implementationMock.function +\n        operation.implementationMock.function,\n      handler:\n        currentOperation.implementationMock.handler +\n        operation.implementationMock.handler,\n      handlerName:\n        currentOperation.implementationMock.handlerName +\n        ',\\n  ' +\n        operation.implementationMock.handlerName +\n        '()',\n    },\n    mutators: operation.mutator\n      ? [...(currentOperation.mutators ?? []), operation.mutator]\n      : currentOperation.mutators,\n    clientMutators: operation.clientMutators\n      ? [\n          ...(currentOperation.clientMutators ?? []),\n          ...operation.clientMutators,\n        ]\n      : currentOperation.clientMutators,\n    formData: operation.formData\n      ? [...(currentOperation.formData ?? []), operation.formData]\n      : currentOperation.formData,\n    formUrlEncoded: operation.formUrlEncoded\n      ? [...(currentOperation.formUrlEncoded ?? []), operation.formUrlEncoded]\n      : currentOperation.formUrlEncoded,\n    paramsSerializer: operation.paramsSerializer\n      ? [\n          ...(currentOperation.paramsSerializer ?? []),\n          operation.paramsSerializer,\n        ]\n      : currentOperation.paramsSerializer,\n    fetchReviver: operation.fetchReviver\n      ? [...(currentOperation.fetchReviver ?? []), operation.fetchReviver]\n      : currentOperation.fetchReviver,\n  };\n  return currentAcc;\n};\n\nexport const generateTargetForTags = (\n  builder: WriteSpecsBuilder,\n  options: NormalizedOutputOptions,\n) => {\n  const isAngularClient = options.client === OutputClient.ANGULAR;\n\n  const allTargetTags = Object.values(builder.operations)\n    .map(addDefaultTagIfEmpty)\n    .reduce<Record<string, GeneratorTargetFull>>(\n      (acc, operation, index, arr) => {\n        const targetTags = generateTargetTags(acc, operation);\n\n        if (index === arr.length - 1) {\n          return Object.entries(targetTags).reduce<\n            Record<string, GeneratorTargetFull>\n          >((acc, [tag, target]) => {\n            const isMutator = !!target.mutators?.some((mutator) =>\n              isAngularClient ? mutator.hasThirdArg : mutator.hasSecondArg,\n            );\n            const operationNames = Object.values(builder.operations)\n              // Operations can have multiple tags, but they are grouped by the first\n              // tag, therefore we only want to handle the case where the tag\n              // is the first in the list of tags.\n              .filter(({ tags }) => tags.map(kebab).indexOf(kebab(tag)) === 0)\n              .map(({ operationName }) => operationName);\n\n            const typescriptVersion =\n              options.packageJson?.dependencies?.typescript ??\n              options.packageJson?.devDependencies?.typescript ??\n              '4.4.0';\n\n            const hasAwaitedType = compareVersions(typescriptVersion, '4.5.0');\n\n            const titles = builder.title({\n              outputClient: options.client,\n              title: pascal(tag),\n              customTitleFunc: options.override.title,\n              output: options,\n            });\n\n            const footer = builder.footer({\n              outputClient: options?.client,\n              operationNames,\n              hasMutator: !!target.mutators?.length,\n              hasAwaitedType,\n              titles,\n              output: options,\n            });\n\n            const header = builder.header({\n              outputClient: options.client,\n              isRequestOptions: options.override.requestOptions !== false,\n              isMutator,\n              isGlobalMutator: !!options.override.mutator,\n              provideIn: options.override.angular.provideIn,\n              hasAwaitedType,\n              titles,\n              output: options,\n              verbOptions: builder.verbOptions,\n              tag,\n              clientImplementation: target.implementation,\n            });\n\n            acc[tag] = {\n              implementation:\n                header.implementation +\n                target.implementation +\n                footer.implementation,\n              implementationMock: {\n                function: target.implementationMock.function,\n                handler:\n                  target.implementationMock.handler +\n                  header.implementationMock +\n                  target.implementationMock.handlerName +\n                  footer.implementationMock,\n                handlerName: target.implementationMock.handlerName,\n              },\n              imports: target.imports,\n              importsMock: target.importsMock,\n              mutators: target.mutators,\n              clientMutators: target.clientMutators,\n              formData: target.formData,\n              formUrlEncoded: target.formUrlEncoded,\n              paramsSerializer: target.paramsSerializer,\n              fetchReviver: target.fetchReviver,\n            };\n\n            return acc;\n          }, {});\n        }\n\n        return targetTags;\n      },\n      {},\n    );\n\n  return Object.entries(allTargetTags).reduce<Record<string, GeneratorTarget>>(\n    (acc, [tag, target]) => {\n      acc[tag] = {\n        ...target,\n        implementationMock:\n          target.implementationMock.function +\n          target.implementationMock.handler,\n      };\n\n      return acc;\n    },\n    {},\n  );\n};\n","import fs from 'fs-extra';\n\nimport { generateModelsInline, generateMutatorImports } from '../generators';\nimport { OutputClient, type WriteModeProps } from '../types';\nimport {\n  camel,\n  getFileInfo,\n  isFunction,\n  isSyntheticDefaultImportsAllow,\n  pascal,\n  upath,\n} from '../utils';\nimport { getMockFileExtensionByTypeName } from '../utils/file-extensions';\nimport { generateImportsForBuilder } from './generate-imports-for-builder';\nimport { generateTargetForTags } from './target-tags';\nimport { getOrvalGeneratedTypes, getTypedResponse } from './types';\n\nexport const writeSplitTagsMode = async ({\n  builder,\n  output,\n  specsName,\n  header,\n  needSchema,\n}: WriteModeProps): Promise<string[]> => {\n  const { filename, dirname, extension } = getFileInfo(output.target, {\n    backupFilename: camel(builder.info.title),\n    extension: output.fileExtension,\n  });\n\n  const target = generateTargetForTags(builder, output);\n\n  const isAllowSyntheticDefaultImports = isSyntheticDefaultImportsAllow(\n    output.tsconfig,\n  );\n\n  const indexFilePath =\n    output.mock && !isFunction(output.mock) && output.mock.indexMockFiles\n      ? upath.join(\n          dirname,\n          'index.' + getMockFileExtensionByTypeName(output.mock!) + extension,\n        )\n      : undefined;\n  if (indexFilePath) {\n    await fs.outputFile(indexFilePath, '');\n  }\n\n  const generatedFilePathsArray = await Promise.all(\n    Object.entries(target).map(async ([tag, target]) => {\n      try {\n        const {\n          imports,\n          implementation,\n          implementationMock,\n          importsMock,\n          mutators,\n          clientMutators,\n          formData,\n          fetchReviver,\n          formUrlEncoded,\n          paramsSerializer,\n        } = target;\n\n        let implementationData = header;\n        let mockData = header;\n\n        const relativeSchemasPath = output.schemas\n          ? '../' +\n            upath.relativeSafe(\n              dirname,\n              getFileInfo(output.schemas, { extension: output.fileExtension })\n                .dirname,\n            )\n          : '../' + filename + '.schemas';\n\n        const importsForBuilder = generateImportsForBuilder(\n          output,\n          imports,\n          relativeSchemasPath,\n        );\n\n        implementationData += builder.imports({\n          client: output.client,\n          implementation,\n          imports: importsForBuilder,\n          specsName,\n          hasSchemaDir: !!output.schemas,\n          isAllowSyntheticDefaultImports,\n          hasGlobalMutator: !!output.override.mutator,\n          hasTagsMutator: Object.values(output.override.tags).some(\n            (tag) => !!tag.mutator,\n          ),\n          hasParamsSerializerOptions: !!output.override.paramsSerializerOptions,\n          packageJson: output.packageJson,\n          output,\n        });\n\n        const importsMockForBuilder = generateImportsForBuilder(\n          output,\n          importsMock,\n          relativeSchemasPath,\n        );\n\n        mockData += builder.importsMock({\n          implementation: implementationMock,\n          imports: importsMockForBuilder,\n          specsName,\n          hasSchemaDir: !!output.schemas,\n          isAllowSyntheticDefaultImports,\n          options: isFunction(output.mock) ? undefined : output.mock,\n        });\n\n        const schemasPath = output.schemas\n          ? undefined\n          : upath.join(dirname, filename + '.schemas' + extension);\n\n        if (schemasPath && needSchema) {\n          const schemasData = header + generateModelsInline(builder.schemas);\n\n          await fs.outputFile(schemasPath, schemasData);\n        }\n\n        if (mutators) {\n          implementationData += generateMutatorImports({\n            mutators,\n            implementation,\n            oneMore: true,\n          });\n        }\n\n        if (clientMutators) {\n          implementationData += generateMutatorImports({\n            mutators: clientMutators,\n            oneMore: true,\n          });\n        }\n\n        if (formData) {\n          implementationData += generateMutatorImports({\n            mutators: formData,\n            oneMore: true,\n          });\n        }\n        if (formUrlEncoded) {\n          implementationData += generateMutatorImports({\n            mutators: formUrlEncoded,\n            oneMore: true,\n          });\n        }\n        if (paramsSerializer) {\n          implementationData += generateMutatorImports({\n            mutators: paramsSerializer,\n            oneMore: true,\n          });\n        }\n\n        if (fetchReviver) {\n          implementationData += generateMutatorImports({\n            mutators: fetchReviver,\n            oneMore: true,\n          });\n        }\n\n        if (implementation.includes('NonReadonly<')) {\n          implementationData += getOrvalGeneratedTypes();\n          implementationData += '\\n';\n        }\n\n        if (implementation.includes('TypedResponse<')) {\n          implementationData += getTypedResponse();\n          implementationData += '\\n';\n        }\n\n        implementationData += `\\n${implementation}`;\n        mockData += `\\n${implementationMock}`;\n\n        const implementationFilename =\n          tag +\n          (OutputClient.ANGULAR === output.client ? '.service' : '') +\n          extension;\n\n        const implementationPath = upath.join(\n          dirname,\n          tag,\n          implementationFilename,\n        );\n        await fs.outputFile(implementationPath, implementationData);\n\n        const mockPath = output.mock\n          ? upath.join(\n              dirname,\n              tag,\n              tag +\n                '.' +\n                getMockFileExtensionByTypeName(output.mock) +\n                extension,\n            )\n          : undefined;\n\n        if (mockPath) {\n          await fs.outputFile(mockPath, mockData);\n          if (indexFilePath) {\n            const localMockPath = upath.joinSafe(\n              './',\n              tag,\n              tag + '.' + getMockFileExtensionByTypeName(output.mock!),\n            );\n            fs.appendFile(\n              indexFilePath,\n              `export { get${pascal(tag)}Mock } from '${localMockPath}'\\n`,\n            );\n          }\n        }\n\n        return [\n          implementationPath,\n          ...(schemasPath ? [schemasPath] : []),\n          ...(mockPath ? [mockPath] : []),\n        ];\n      } catch (error) {\n        throw new Error(\n          `Oups... 🍻. An Error occurred while splitting tag ${tag} => ${error}`,\n        );\n      }\n    }),\n  );\n\n  return generatedFilePathsArray.flat();\n};\n","import fs from 'fs-extra';\n\nimport { generateModelsInline, generateMutatorImports } from '../generators';\nimport type { WriteModeProps } from '../types';\nimport {\n  camel,\n  getFileInfo,\n  isFunction,\n  isSyntheticDefaultImportsAllow,\n  kebab,\n  upath,\n} from '../utils';\nimport { generateImportsForBuilder } from './generate-imports-for-builder';\nimport { generateTargetForTags } from './target-tags';\nimport { getOrvalGeneratedTypes, getTypedResponse } from './types';\n\nexport const writeTagsMode = async ({\n  builder,\n  output,\n  specsName,\n  header,\n  needSchema,\n}: WriteModeProps): Promise<string[]> => {\n  const { filename, dirname, extension } = getFileInfo(output.target, {\n    backupFilename: camel(builder.info.title),\n    extension: output.fileExtension,\n  });\n\n  const target = generateTargetForTags(builder, output);\n\n  const isAllowSyntheticDefaultImports = isSyntheticDefaultImportsAllow(\n    output.tsconfig,\n  );\n\n  const generatedFilePathsArray = await Promise.all(\n    Object.entries(target).map(async ([tag, target]) => {\n      try {\n        const {\n          imports,\n          implementation,\n          implementationMock,\n          importsMock,\n          mutators,\n          clientMutators,\n          formData,\n          formUrlEncoded,\n          fetchReviver,\n          paramsSerializer,\n        } = target;\n\n        let data = header;\n\n        const schemasPathRelative = output.schemas\n          ? upath.relativeSafe(\n              dirname,\n              getFileInfo(output.schemas, { extension: output.fileExtension })\n                .dirname,\n            )\n          : './' + filename + '.schemas';\n\n        const importsForBuilder = generateImportsForBuilder(\n          output,\n          imports.filter(\n            (imp) => !importsMock.some((impMock) => imp.name === impMock.name),\n          ),\n          schemasPathRelative,\n        );\n\n        data += builder.imports({\n          client: output.client,\n          implementation,\n          imports: importsForBuilder,\n          specsName,\n          hasSchemaDir: !!output.schemas,\n          isAllowSyntheticDefaultImports,\n          hasGlobalMutator: !!output.override.mutator,\n          hasTagsMutator: Object.values(output.override.tags).some(\n            (tag) => !!tag.mutator,\n          ),\n          hasParamsSerializerOptions: !!output.override.paramsSerializerOptions,\n          packageJson: output.packageJson,\n          output,\n        });\n\n        if (output.mock) {\n          const importsMockForBuilder = generateImportsForBuilder(\n            output,\n            importsMock,\n            schemasPathRelative,\n          );\n\n          data += builder.importsMock({\n            implementation: implementationMock,\n            imports: importsMockForBuilder,\n            specsName,\n            hasSchemaDir: !!output.schemas,\n            isAllowSyntheticDefaultImports,\n            options: isFunction(output.mock) ? undefined : output.mock,\n          });\n        }\n\n        const schemasPath = output.schemas\n          ? undefined\n          : upath.join(dirname, filename + '.schemas' + extension);\n\n        if (schemasPath && needSchema) {\n          const schemasData = header + generateModelsInline(builder.schemas);\n\n          await fs.outputFile(schemasPath, schemasData);\n        }\n\n        if (mutators) {\n          data += generateMutatorImports({ mutators, implementation });\n        }\n\n        if (clientMutators) {\n          data += generateMutatorImports({\n            mutators: clientMutators,\n          });\n        }\n\n        if (formData) {\n          data += generateMutatorImports({ mutators: formData });\n        }\n\n        if (formUrlEncoded) {\n          data += generateMutatorImports({ mutators: formUrlEncoded });\n        }\n\n        if (paramsSerializer) {\n          data += generateMutatorImports({ mutators: paramsSerializer });\n        }\n\n        if (fetchReviver) {\n          data += generateMutatorImports({ mutators: fetchReviver });\n        }\n\n        data += '\\n\\n';\n\n        if (implementation.includes('NonReadonly<')) {\n          data += getOrvalGeneratedTypes();\n          data += '\\n';\n        }\n\n        if (implementation.includes('TypedResponse<')) {\n          data += getTypedResponse();\n          data += '\\n';\n        }\n\n        data += implementation;\n\n        if (output.mock) {\n          data += '\\n\\n';\n\n          data += implementationMock;\n        }\n\n        const implementationPath = upath.join(\n          dirname,\n          `${kebab(tag)}${extension}`,\n        );\n        await fs.outputFile(implementationPath, data);\n\n        return [implementationPath, ...(schemasPath ? [schemasPath] : [])];\n      } catch (error) {\n        throw new Error(\n          `Oups... 🍻. An Error occurred while writing tag ${tag} => ${error}`,\n        );\n      }\n    }),\n  );\n\n  return generatedFilePathsArray.flat();\n};\n"],"mappings":"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"}